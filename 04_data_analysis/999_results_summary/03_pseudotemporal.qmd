---
title: EndoMT pseudotime
execute:
  eval: true
code-fold: true
---

```{r}
here::i_am("04_data_analysis/001_snrnaseq_analysis/16_pathway_analysis.qmd")
```

The "EndoMT" population looks to be some kind of transitioning celltype, perhaps endothelial cells transitioning to mural cells, or some more broad stem cell population that could go in both/more directions.
<!-- So let's try doing some pseudotime analysis to see what trajectories might be there . -->

# Load packages

```{r}
source(here::here("04_data_analysis/990_code_libraries/02_library-calls-for-renv.R"))
Sys.setenv(TAR_PROJECT = here::here())
tar_config_set(store = here::here("_targets"))
library(SeuratWrappers)
library(monocle3)
library(slingshot)
```

```{r}
# Get seurat object
tar_load(sce)
tar_load(gene_ids)

assertthat::assert_that(sum(rownames(sce@assays$RNA@counts) ==
                              gene_ids$ensembl) == nrow(gene_ids))
```

```{r}
DimPlot(sce, reduction = "umap", group.by = "highlevel_manual_annotations",
        label = TRUE)
DimPlot(sce, reduction = "umap", group.by = "subcelltype_annotations",
        label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "highlevel_manual_annotations",
        label = TRUE)
```

## Microglia-A

Want to check if we see microglia-a align along case/control

### Subset to celltypes

```{r}
# Subset to EndoMT
rownames(sce@assays$RNA@data) <- gene_ids$ensembl
sce_microglia <- subset(sce, subcelltype_annotations %in% c("Microglia-activated"))
# these two donors are clustered annoyingly, try removing them
#sce_microglia <- subset(sce_microglia, donor %in% c("donor-17", "donor-36"), invert = TRUE)
```

```{r}
options(future.globals.maxSize = 4000 * 1024^2) ## 4 GB
sce_microglia <- NormalizeData(sce_microglia)
sce_microglia <- FindVariableFeatures(sce_microglia)
sce_microglia <- ScaleData(sce_microglia)
```

```{r}
ElbowPlot(sce_microglia, ndims = 50)
sce_microglia <- RunPCA(sce_microglia, dims = 1:40)
sce_microglia <- RunUMAP(sce_microglia, dims = 1:40)
```

```{r}
# This resolution is good to recapture the level 2 celltypes
#sce_microglia <- FindClusters(sce_microglia, resolution = 0.3)
# this is good to reduce the celltypes to three main clusters
sce_microglia <- FindClusters(sce_microglia, resolution = 0.1)
```


```{r}
p1 <- DimPlot(sce_microglia, reduction = "umap", group.by = "diagnosis",
              label = TRUE)
p2 <- DimPlot(sce_microglia, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(sce_microglia, reduction = "umap", group.by = "donor",
              label = TRUE)
p1|p2
p1 <- DimPlot(sce_microglia, reduction = "pca", group.by = "diagnosis",
              label = TRUE)
p2 <- DimPlot(sce_microglia, reduction = "pca", group.by = "seurat_clusters",
              label = TRUE)
p1|p2
DimPlot(sce_microglia, reduction = "pca", group.by = "donor",
              label = TRUE)
```

```{r}
# Extract PCA embeddings
pca_embeddings <- Embeddings(sce_microglia, reduction = "pca")

# Create a data frame for the first two principal components
pca_df <- data.frame(PC1 = pca_embeddings[, 1], PC2 = pca_embeddings[, 2],
                     diagnosis = sce_microglia$diagnosis)

library(ggpointdensity)
# Generate the density plot
p1 <- ggplot(pca_df, aes(x = PC1, y = PC2)) +
  geom_pointdensity() +
  #geom_point(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Density Plot of First Two Principal Components",
       x = "PC1",
       y = "PC2") +
  facet_wrap(~diagnosis)
p2 <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = diagnosis)) +
  geom_pointdensity() +
  #geom_point(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Density Plot of First Two Principal Components",
       x = "PC1",
       y = "PC2")
p1|p2
```

```{r}
pca_df <- data.frame(pca_embeddings[, 1:30], diagnosis = sce_microglia$diagnosis)

plot_pcs <- function(i) {
  pc_x <- paste0("PC_", i)
  pc_y <- paste0("PC_", i + 1)
  ggplot(pca_df, aes_string(x = pc_x, y = pc_y)) +
    geom_pointdensity() +
    theme_minimal() +
    labs(title = paste(pc_x, "vs", pc_y),
         x = pc_x,
         y = pc_y,
         color = "diagnosis") +
    facet_wrap(~ diagnosis)
}

# Generate scatter plots for PC1 vs PC2, PC3 vs PC4, ..., PC29 vs PC30 using lapply
plots <- lapply(seq(1, 29, by = 2), plot_pcs)

# Arrange plots in a grid
plots <- do.call(grid.arrange, c(plots, ncol = 3))
```


## Monocle 3

```{r}
cds <- as.cell_data_set(sce_microglia)
fData(cds)$gene_short_name <- rownames(cds)


# assign paritions
reacreate.partition <- c(rep(1,length(cds@colData@rownames)))
names(reacreate.partition) <- cds@colData@rownames
reacreate.partition <- as.factor(reacreate.partition)

cds@clusters$UMAP$partitions <- reacreate.partition
cds@clusters$PCA$partitions <- reacreate.partition

# Assign the cluster info
list_cluster <- sce_microglia@active.ident
cds@clusters$UMAP$clusters <- list_cluster
cds@clusters$PCA$clusters <- list_cluster

# Assign UMAP coordinate - cell embeddings
cds@int_colData@listData$reducedDims$UMAP <- sce_microglia@reductions$umap@cell.embeddings
cds@int_colData@listData$reducedDims$PCA <- sce_microglia@reductions$pca@cell.embeddings
```


```{r}
# plot
cluster.before.trajectory <- plot_cells(cds,
           color_cells_by = 'cluster',
           label_groups_by_cluster = FALSE,
           group_label_size = 5) +
  theme(legend.position = "right")

cluster.names <- plot_cells(cds,
           color_cells_by = "diagnosis",
           label_groups_by_cluster = FALSE,
           group_label_size = 5) +
  #scale_color_manual(values = c('red', 'blue', 'green', 'maroon', 'yellow', 'grey', 'cyan')) +
  theme(legend.position = "right")

cluster.before.trajectory | cluster.names
```


```{r}
#| eval: false

# This is with 30 dims used in umap

# ...3. Learn trajectory graph ------------------------
cds <- learn_graph(cds, use_partition = TRUE, verbose = TRUE)

plot_cells(cds, color_cells_by = "diagnosis")

# ...4. Order the cells in pseudotime -------------------

# Try setting the cases cells as root
cds <- order_cells(cds, reduction_method = 'UMAP', root_cells = colnames(cds[,clusters(cds) == 1]))
endomt_as_root <- plot_cells(cds,
           color_cells_by = 'pseudotime',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE) +
  ggtitle("EndoMT cluster (middle cluster) as root")

# Try setting the control cells as the root
cds <- order_cells(cds, reduction_method = 'UMAP', root_cells = colnames(cds[,clusters(cds) == 0]))
capilary_as_root <- plot_cells(cds,
           color_cells_by = 'pseudotime',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE) +
  ggtitle("Capillary cluster (left cluster) as root")


capilary_as_root | endomt_as_root

#ggsave(here::here("05_figures/990_shared_figures/004_pseudotime/monocle3_capilary_and_endomt_as_root_pseudotime_res0.1.png"),
#       width = 20)
# cells ordered by monocle3 pseudotime

cds$monocle3_pseudotime <- pseudotime(cds)
data.pseudo <- as.data.frame(colData(cds))

pseudotime_boxplots <- ggplot(data.pseudo,
                              aes(monocle3_pseudotime,
                                  reorder(manual_annotations,
                                          monocle3_pseudotime, median),
                                  fill = diagnosis)) +
  geom_boxplot()
pseudotime_boxplots
pseudotime_boxplots <- ggplot(data.pseudo,
                              aes(monocle3_pseudotime,
                                  reorder(manual_annotations,
                                          monocle3_pseudotime, median),
                                  fill = donor)) +
  geom_boxplot() +
  facet_wrap(~diagnosis)
pseudotime_boxplots


pseudotime_boxplots <- data.pseudo |>
  rownames_to_column("cell") |>
  ggplot(aes(monocle3_pseudotime,
             fill = diagnosis,
             alpha = 0.5)) +
  geom_density()
pseudotime_boxplots
#ggsave(here::here("05_figures/990_shared_figures/004_pseudotime/monocle3_capilary_as_root_boxplots_res0.1.png"))
pseudotime_boxplots <- ggplot(data.pseudo,
                              aes(monocle3_pseudotime,
                                  reorder(manual_annotations,
                                          monocle3_pseudotime, median),
                                  fill = diagnosis)) +
  geom_boxplot()
```

- switchde/tradeseq  - look at genes along pseudotime

```{r}
#| eval: false
# ...5. Finding genes that change as a function of pseudotime --------------------
deg_bcells <- graph_test(cds, neighbor_graph = 'principal_graph', cores = 4)

deg_bcells |>
  arrange(q_value) |>
  filter(status == 'OK') |>
  head()

FeaturePlot(sce, features = c('E2F2', 'STMN1', 'CD52'))
```

```{r}
cds_sub <- choose_graph_segments(cds)
```

```{r}
#| eval: false
# visualizing pseudotime in seurat
sce$pseudotime <- pseudotime(cds)
Idents(sce) <- sce$redefined_cluster
FeaturePlot(sce, features = "pseudotime", label = T)
```

## Slingshot
## EndoMT

### Subset to celltypes

```{r}
# Subset to EndoMT
rownames(sce@assays$RNA@data) <- gene_ids$ensembl
sce <- subset(sce, highlevel_manual_annotations %in% c("SMC", "Pericyte", "mystery-cluster", "Endothelial"))
# remove unneded cells
sce <- subset(sce, subcelltype_annotations %in% c("Oligo-A", "Astrocyte-activated"), invert = TRUE)
```

```{r}
sce <- NormalizeData(sce)
sce <- FindVariableFeatures(sce)
sce <- ScaleData(sce)
```

```{r}
sce <- RunPCA(sce, dims = 1:30)
sce <- RunUMAP(sce, dims = 1:30)
ElbowPlot(sce, ndims = 30)
```

```{r}
# This resolution is good to recapture the level 2 celltypes
#sce <- FindClusters(sce, resolution = 0.3)
# this is good to reduce the celltypes to three main clusters
sce <- FindClusters(sce, resolution = 0.05)
```


```{r}
DimPlot(sce, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(sce, reduction = "umap", group.by = "highlevel_manual_annotations",
              label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "seurat_clusters",
              label = TRUE)
```

```{r}
p1 <- DimPlot(sce, reduction = "umap", group.by = "subcelltype_annotations",
              label = TRUE)
p2 <- DimPlot(sce, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)
p1|p2
p1 <- DimPlot(sce, reduction = "umap", group.by = "highlevel_manual_annotations",
              label = TRUE)
p2 <- DimPlot(sce, reduction = "pca", group.by = "highlevel_manual_annotations",
              label = TRUE)
p1|p2
```

```{r}
# Extract PCA embeddings
pca_embeddings <- Embeddings(sce, reduction = "pca")

# Create a data frame for the first two principal components
pca_df <- data.frame(PC1 = pca_embeddings[, 1], PC2 = pca_embeddings[, 2],
                     celltype = sce$highlevel_manual_annotations)

library(ggpointdensity)
# Generate the density plot
p1 <- ggplot(pca_df, aes(x = PC1, y = PC2)) +
  geom_pointdensity() +
  #geom_point(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Density Plot of First Two Principal Components",
       x = "PC1",
       y = "PC2") +
  facet_wrap(~celltype)
p2 <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = celltype)) +
  geom_pointdensity() +
  #geom_point(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Density Plot of First Two Principal Components",
       x = "PC1",
       y = "PC2")
p1|p2
```

```{r}
# Create a data frame for the first 30 principal components and cell type annotations
pca_df <- data.frame(pca_embeddings[, 1:30], CellType = sce$highlevel_manual_annotations)

# Function to create scatter plots for each pair of PCs
plot_pcs <- function(i) {
  pc_x <- paste0("PC_", i)
  pc_y <- paste0("PC_", i + 1)
  ggplot(pca_df, aes_string(x = pc_x, y = pc_y, color = "CellType")) +
    geom_point(alpha = 0.5) +
    theme_minimal() +
    labs(title = paste(pc_x, "vs", pc_y),
         x = pc_x,
         y = pc_y,
         color = "Cell Type")
}

# Generate scatter plots for PC1 vs PC2, PC3 vs PC4, ..., PC29 vs PC30 using lapply
plots <- lapply(seq(1, 29, by = 2), plot_pcs)

# Arrange plots in a grid
plots <- do.call(grid.arrange, c(plots, ncol = 3))
ggsave(here::here("05_figures/990_shared_figures/004_pseudotime/first_30_pcs.png"), plots, width = 20, height = 15)

# Function to create scatter plots for each pair of PCs
plot_pcs <- function(i) {
  pc_x <- paste0("PC_", i)
  pc_y <- paste0("PC_", i + 1)
  ggplot(pca_df, aes_string(x = pc_x, y = pc_y)) +
    geom_pointdensity() +
    theme_minimal() +
    labs(title = paste(pc_x, "vs", pc_y),
         x = pc_x,
         y = pc_y,
         color = "Cell Type") +
    facet_wrap(~ CellType)
}

# Generate scatter plots for PC1 vs PC2, PC3 vs PC4, ..., PC29 vs PC30 using lapply
plots <- lapply(seq(1, 29, by = 2), plot_pcs)

# Arrange plots in a grid
plots <- do.call(grid.arrange, c(plots, ncol = 3))
ggsave(here::here("05_figures/990_shared_figures/004_pseudotime/first_30_pcs_facet.png"), plots, width = 20, height = 15)
```

```{r}
sce <- RunPCA(sce, npcs = 2)
# This splits the pericyte and smcs
sce <- FindClusters(sce, resolution = 0.1)
sce <- RunUMAP(sce, dims = 1:2)
```

```{r}
sce$highlevel_manual_annotations <- if_else(sce$highlevel_manual_annotations == "mystery-cluster", "EndoMT", sce$highlevel_manual_annotations)
```

```{r}
# Subset to just your transitionary population
Idents(sce) <- sce$highlevel_manual_annotations
endo_transition <- subset(sce, idents = "EndoMT")

# Rerun preprocessing on just this population
options(future.globals.maxSize = 30000 * 1024^2) ## 30 GB
endo_transition <- SCTransform(endo_transition)
endo_transition <- RunPCA(endo_transition, npcs = 2)
endo_transition <- RunUMAP(endo_transition, dims = 1:2)

# Find subclusters
endo_transition <- FindNeighbors(endo_transition, dims = 1:2)
endo_transition <- FindClusters(endo_transition, resolution = 0.02)

DimPlot(endo_transition, reduction = "pca", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(endo_transition, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)

# Get new clusters
subclusters <- case_when(
  Idents(endo_transition) == 0 ~ "EndoMT_1",
  Idents(endo_transition) == 1 ~ "EndoMT_2",
  Idents(endo_transition) == 2 ~ "EndoMT_1",
  .default = NA)

names(subclusters) <- colnames(endo_transition)

# Create a vector the same length as your original object, filled with NAs
new_clusters <- rep(NA, ncol(sce))
names(new_clusters) <- colnames(sce)

# Fill in the subcluster identities for the transitionary cells
new_clusters[names(subclusters)] <- subclusters

# Add this as a new metadata column
sce$endomt_subclusters <- new_clusters

# Update Idents
new_clusters[is.na(new_clusters)] <- sce$highlevel_manual_annotations[is.na(new_clusters)]
qs::qsave(new_clusters,
          here("03_data/990_processed_data/008_pseudotime",
          "endomt_subclusters.qs"))
Idents(sce) <- new_clusters
sce$level1_celltypes_with_endomt_subclusters <- Idents(sce)
```


```{r}
DimPlot(sce, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(sce, reduction = "umap", group.by = "highlevel_manual_annotations",
              label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "level1_celltypes_with_endomt_subclusters",
              label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "diagnosis",
              label = TRUE)
```

## Monocle 3

```{r}
cds <- as.cell_data_set(sce)
fData(cds)$gene_short_name <- rownames(cds)


# assign paritions
reacreate.partition <- c(rep(1,length(cds@colData@rownames)))
names(reacreate.partition) <- cds@colData@rownames
reacreate.partition <- as.factor(reacreate.partition)

cds@clusters$UMAP$partitions <- reacreate.partition
cds@clusters$PCA$partitions <- reacreate.partition

# Assign the cluster info
list_cluster <- sce@active.ident
cds@clusters$UMAP$clusters <- list_cluster
cds@clusters$PCA$clusters <- list_cluster

# Assign UMAP coordinate - cell embeddings
cds@int_colData@listData$reducedDims$UMAP <- sce@reductions$umap@cell.embeddings
cds@int_colData@listData$reducedDims$PCA <- sce@reductions$pca@cell.embeddings
```


```{r}
# plot
cluster.before.trajectory <- plot_cells(cds,
           color_cells_by = 'cluster',
           label_groups_by_cluster = FALSE,
           group_label_size = 5) +
  theme(legend.position = "right")

cluster.names <- plot_cells(cds,
           color_cells_by = "subcelltype_annotations",
           label_groups_by_cluster = FALSE,
           group_label_size = 5) +
  #scale_color_manual(values = c('red', 'blue', 'green', 'maroon', 'yellow', 'grey', 'cyan')) +
  theme(legend.position = "right")

cluster.before.trajectory | cluster.names
```


```{r}
#| eval: false

# This is with 30 dims used in umap

# ...3. Learn trajectory graph ------------------------
cds <- learn_graph(cds, use_partition = TRUE, verbose = TRUE)

plot_cells(cds, color_cells_by = "subcelltype_annotations")

# ...4. Order the cells in pseudotime -------------------

cds <- order_cells(cds)

plot_cells(cds,
           color_cells_by = 'pseudotime',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE)

# Try setting the EndoMT cells as root
cds <- order_cells(cds, reduction_method = 'UMAP', root_cells = colnames(cds[,clusters(cds) == 3]))
endomt_as_root <- plot_cells(cds,
           color_cells_by = 'pseudotime',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE) +
  ggtitle("EndoMT cluster (middle cluster) as root")

# Try setting the capilary cells as the root
cds <- order_cells(cds, reduction_method = 'UMAP', root_cells = colnames(cds[,clusters(cds) == 0]))
capilary_as_root <- plot_cells(cds,
           color_cells_by = 'pseudotime',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE) +
  ggtitle("Capillary cluster (left cluster) as root")


capilary_as_root | endomt_as_root

ggsave(here::here("05_figures/990_shared_figures/004_pseudotime/monocle3_capilary_and_endomt_as_root_pseudotime_res0.1.png"),
       width = 20)
# cells ordered by monocle3 pseudotime

cds$monocle3_pseudotime <- pseudotime(cds)
data.pseudo <- as.data.frame(colData(cds))

pseudotime_boxplots <- ggplot(data.pseudo,
                              aes(monocle3_pseudotime,
                                  reorder(manual_annotations,
                                          monocle3_pseudotime, median),
                                  fill = manual_annotations)) +
  geom_boxplot()
pseudotime_boxplots
ggsave(here::here("05_figures/990_shared_figures/004_pseudotime/monocle3_capilary_as_root_boxplots_res0.1.png"))
```

```{r}
#| eval: false
# ...5. Finding genes that change as a function of pseudotime --------------------
deg_bcells <- graph_test(cds, neighbor_graph = 'principal_graph', cores = 4)

deg_bcells |>
  arrange(q_value) |>
  filter(status == 'OK') |>
  head()

FeaturePlot(sce, features = c('E2F2', 'STMN1', 'CD52'))
```

```{r}
cds_sub <- choose_graph_segments(cds)
```

```{r}
#| eval: false
# visualizing pseudotime in seurat
sce$pseudotime <- pseudotime(cds)
Idents(sce) <- sce$redefined_cluster
FeaturePlot(sce, features = "pseudotime", label = T)
```

## Slingshot

```{r}
# Convert Seurat object to SingleCellExperiment
sce_slingshot <- as.SingleCellExperiment(sce)
```

```{r}
#| eval: false
# Run Slingshot
sce_slingshot <- slingshot(sce_slingshot, clusterLabels = 'highlevel_manual_annotations', reducedDim = 'UMAP')
# Plot the trajectory
png(here::here("05_figures/990_shared_figures/004_pseudotime/slingshot_umap.png"))
plot(reducedDims(sce_slingshot)$UMAP, col = sce$highlevel_manual_annotations, pch = 16, asp = 1)
lines(SlingshotDataSet(sce_slingshot), lwd = 2)
dev.off()
```


```{r}
#| eval: false
# Run Slingshot on PCA
sce_slingshot <- slingshot(sce_slingshot, clusterLabels = 'highlevel_manual_annotations', reducedDim = 'PCA')
# Plot the trajectory
png(here::here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca.png"))
plot(reducedDims(sce_slingshot)$PCA, col = sce$highlevel_manual_annotations, pch = 16, asp = 1)
lines(SlingshotDataSet(sce_slingshot), lwd = 2)
dev.off()
```

```{r}
sce_slingshot <- slingshot(
  sce_slingshot,
  clusterLabels = 'level1_celltypes_with_endomt_subclusters',
  start.clus = "Endothelial",
  reducedDim = 'PCA'
)
png(here::here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca_endothelial_start_ndim2_res0.1.png"))
plot(reducedDims(sce_slingshot)$PCA, col = sce$level1_celltypes_with_endomt_subclusters, pch = 16, asp = 1)
lines(SlingshotDataSet(sce_slingshot), lwd = 2)
dev.off()
```

```{r}
# 1. Plot PCA with Slingshot trajectory
pca <- reducedDims(sce_slingshot)$PCA
lineages <- slingCurves(sce_slingshot)

qs::qsave(sce_slingshot, here("03_data/990_processed_data/008_pseudotime",
                              "slingshot_obj.qs"))
# sce_slingshot <- qs::qread(here("03_data/990_processed_data/008_pseudotime",
#                               "slingshot_obj.qs"))

celltype <- sce_slingshot$level1_celltypes_with_endomt_subclusters
celltype <- str_replace(celltype, "_", "-")

# Plot PCA colored by cell type
# Flip x-axis
p_pca <- ggplot(as.data.frame(pca), aes(x = -PC_1, y = PC_2)) +
  geom_point(aes(color = celltype),
             size = 0.8, alpha = 0.6) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  labs(x = "PC1", y = "PC2", color = "Celltype &\nLineage") +
  scale_color_npg()
  #scale_color_brewer(palette = "Dark2")

# Add arrows to the curves
curves <- map2_dfr(lineages, names(lineages), ~ .x$s |>
           as.data.frame() |>
           mutate(lineage = .y)) |>
  mutate(lineage = if_else(lineage == "Lineage1", "EndoMT-SMC Lienage",
                           "EndoMT-PC Lineage"))

# Add arrows using geom_path and arrow.decoration
p_pca <- p_pca +
  geom_path(data = curves,
            aes(x = -PC_1, y = PC_2, colour = lineage), # Note the negative PC_1
            linewidth = 1.1,
            arrow = arrow(type = "closed",
                         length = unit(0.1, "inches"),
                         ends = "last"))

# Calculate centroids for each cell type
centroids <- data.frame(
  PC_1 = pca[, 1],
  PC_2 = pca[, 2],
  CellType = celltype) |>
  group_by(CellType) |>
  summarise(
    mean_PC1 = mean(PC_1),
    mean_PC2 = mean(PC_2)
  )
 p_pca_labeled <- p_pca +
  geom_text_repel(
    data = centroids,
    aes(x = -mean_PC1, y = mean_PC2, label = CellType),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    force = 10,
    segment.color = "grey50",
    segment.size = 0.5,
    max.overlaps = Inf
  )

print(p_pca_labeled)

ggsave(here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca_npc2_res0.1.png"), height = 8, width = 10)


# Extract pseudotimes
pseudotime <- slingPseudotime(sce_slingshot)

# Convert to data frame for ggplot
pseudotime_df <- data.frame(
  Pseudotime1 = pseudotime[,1],
  Pseudotime2 = pseudotime[,2],
  Group = sce_slingshot$diagnosis
)

# Plot Pseudotime for Lineage 1
p1 <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 1", x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 2
p2 <- ggplot(pseudotime_df, aes(x = Pseudotime2, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 2", x = "Pseudotime", y = "Density")

# Combine the density plots side by side
p_density <- plot_grid(p1, p2, labels = c("A", "B"))

print(p_density)

# Convert to data frame for ggplot
pseudotime_df <- data.frame(
  Cell = colnames(sce_slingshot),
  Pseudotime1 = pseudotime[,1],
  Pseudotime2 = pseudotime[,2],
  Group = sce_slingshot$diagnosis,
  CellType = sce_slingshot$level1_celltypes_with_endomt_subclusters
)

# Plot Pseudotime for Lineage 1
p1_diagnosis <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 1", x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 2
p2_diagnosis <- ggplot(pseudotime_df, aes(x = Pseudotime2, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 2", x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 1 with Cell Type
p1_no_facet <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 1 by Cell Type", x = "Pseudotime", y = "Density")

p2_no_facet <- ggplot(pseudotime_df, aes(x = Pseudotime2, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 2 by Cell Type", x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 2 with Cell Type
p1 <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = CellType)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  facet_wrap(~ Group) +  # Separate plots for cases and controls
  labs(x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 2 with Cell Type
p2 <- ggplot(pseudotime_df, aes(x = Pseudotime2, fill = CellType)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  facet_wrap(~ Group) +  # Separate plots for cases and controls
  labs(x = "Pseudotime", y = "Density")

# Combine the density plots side by side
p_density <- plot_grid(p1, p2, labels = c("A", "B"))

(p1_no_facet + p2_no_facet) / (p1 + p2)

ggsave(here("05_figures/990_shared_figures/004_pseudotime/slingshot_density_npc2_res0.1.png"), height = 8, width = 10)

print(p_density)


p1 <- ggplot(data.frame(pca, pseudotime), aes(PC_1, PC_2, color = Lineage1)) +
  geom_point(alpha = 0.7) +
  scale_color_viridis_c(option = 'plasma', name = 'Pseudotime') +
  labs(x = 'PC1', y = 'PC2') +
  theme_minimal()
```

### Density plot

```{r}
pseudotime_data <- data.frame(slingPseudotime(sce_slingshot))
pseudotime_data <- pseudotime_data |>
  dplyr::mutate(
    Group = sce_slingshot$diagnosis,
    CellType = sce_slingshot$level1_celltypes_with_endomt_subclusters
  ) |>
  pivot_longer(cols = starts_with("Lineage"),
               names_to = "lineage",
               values_to = "Pseudotime") |>
  dplyr::mutate(celltype_reduced = case_when(
    CellType %in% c("EndoMT_1", "EndoMT_2") ~ "EndoMT-1/2",
    CellType %in% c("Pericyte", "SMC") ~ "Pericyte/SMC",
    .default = CellType)) |>
  dplyr::filter(!is.na(Pseudotime))
```

```{r}
#| eval: false

# Calculate cell type abundance per pseudotime bin
celltype_abundance <- pseudotime_data |>
  dplyr::group_by(Pseudotime = cut(Pseudotime, breaks = 5)) %>%
  dplyr::count(celltype_reduced) %>%
  dplyr::group_by(Pseudotime) %>%
  dplyr::slice_max(n, n = 1) %>%
  dplyr::ungroup()

density <- celltype_abundance$Pseudotime |>
  str_remove_all("]") |> str_remove_all("\\(") |> str_split(",") |>
  map_dfr(~ data.frame("min" = as.numeric(.x[1]), "max" = as.numeric(.x[2]))) |>
  cbind("celltype" = celltype_abundance$celltype_reduced) |>
  dplyr::mutate(Pseudotime = 10)

# Prepare density data for each lineage and group
density_data <- lapply(lineage_names, function(lineage) {
  pseudotime_data %>%
    filter(!is.na(Pseudotime[, lineage])) %>%
    group_by(Group) %>%
    summarise(
      density = density(Pseudotime[, lineage],
                        from = min(Pseudotime[, lineage], na.rm = TRUE),
                        to = max(Pseudotime[, lineage], na.rm = TRUE))
    )
})

density_plot <- ggplot(pseudotime_data, aes(x = Pseudotime, fill = Group)) +
  geom_density(alpha = 0.7) +
  theme_minimal() +
  labs(x = "Pseudotime", y = "Density") +
  facet_wrap(~lineage) +
  geom_rect(data = density,
            aes(xmin = min, xmax = max, ymin = 0, ymax = 0.15,
                fill = celltype), alpha = 0.2)
density_plot
```

```{r}
pseudotime_data <- pseudotime_data |>
  dplyr::mutate(Group = if_else(Group == "Case", "AD", Group),
                lineage = if_else(lineage == "Lineage1", "EndoMT-SMC Lienage",
                           "EndoMT-PC Lineage"))

# Calculate cell type proportions per pseudotime bin
celltype_proportions <- pseudotime_data |>
  dplyr::group_by(Pseudotime = cut(Pseudotime, breaks = 5), lineage) |>
  dplyr::group_by(Pseudotime, lineage, celltype_reduced) |>
  dplyr::summarise(count = n(), .groups = "drop") |>
  dplyr::group_by(Pseudotime, lineage) |>
  dplyr::mutate(proportion = count / sum(count)) |>
  dplyr::slice_max(proportion, n = 1) |>
  dplyr::ungroup()

# Create initial bar positions and consolidate consecutive same cell types
annotation_bars <- celltype_proportions |>
  dplyr::mutate(
    interval = Pseudotime |>
      str_remove_all("]") |>
      str_remove_all("\\(") |>
      str_split(","),
    xmin = map_dbl(interval, ~ as.numeric(.x[1])),
    xmax = map_dbl(interval, ~ as.numeric(.x[2]))
  ) |>
  # Group by lineage and cell type, then consolidate consecutive bins
  dplyr::group_by(lineage) |>
  dplyr::arrange(lineage, xmin) |>
  dplyr::mutate(
    group_id = cumsum(celltype_reduced != dplyr::lag(celltype_reduced, default = dplyr::first(celltype_reduced)))
  ) |>
  dplyr::group_by(lineage, celltype_reduced, group_id) |>
  dplyr::summarise(
    xmin = min(xmin),
    xmax = max(xmax),
    .groups = "drop"
  ) |>
  dplyr::mutate(
    x_mid = (xmin + xmax) / 2,
    ymin = 0.15,
    ymax = 0.16,
    label_y = 0.165
  )

# Create the density plot with consolidated annotation bars
density_plot <- ggplot() +
  geom_density(data = pseudotime_data,
               aes(x = Pseudotime, fill = Group),
               alpha = 0.7) +
  geom_rect(data = annotation_bars,
            aes(xmin = xmin, xmax = xmax,
                ymin = ymin, ymax = ymax,
                fill = celltype_reduced),
            inherit.aes = FALSE) +
  geom_text(data = annotation_bars,
            aes(x = x_mid, y = label_y, label = celltype_reduced),
            size = 2,
            #angle = 45,
            hjust = 0.5,
            inherit.aes = FALSE) +
  scale_fill_manual(
    values = c(
      "Control" = "#DC0000FF",
      "AD" = "#4DBBD4FF",
      "EndoMT-1/2" = "#E64B35FF",
      "Pericyte/SMC" = "#91D1C2FF",
      "Endothelial" = "#F39B7FFF",
      "Fibroblast" = "#7E6148FF"
    ),
    breaks = c("Control", "AD")
  ) +
  #scale_fill_npg(breaks = c("Control", "AD")) +
  theme_minimal() +
  labs(x = "Pseudotime", y = "Density", fill = "") +
  facet_wrap(~lineage) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.2)))
  #theme(plot.margin = margin(t = 40, r = 20, b = 20, l = 20, unit = "pt"))

density_plot

# TODO make colours consitent
```

## tradeseq results

tradeseq takes ages to run, I had to subset to 1K cells per celltype to get it to finish in a reasonable time

The associationTest function gives the wald stat, the degrees of freedom and the unadjusted p-vals associated with each gene.
By default it doesn't test for each lineage independently.

```{r}
library(tradeSeq)
# Read in data from hawk
sce_subset <- qs::qread(here("03_data/990_processed_data/008_pseudotime/slingshot_tradeseq_3k_case_and_control.qs"))

asso_res <- associationTest(sce_subset, lineages = TRUE)
asso_res_overall <- associationTest(sce_subset)
asso_res |> head(2) |> write_tsv("temp.txt")
# asso_res_consec <- associationTest(sce_subset, lineages = TRUE, contrastType = "consecutive")
# asso_res_consec |> head()

# Function to tidy the tradeseq output
tidy_tradeseq <- function(data) {
  # First, get the base columns that don't need splitting
  base_cols <- c("waldStat", "df", "pvalue")

  data <- data |>
    rownames_to_column("ensembl_gene_id")

  # Find columns that need to be split (those containing underscores)
  split_cols <- names(data)[grepl("_", names(data))]

  # Create the base dataframe with non-split columns
  base_df <- data[c(base_cols, "ensembl_gene_id")] |>
    dplyr::mutate(lineage = "overall")

  # Process the split columns
  if (sum(grepl("condition", split_cols)) > 0) {
    base_df$condition <- "overall"
    split_data <- data |>
      dplyr::select(all_of(split_cols)) |>
      pivot_longer(
        cols = -ensembl_gene_id,
        names_to = c(".value", "lineage", "condition"),
        names_pattern = "(.*)_lineage(\\d+)_condition(.*)"
      )
  } else {
    split_data <- data |>
      dplyr::select(all_of(split_cols)) |>
      pivot_longer(
        cols = -ensembl_gene_id,
        names_to = c(".value", "lineage"),
        names_pattern = "(.*)_lineage(\\d+)"
      )
  }

  result <- rbind(split_data, base_df)
  # Add logfc back in
  if (sum(grepl("condition", split_cols)) > 0) {
  result <- data[c("ensembl_gene_id", "meanLogFC")] |>
    dplyr::left_join(x = result, y = _, by = "ensembl_gene_id")
  }
  return(result)
}

asso_res_tidy <- tidy_tradeseq(asso_res) |>
  dplyr::left_join(translated_id, by = "ensembl_gene_id")

# Get top 10 genes per condition and lineage
top_genes <- asso_res_tidy |>
  dplyr::filter(hgnc_symbol != "" | !is.na(hgnc_symbol)) |>
  dplyr::group_by(condition, lineage) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE) |>
  dplyr::ungroup() |>
  dplyr::filter(pvalue == 0)

table(top_genes$lineage, top_genes$condition)

top_controls <- top_genes |>
  dplyr::filter(condition == "Control") |>
  slice_max(waldStat, n = 25, with_ties = FALSE, by = c(condition, lineage)) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)

pdf(here("05_figures/990_shared_figures/004_pseudotime/01_tradeseq/",
                       "top_controls_pseudotime_degs.pdf"),
       height = 12, width = 20)
map2(top_controls$ensembl_gene_id, top_controls$hgnc_symbol, ~ plotSmoothers(sce_subset, counts, .x) +
    ggtitle(.y))
dev.off()

# CNTN1 looks unique to lineage 1!
lineage_genes <- c("CHF", "TFPI", "PDK4", "ITGA3", "JARID2", "CYTH3", "ZNF207",
                   "SLC6A13", "FYN", "MRC2", "DCN", "RUFY3", "CNTN1", "ATP1A2",
                   "NR1H3", "PRKCH", "ZFHX3", "FLT1", "ATP10A", "PLEKHG1",
                   "RORA", "IGF1R", "SLC6A1", "LAMA2", "SLC6A12", "SORBS1",
                   "SEC14L1", "PDE3A")

top_lineage_degs <- top_genes |>
  dplyr::filter(hgnc_symbol %in% lineage_genes)

# Get stats for the all genes overall across all lineages and conditions
plot_gene_pseudotime <- function(gene, gene_symbol, sce, counts) {
  plot <- plotSmoothers(sce, counts, gene, curvesCols = pal_npg("nrc")(4)) +
    scale_colour_npg(labels = c("EndoMT-SMC - AD", "EndoMT-SMC - Control",
                                "EndoMT-PC - AD",
                                "EndoMT-PC - Control")) +
    ggtitle(if_else(gene_symbol == "", gene, gene_symbol)) +
    labs(colour = "Lineage") +
    theme(legend.position = "none")
  return(plot)
}

counts <- assays(sce_subset)$counts

plot_lineages <- map2(unique(top_lineage_degs$ensembl_gene_id),
                      unique(top_lineage_degs$hgnc_symbol),
              plot_gene_pseudotime, sce_subset, counts)

plot_lineages[[5]] <- plot_lineages[[5]] +
  theme(legend.position = "right")


plot <- plot_grid(plotlist = plot_lineages, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "top_lineage_pseudotime_degs.png"),
       height = 14, width = 18)
```

## Key genes for figure

```{r}
key_genes <- translated_id |>
  dplyr::filter(hgnc_symbol %in% c("BACE2", "APOD"))

plot_lineages <- map2(unique(key_genes$ensembl_gene_id),
                      unique(key_genes$hgnc_symbol),
              plot_gene_pseudotime, sce_subset, counts)
apod <- plot_lineages[[2]] +
  theme(legend.position = "bottom")

# extract a legend that is laid out horizontally
legend_b <- get_legend(
  apod +
    guides(color = guide_legend(nrow = 1)) +
    theme(legend.position = "bottom")
)
prow <- plot_grid(apod + theme(legend.position = "none"), plot_lineages[[1]])
key_genes_plot <- plot_grid(prow, legend_b, ncol = 1, rel_heights = c(1, 0.1))

key_genes <- translated_id |>
  dplyr::filter(grepl("^ANG", hgnc_symbol)) |>
  dplyr::filter(ensembl_gene_id %in% rownames(counts))

plot_lineages <- map2(unique(key_genes$ensembl_gene_id),
                      unique(key_genes$hgnc_symbol),
              plot_gene_pseudotime, sce_subset, counts)
plot_lineages[[5]] <- plot_lineages[[5]] +
  theme(legend.position = "right")


plot <- plot_grid(plotlist = plot_lineages, ncol = 3)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "ANG_genes.png"),
       height = 14, width = 18)
```

## Build figure

```{r}
plot <- plot_grid(p_pca_labeled, density_plot, key_genes_plot,
                   ncol = 1, labels = "AUTO",
                  rel_heights = c(1.2, 1, 1))
plot
ggsave(here::here("05_figures/990_shared_figures/003_final_figures",
                  "endomt_fig.pdf"), plot, width = 7, height = 9, units = "in")
#plot_grid(p_pca_labeled, density_plot, key_genes_plot, labels = "AUTO", nrow = 3)
```


```{r}
x <- predictSmooth(sce_subset, "ENSG00000000971")

x <- x |> dplyr::mutate(lineage_condition = paste0("Lienage-", lineage, "_", condition))
plot_example <- plotSmoothers(sce_subset, counts, "ENSG00000000971")


ggplot(x, aes(x = time, y = log(yhat + 1), colour = lineage_condition)) +
  geom_point() +
#  geom_smooth(linewidth = 1) +
  # Add confidence interval ribbon if you have SE columns
  # geom_ribbon(aes(ymin = yhat - 2 * SE, ymax = yhat + 2 * SE),
  #             alpha = 0.2,
  #             fill = "blue")+
  theme_bw() +
  labs(x = "Pseudotime",
       y = "Expression",
       title = "Gene Expression over Pseudotime") +
  theme(panel.grid.minor = element_blank())

```

### Get best lineage genes

It's difficult to identify the genes most differential between lineages for the EndoMTs.
I'll get the area under the curve between a range of pseudotime I'm interested in for each group and then get the mean AUC for each lineage and the difference between cases and controls for the lineage.
Then I can try to identify the genes with the biggest lineage AUC difference and plots those to see if this works, and hopefully identify the most relevant genes.

```{r}
# Get all genes with a p-value of 0
all_top_genes <- top_genes |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)

table(all_top_genes$condition, all_top_genes$lineage)

smoothed_values <- predictSmooth(sce_subset,
                                 gene = unique(all_top_genes$ensembl_gene_id),
                                 nPoints = 100)
library(pracma)

compute_auc <- function(pseudotime, expression) {
  auc <- trapz(pseudotime, expression)
  return(auc)
}

pseudotime_ranges = list(c(0, 10), c(11, 20), c(21, 30),
                         c(31, max(smoothed_values$time)), c(15, 28),
                         c(0, max(smoothed_values$time)))
names(pseudotime_ranges) <- c("0-10", "11-20", "21-30", "30+", "15-28", "overall")
subset_smoothed_values <- map(pseudotime_ranges, ~ {
  smoothed_values |>
    dplyr::filter(time >= .x[1] & time <= .x[2])
})

auc_results <- map2(subset_smoothed_values, names(subset_smoothed_values), ~ {
  .x |>
    summarize(AUC = compute_auc(time, yhat),
              pseudotime_range = .y,
              .by = c(gene, lineage, condition))
}) |>
  list_rbind()
```

```{r}
# Get the difference between lineage 1 and 2 for controls
lin_diff <- auc_results |>
  as_tibble() |>
  dplyr::filter(condition == "Control") |>
  dplyr::summarise(lin1_minus_lin2 = AUC[lineage == 1] - AUC[lineage == 2], .by = c(pseudotime_range, gene))

top_lin_diff <- lin_diff |>
  dplyr::left_join(translated_id, by = join_by(gene == ensembl_gene_id)) |>
  dplyr::filter(hgnc_symbol != "") |>
  dplyr::slice_max(abs(lin1_minus_lin2), by = pseudotime_range, n = 12) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)
head(top_lin_diff)

top_lin_plots <- map2(top_lin_diff$gene, top_lin_diff$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

top_lin_plots[[1]]
top_lin_plots[[5]] <- top_lin_plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = top_lin_plots, ncol = 5)
plot
ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "top_lineage_4_pseudotime_bins.png"),
       height = 18, width = 18)
```

```{r}
# Get the difference between cases and controls per lineage
condition_diff <- auc_results |>
  as_tibble() |>
  dplyr::summarise(case_minus_control = AUC[condition == "Case"] -
                     AUC[condition == "Control"],
                   .by = c(pseudotime_range, gene, lineage))

top_cond_diff <- condition_diff |>
  dplyr::left_join(translated_id, by = join_by(gene == ensembl_gene_id)) |>
  dplyr::filter(hgnc_symbol != "") |>
  dplyr::slice_max(abs(case_minus_control), by = c(pseudotime_range, lineage),
                   n = 10) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)
head(top_cond_diff)

top_cond_plots <- map2(top_cond_diff$gene, top_cond_diff$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)
top_cond_plots[[5]] <- top_cond_plots[[5]] +
  theme(legend.position = "right")
plot <- plot_grid(plotlist = top_cond_plots, ncol = 5)
plot
ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "top_condition_4_pseudotime_bins.png"),
       height = 15, width = 18)
```


### patternTest

tradeseq has a function to check lineage sig gene

```{r}
lineage_genes <- patternTest(sce_subset)

# adjust pval and filter on fold change
get_top_genes <- function(df, fc_column, fc_filter = 2) {
  top_genes <- df |>
    rownames_to_column("ensembl_gene_id") |>
    as_tibble() |>
    dplyr::mutate(padj = p.adjust(pvalue, "bonferroni")) |>
    dplyr::filter(padj == 0 & abs({{ fc_column }}) > fc_filter) |>
    left_join(translated_id, by = "ensembl_gene_id") |>
    dplyr::filter(hgnc_symbol != "") |>
    dplyr::arrange(desc({{ fc_column }}))
  return(top_genes)
}

top_lin_genes <- get_top_genes(lineage_genes, fcMedian)

readr::write_csv(top_lin_genes,
                 here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_lineage_genes.csv"))

dim(top_lin_genes)
top_genes <- top_lin_genes |>
  slice_max(fcMedian, n = 20)

plots <- map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[5]]
plots[[5]] <- plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "lineage_patterntest_top20.png"),
       height = 8, width = 18)
```

#### Lineage differentiating genes

List of genes that appear to be different between lineages, but not cases/controls:

- UST, CAP2, SLC12A7, FILIP1, CASQ2, TMEM131L, NR4A1, RHOJ, FOXP2, MYH11, PDZD2, TRPC3, MYOCD, ACKR3, DENND2A, PARD3, JPH2, SCN3A, PID1, ABCA9, SORBS2, ADAMTS1, PDE1C, TTN, COLEC12, PLXDC1, PDE7B, SH3RF3, SLC19A1, ERBB4, GRM8, LAMA2, RYR2, NR2F1âˆ’AS1, MIR100HG
- Note: RHOJ is also different in cases for lienage 2 at least
### Top early genes

#### Condition differential genes

- SLC38A2, SSTR2, RHOJ, LINC00472, LINC00882

```{r}
diff_early_genes <- tradeSeq::earlyDETest(sce_subset)

top_diff_early_genes <- get_top_genes(diff_early_genes, fcMedian)

readr::write_csv(top_diff_early_genes,
                 here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_diff_early_genes.csv"))

top_genes <- top_diff_early_genes |>
  slice_max(logFC1_2, n = 20)

plots <- map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[5]]
plots[[5]] <- plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "diff_early_genes_top20.png"),
       height = 10, width = 18)
```

### Top end genes

```{r}
# Assuming you've already run fitGAM
# Test for differential expression across pseudotime
# For lineage-specific differences
diff_end_genes <- tradeSeq::diffEndTest(sce_subset)

# Adjust p-values and filter logfc
top_diff_end_genes <- get_top_genes(diff_end_genes, logFC1_2)

readr::write_csv(top_diff_end_genes,
                 here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_diff_end_genes.csv"))

top_genes <- top_diff_end_genes |>
  # get genes that are unique to end genes
  dplyr::filter(!(ensembl_gene_id %in% top_diff_early_genes$ensembl_gene_id)) |>
  slice_max(logFC1_2, n = 20)

plots <- map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[5]]
plots[[5]] <- plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "diff_end_genes_top20.png"),
       height = 10, width = 18)
```

### Condition test

The `conditionTest` function test genes across conditions.
It can give overall genes, and per lineage, so I'll check both

```{r}
lineages <- conditionTest(sce_subset, lineages = TRUE, pairwise = TRUE)

lineages_tidy <- tidy_tradeseq(lineages)

top_genes_condition <- lineages_tidy |>
  dplyr::filter(pvalue == 0) |>
  dplyr::left_join(translated_id, by = "ensembl_gene_id") |>
  dplyr::filter(hgnc_symbol != "" & !is.na(hgnc_symbol))

length(unique(top_genes_condition$hgnc_symbol))
table(top_genes_condition$lineage)

readr::write_csv(top_genes_condition,
                 here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_condition_genes.csv"))

top_genes <- top_genes_condition |>
  slice_sample(n = 10, by = lineage)

plots <- map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[5]]
plots[[5]] <- plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "top_condition_genes.png"),
       height = 14, width = 18)
```

#### Hypergeometric pathways

It seems only lineage 2 has any pathway enrichment, and only in MF.

```{r}
genes <- top_genes_condition |>
  tidyr::nest(.by = lineage)

# plan("multisession", workers = parallel::detectCores() - 1)
go_results_all <- map(genes$data, ~ enrichGO(gene = .x$ensembl_gene_id, OrgDb = "org.Hs.eg.db",
                                    keyType = "ENSEMBL", ont = "ALL",
                                    universe = rownames(sce_subset)))
                           # .options = furrr_options(seed = 123))

names(go_results_all) <- genes$lineage

go_results_filtered <- go_results_all |>
  purrr::keep(~ !is.null(.)) |>
  purrr::keep(~ nrow(.) > 0)

# Apply pairwise_termism where possible
go_results_filtered <- map(go_results_filtered, ~{
  if(length(.x$ID) >= 2) {
    pairwise_termsim(.x)
  } else {
    .x
  }
})

# dotplots
dotplots <-
  map2(
    go_results_filtered,
    names(go_results_filtered),
    ~ dotplot(.x, showCategory = 20, split = "ONTOLOGY") + facet_grid(. ~ ONTOLOGY) +
      ggtitle(paste0(.y, " - Sig genes only"))
  )
dotplots
```


### All genes of interest

It might be nice to make a list and perhaps pdf of all the unique genes of interest accross the comparisons

```{r}
df <- list(top_diff_early_genes, top_diff_end_genes, top_genes_condition,
           top_lin_genes)
genes <- map(df, dplyr::pull, hgnc_symbol)
genes <- unique(unlist(genes))

cat("Number of unique genes of interest:", length(genes))
```

### Additional genes to plot


```{r}
additional_genes <- translated_id |>
  dplyr::filter(hgnc_symbol %in% c("BACE2", "APOD", "MEF2C", "NOTCH1")) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)

plots <- map2(additional_genes$ensembl_gene_id,
              additional_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[2]]
plots[[2]] <- plots[[2]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 2)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "additional_genes.png"),
       height = 6, width = 12)
```

### Transcription factors

Check if the genes are transcription factors, it might be of particular interest if there's some in the early diff genes.

```{r}
# Load required libraries
library(org.Hs.eg.db)
library(dplyr)
library(httr)
library(jsonlite)

# Function to check transcription factors using multiple methods
comprehensive_tf_check <- function(gene_list) {
  # Initialize results dataframe
  results <- data.frame(
    Gene = gene_list,
    Is_TF = NA,
    TF_Sources = NA,
    stringsAsFactors = FALSE
  )

  # 1. GO Annotation Check
  go_tf_term <- "GO:0003700"  # Transcription factor activity
  go_results <- tryCatch({
    go_annotations <- AnnotationDbi::select(org.Hs.eg.db,
                             keys = gene_list,
                             columns = c("GOALL"),
                             keytype = "SYMBOL")
    go_tf_genes <- go_annotations$SYMBOL[grep(go_tf_term, go_annotations$GOALL)]
    go_tf_genes
  }, error = function(e) c())

  # 2. TFClass Database Check (via manual API/web query simulation)
  tfclass_check <- sapply(gene_list, function(gene) {
    tryCatch({
      # Note: This is a simulated approach as TFClass doesn't have a direct R API
      url <- paste0("http://tfclass.bioinf.med.uni-goettingen.de/tfclass/cgi-bin/tfclass.py?VERSION=1.22&DATASET=TF&SPECIES=Homo%20sapiens&GENE=", gene)
      response <- GET(url)
      content <- content(response, "text")
      grepl("Transcription Factor", content)
    }, error = function(e) FALSE)
  })

  # 3. Literature-based TF Databases (simulated with known TFs)
  known_tfs <- c(
    "STAT3", "TP53", "MYC", "FOXO1", "NRF2", "CREB1",
    "ELK1", "SP1", "NFKB1", "HIF1A", "REST", "BRCA1"
  )

  # Combine results
  for (i in seq_along(gene_list)) {
    gene <- gene_list[i]
    sources <- c()

    # Check GO annotation
    if (gene %in% go_tf_genes) {
      sources <- c(sources, "GO_Annotation")
    }

    # Check TFClass
    if (tfclass_check[gene]) {
      sources <- c(sources, "TFClass")
    }

    # Check known TFs
    if (gene %in% known_tfs) {
      sources <- c(sources, "Literature_Known_TFs")
    }

    # Determine overall TF status
    results$Is_TF[i] <- length(sources) > 0
    results$TF_Sources[i] <- ifelse(length(sources) > 0,
                                    paste(sources, collapse = "; "),
                                    "No TF Evidence")
  }

  return(results)
}


# Early transcrition factors
early_tf <- comprehensive_tf_check(unique(top_diff_early_genes$hgnc_symbol))
table(early_tf$TF_Sources)
early_tf <- early_tf |>
  dplyr::filter(Is_TF) |>
  dplyr::left_join(translated_id, by = join_by(Gene == hgnc_symbol))

plots <- map2(early_tf$ensembl_gene_id,
              early_tf$Gene,
              plot_gene_pseudotime, sce_subset, counts)

plots[[4]]
plots[[4]] <- plots[[4]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 4)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "early_diff_tf_genes.png"),
       height = 6, width = 14)


all_tf <- comprehensive_tf_check(unique(genes))
all_tf <- all_tf |>
  dplyr::filter(Is_TF) |>
  dplyr::left_join(translated_id, by = join_by(Gene == hgnc_symbol))

readr::write_csv(all_tf,
                 here("03_data/990_processed_data/008_pseudotime",
                      "all_transcription_factors.csv"))

plots <- map2(all_tf$ensembl_gene_id,
              all_tf$Gene,
              plot_gene_pseudotime, sce_subset, counts)

plots[[4]]
plots[[4]] <- plots[[4]] +
  theme(legend.position = "right")

# Vectorized PDF creation
pdf(here::here("05_figures/990_shared_figures/004_pseudotime",
         "01_tradeseq", "all_transcription_factors.pdf"),
    width = 11, height = 8)

# Split the plot list into chunks of 4
plot_chunks <- split(plots, ceiling(seq_along(plots)/4))

# Use map to apply grid.arrange to each chunk
walk(plot_chunks, function(chunk) {
  do.call(grid.arrange, c(chunk, ncol = 2, nrow = 2))
})

dev.off()

table(all_tf$TF_Sources)
```

Zam flagged there TFs as being visually interesting

```{r}
lineage1_genes <- c("ZBTB7C", "PRDM17", "JPH2", "NR4A1", "PPARG", "ZFHX3", "NR4A3", "FOSL2", "ETV6")
lineage2_genes <- c("RORA", "FOXP2", "ESRRG", "DACH1", "TCF4")

# If you want a named vector approach
lineage_genes <- c(
  setNames(lineage1_genes, rep("Lineage1", length(lineage1_genes))),
  setNames(lineage2_genes, rep("Lineage2", length(lineage2_genes)))
)
```

```{r}
# If you used fitGAM, you can extract information directly
cell_data <- data.frame(
  pseudotime = slingPseudotime(sce_subset),
  condition = sce_slingshot$diagnosis,
  lineage = slingLineages(sce_slingshot)
)

pseudotime <- slingPseudotime(sce_slingshot) |>
  as.data.frame()
pseudotime$condition <- colData(sce_slingshot)$diagnosis

# Extract count matrix from slingshot object
count_matrix <- assay(sce_slingshot)

genes_to_check <- translated_id |>
  dplyr::filter(hgnc_symbol %in% c("BACE2"))
# Extract expression for your gene of interest
gene_expr <- count_matrix[genes_to_check$ensembl_gene_id, ]

# Combine pseudotime and gene expression
plot_data <- data.frame(
  cell = colnames(count_matrix),
  expression = gene_expr,
  pseudotime_lineage1 = pseudotime$Lineage1,
  pseudotime_lineage2 = pseudotime$Lineage2,
  condition = sce_slingshot$diagnosis
)

head(plot_data)
assertthat::assert_that(sum(rownames(pseudotime) != plot_data$cell) == 0)

# Melt the data for easier plotting
plot_data <- plot_data |>
  pivot_longer(contains("_lineage"), names_to = "lineage", values_to = "pseudotime") |>
  dplyr::filter(!is.na(pseudotime)) |>
  dplyr::mutate(lineage = str_remove(lineage, "pseudotime_"))

# Plotting
ggplot(plot_data,
       aes(x = pseudotime,
           y = expression,
           color = condition,
           group = interaction(condition, lineage))) +
  geom_density(alpha = 0.5) +
#  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~ lineage, scales = "free") +
  labs(
    title = paste("Expression of", "blah", "Across Pseudotime"),
    x = "Pseudotime",
    y = "Normalized Expression"
  ) +
  theme_minimal()
```



```{r}
#| eval: false
top_genes <- translated_id |>
  dplyr::filter(hgnc_symbol %in% genes) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)

qs::qsave(top_genes, here("03_data/990_processed_data/008_pseudotime",
                          "all_genes_of_interest.qs"))

future::plan(multisession, workers = 10)
plot_list <- future_map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

# Vectorized PDF creation
pdf(here("05_figures/990_shared_figures/004_pseudotime",
         "01_tradeseq", "all_genes.pdf"), width = 11, height = 8)

# Split the plot list into chunks of 4
plot_chunks <- split(plot_list, ceiling(seq_along(plot_list)/4))

# Use map to apply grid.arrange to each chunk
walk(plot_chunks, function(chunk) {
  do.call(grid.arrange, c(chunk, ncol = 2, nrow = 2))
})

dev.off()
```


```{r}
#| eval: false

# Trying to add the celltypes to the background of the plot - not working

sce_slingshot <- qs::qread(here("03_data/990_processed_data/008_pseudotime",
                              "slingshot_obj.qs"))

sce_slingshot_sub <- sce_slingshot[, rownames(colData(sce_subset))]

pseudotime <- slingshot::slingPseudotime(sce_slingshot_sub)

df <- data.frame(
  cellTypes = sce_slingshot_sub$level1_celltypes_with_endomt_subclusters,
  pseudotime = pseudotime
)

pseudotime_df <- data.frame(
  Cell = colnames(sce_slingshot_sub),
  Pseudotime1 = pseudotime[,1],
  Pseudotime2 = pseudotime[,2],
  Group = sce_slingshot_sub$diagnosis,
  CellType = sce_slingshot_sub$level1_celltypes_with_endomt_subclusters
)

df <- pseudotime_df |>
  dplyr::mutate(pseudotime_agg = case_when(
    is.na(Pseudotime1) ~ Pseudotime2,
    is.na(Pseudotime2) ~ Pseudotime1,
    !is.na(Pseudotime1) & !is.na(Pseudotime2) ~ (Pseudotime1 + Pseudotime2) / 2,
    .default = NA
  )) |>
  dplyr::summarise(min_pseu = min(pseudotime_agg),
                   max_pseu = max(pseudotime_agg),
                   ymin = 0, ymax = 1, gene_count = 1, .by = CellType)

p1_diagnosis <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 1", x = "Pseudotime", y = "Density")
ggplot() + geom_rect(data = df,
                     aes(xmin = min_pseu, xmax = max_pseu, ymin = 0, ymax = 1, fill = CellType),
                     alpha = 0.2)

plot_controls[[1]] + geom_rect(data = df,
                     aes(xmin = min_pseu, xmax = max_pseu, ymin = ymin, ymax = ymax, fill = CellType),
                     alpha = 0.2)

plot_controls[[1]] + geom_density(data = pseudotime_df,
                     aes(x = ),
                     alpha = 0.2)


combined_data <- pseudotime_df |>
  pivot_longer(Pseudotime1:Pseudotime2, names_to = "lineage",
               values_to = "pseudotime") |>
  dplyr::filter(!is.na(pseudotime))

celltype_regions <- combined_data %>%
  group_by(lineage, CellType) %>%
  summarise(
    start = min(pseudotime),
    end = max(pseudotime),
    .groups = "drop"
  ) %>%
  dplyr::summarise(start = round(mean(start)),
                   end = round(mean(end)),
                   ymin = 0,
                   ymax = 1,
                   .by = CellType)

plot_controls[[1]] + geom_rect(data = celltype_regions,
              aes(xmin = start,
                  xmax = end,
                  ymin = min(plot_controls[[1]]$data$gene_count),
                  ymax = max(plot_controls[[1]]$data$gene_count),
                  fill = CellType),
              alpha = 0.2)

# Get y-axis limits from the plot data
y_min <- min(plot_controls[[1]]$data$gene_count)
y_max <- max(plot_controls[[1]]$data$gene_count)

# Add rectangles with fixed y limits
plot_lineages[[1]] +
    geom_rect(data = celltype_regions,
              aes(xmin = start,
                  xmax = end,
                  fill = CellType),
              ymin = y_min,
              ymax = y_max,
              alpha = 0.2)

plot_lineages[[1]]$data |> nrow()
plot_lineages[[1]] +
ggplot2::geom_rect(data = celltype_regions, aes(
    xmin = start,
    xmax = end,
    ymin = -Inf,
    ymax = Inf,
    fill = CellType
  ), alpha = 0.3)
plot_lineages[[1]] +
  #annotate("rect", xmin = 4, xmax = 5, ymin = 0, ymax = 4)
  geom_rect(aes(xmin=start, xmax=end, ymin=0, ymax=max(plot_lineages[[1]]$data$gene_count)), data = celltype_regions)

plot_lineages[[1]]
plot_data_df <- plot_lineages[[1]]$data |>
  dplyr::mutate(log_gene_count = log(gene_count + 1))

p <- ggplot() +
  geom_rect(aes(xmin=start, xmax=end, ymin=0,
                ymax=7,
                fill = CellType), alpha = 0.2, data = celltype_regions) +
  geom_smooth(data = plot_data_df, aes(x = time, y = log_gene_count, color = lineage)) +
  theme_minimal()
p
```


```{r}
#| eval: false

# format for the associations is annoying, function to reformat
# Should geneeralise this to an arbitrary number of lineages in future
analyse_pseudotime_genes <- function(asso_res, pval_adjust_method = "fdr") {

  # Get significant genes for each lineage
  genes_l1 <- asso_res |>
    dplyr::select(waldStat_1:pvalue_1) |>
    dplyr::rename(waldStat = waldStat_1, df = df_1, pvalue = pvalue_1) |>
    na.omit() |>
    dplyr::mutate(lineage = "1", p_adj = p.adjust(pvalue, pval_adjust_method))
  genes_l2 <- asso_res |>
    dplyr::select(waldStat_2:pvalue_2) |>
    dplyr::rename(waldStat = waldStat_2, df = df_2, pvalue = pvalue_2) |>
    na.omit() |>
    dplyr::mutate(lineage = "2", p_adj = p.adjust(pvalue, pval_adjust_method))
  genes_overall <- asso_res |>
    dplyr::select(waldStat:pvalue) |>
    na.omit() |>
    dplyr::mutate(lineage = "overall", p_adj = p.adjust(pvalue, pval_adjust_method))

  df <- rbind(genes_l1, genes_l2, genes_overall)
  df$ensembl <- rownames(df)
  asso_res$ensembl <- rownames(asso_res)
  df <- asso_res |>
    dplyr::select(ensembl, meanLogFC) |>
    dplyr::left_join(x = df, y = _, by = "ensembl")
  return(df)
}

tar_load(translated_id)
tradeseq_res <- analyse_pseudotime_genes(asso_res, "bonferroni") |>
  dplyr::left_join(translated_id, by = join_by(ensembl == ensembl_gene_id))
tradeseq_res_consec <- analyse_pseudotime_genes(asso_res_consec, "bonferroni") |>
  dplyr::left_join(translated_id, by = join_by(ensembl == ensembl_gene_id))

tradeseq_overall <- asso_res_overall |>
  dplyr::filter(!is.na(pvalue)) |>
  dplyr::mutate(p_adj = p.adjust(pvalue, "bonferroni")) |>
  rownames_to_column("ensembl")

tradeseq_sig_overall <- tradeseq_overall |>
  dplyr::filter(p_adj < 0.05) |>
  dplyr::left_join(translated_id, by = join_by(ensembl == ensembl_gene_id))

tradeseq_sig <- tradeseq_res |>
  dplyr::filter(p_adj < 0.05)
tradeseq_sig_consec <- tradeseq_res_consec |>
  dplyr::filter(p_adj < 0.05)

table(tradeseq_sig$lineage)
table(tradeseq_sig_consec$lineage)

counts <- assays(sce_subset)$counts
# For some reason this contains loads of genes not present in the counts?
tradeseq_sig <- tradeseq_res |>
  dplyr::filter(p_adj < 0.05 & ensembl %in% rownames(counts) & meanLogFC < 100)
tradeseq_sig_consec <- tradeseq_res_consec |>
  dplyr::filter(p_adj < 0.05 & ensembl %in% rownames(counts) & meanLogFC < 100)
# Plot for a gene
plotSmoothers(sce_subset, counts, rownames(counts)[1])

# get top genes
big_genes <- tradeseq_sig_consec |>
  slice_min(p_adj, by = lineage, n = 5) |>
  #dplyr::filter(meanLogFC > 2 | is.na(meanLogFC)) |>
  slice_max(abs(meanLogFC), by = lineage, n = 5) |>
  slice_sample(by = lineage, n = 5)

tradeseq_plots <- function(gene_id, gene_symbol) {
  plot <- plotSmoothers(sce_subset, counts, gene_id) +
    ggtitle(if_else(gene_symbol == "", gene_id, gene_symbol))
  return(plot)
}

plots <- map2(big_genes$ensembl, big_genes$hgnc_symbol, tradeseq_plots) |>
  set_names(big_genes$hgnc_symbol)

plot_grid(plotlist = plots, ncol = 5)

big_genes <- tradeseq_sig_overall |>
  slice_min(p_adj, n = 50) |>
  #dplyr::filter(meanLogFC > 2 | is.na(meanLogFC)) |>
  slice_sample(n = 15)

plots <- map2(big_genes$ensembl, big_genes$hgnc_symbol, tradeseq_plots) |>
  set_names(big_genes$hgnc_symbol)

plot_grid(plotlist = plots, ncol = 5)

```


## Condiment differential trajectory analysis

```{r}
library(tradeSeq)

sds <- SlingshotDataSet(sce_slingshot)
# Set up parallel processing
BPPARAM <- BiocParallel::bpparam()
BPPARAM$workers <- parallel::detectCores() - 2
BPPARAM

# Evaluate the optimal number of knots
set.seed(123)  # For reproducibility
k_values <- evaluateK(counts = assays(sce_slingshot)$counts, sds = sds,
                      nGenes = 500, k = 3:10, parallel = TRUE, BPPARAM = BPPARAM)
k_values
# Plot the evaluation results to choose the best k
plot(k_values)

optimal_k <- which.min(k_values$ic$BIC)
# Having a hard time running evaluateK, it's slow and seems to crash, I'll just try progressing with nknots of 6 (the default)
# Fit GAMs for each gene along the pseudotime
sce_slingshot <- fitGAM(counts = assays(sce_slingshot)$counts, pseudotime = slingPseudotime(sds, na = FALSE), cellWeights = slingCurveWeights(sds), nknots = 6, parallel = TRUE, BPPARAM = BPPARAM)

# Extract the model results
gam_results <- rowData(sce_slingshot)$tradeSeq
```

```{r}
#| eval: false
# Load required libraries
library(condiments)

# Assuming you have your data in a SingleCellExperiment object named 'sce'
# with a column in colData named 'condition' (e.g., "case" or "control")

# Perform differential progression analysis
diff_prog <- differentiationTest(sce_slingshot, sce_slingshot$diagnosis)

# View results
head(diff_prog)

# Visualize differential progression
plotDiffProgression(sce_slingshot, diff_prog, lineages = TRUE)

# Perform gene-level analysis
gene_fits <- fitGAM(sce_slingshot)

# Test for condition-specific gene expression
cond_test <- conditionTest(gene_fits)

# View top differentially expressed genes
top_genes <- rownames(cond_test)[order(cond_test$pvalue)[1:20]]
print(top_genes)

# Visualize condition-specific expression for top genes
plotGeneCount(sce_slingshot, gene_fits, top_genes[1:6])

# If you're interested in specific branching points:
branch_test <- branchTest(gene_fits)

# Visualize branching genes
plotBranchHeatmap(sce_slingshot, branch_test, pcutoff = 0.05)
```

```{r}
#| eval: false
# Run Slingshot on PCA
sce_slingshot <- slingshot(sce_slingshot, clusterLabels = 'highlevel_manual_annotations', start.clus = "mystery-cluster", reducedDim = 'PCA')
# Plot the trajectory
png(here::here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca_endomt_start-clus.png"))
# plot(reducedDims(sce_slingshot)$PCA, col = sce$highlevel_manual_annotations, pch = 16, asp = 1)
# lines(SlingshotDataSet(sce_slingshot), lwd = 2)
plot(reducedDims(sce_slingshot)$PCA, col = sce$highlevel_manual_annotations, pch=16, asp = 1)
lines(SlingshotDataSet(sce_slingshot), lwd=2, type = 'lineages', col = 'black')
dev.off()
```

```{r}
#| eval: false
# Extract pseudotime
pseudotime <- slingPseudotime(sce)

# Plot gene expression along pseudotime
plotGeneExpression <- function(gene) {
  plot(pseudotime, assays(sce)$logcounts[gene, ], pch = 16, col = sce$seurat_clusters)
  lines(smooth.spline(pseudotime, assays(sce)$logcounts[gene, ]), lwd = 2)
}

# Example for a specific gene
plotGeneExpression("Gene1")
```


```{r}
lin1 <- getLineages(reducedDims(sce_slingshot)$PCA, sce$highlevel_manual_annotations, start.clus = 'mystery-cluster')
lin1
png(here::here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca_endomt_start-clus_lineage_2pcs_res0.1.png"))
plot(reducedDims(sce_slingshot)$PCA,
     col = brewer.pal(9,"Set1")[sce$highlevel_manual_annotations],
     asp = 1, pch = 16, main = "Lineage with EndoMT as start cluster")
lines(SlingshotDataSet(lin1), lwd = 3, col = 'black')
dev.off()

lin1 <- getLineages(reducedDims(sce_slingshot)$PCA, sce$highlevel_manual_annotations, start.clus = 'Endothelial')
lin1
png(here::here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca_endothelial-clus_lineage_2pcs_res0.1.png"))
plot(reducedDims(sce_slingshot)$PCA,
     col = brewer.pal(9,"Set1")[sce$highlevel_manual_annotations],
     asp = 1, pch = 16, main = "Lineage with Endothelial as start cluster")
lines(SlingshotDataSet(lin1), lwd = 3, col = 'black')
dev.off()
```
