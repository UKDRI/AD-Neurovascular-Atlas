---
title: MAGMA - risk analysis prep
execute:
  eval: false
#self-contained: true
code-fold: true
bibliography: references.bib
---

I need to prep the MAGMA inputs, first I'll subset to controls and do differential expression of the celltypes against each other to get the MAGMA input.
I also need to subset to parenchymal and vascular fractions separately, so three control gene lists as input.

My understanding is the input format should be rows per celltypes and columns as gene IDs

```{r}
here::i_am("04_data_analysis/001_snrnaseq_analysis/18_magma_risk_analysis_prep.qmd")
```

# Load packages

```{r}
source(here::here("04_data_analysis/990_code_libraries/02_library-calls-for-renv.R"))
```

# Load data

```{r}
#| eval: true
# read data
sce <- readr::read_rds(here::here("03_data/990_processed_data/001_snrnaseq/07_scflow_analysis/scflow-sce-annotated-highlevel.rds"))
updated_annotations <- readr::read_rds(here::here("03_data/990_processed_data/001_snrnaseq/10_cell_subtypes/subcluster_annotations.rds"))
```

# Data prep

```{r}
# Gene ensembl IDs
gene_ensembl_ids <- data.frame(gene = rownames(sce@assays$RNA@data), ensembl = rownames(sce@assays$RNA@counts))
rownames(sce@assays$RNA@data) <- gene_ensembl_ids$ensembl

# Exclude the donor 31 celltypes
sce <- subset(sce, idents = c("Ependymal-donor31", "Astro-donor31"), invert = TRUE)
# Add annotations
sce$subcelltype_annotations <- updated_annotations[names(Idents(sce))]
```

Need the total number of genes for subsetting the celltype markers later

```{r}
total_genes <- nrow(sce[["RNA"]])
gene_percents <-
  list(
    "one" = round(total_genes * 0.01),
    "five" = round(total_genes * 0.05),
    "ten" = round(total_genes * 0.1)
  )
```

# Set subset

- All control celltypes
- Control vascular celltypes
- Control parenchymal celltypes

- Also set level 1 or level 2 celltypes

```{r}
# Set subset
#subset <- "all_controls"
#subset <- "controls_parenchymal"
subset <- "controls_vascular"

level <- "level1"
#level <- "level2"
```


```{r}
# Subset to controls
sce <- subset(sce, subset = diagnosis == "Control")

# Get T-Cell numbers
level1_counts <- table(Idents(sce))
level2_counts <- table(sce$subcelltype_annotations)
level1_counts[names(level1_counts) %in% "T-cell"]
level2_counts[grepl("T-cell", names(level2_counts))]

# Update mystery-cluster label
update_label <- c("mystery-cluster" = "Trans-Endo-to-mural")
sce <- RenameIdents(sce, update_label)
sce$highlevel_manual_annotations <- Idents(sce)

# Set celltype level
if(level == "level2") {
  Idents(sce) <- sce$subcelltype_annotations
}

if (subset == "controls_parenchymal") {
  # Subset to controls parenchymal
  sce <- subset(sce, subset = prep == "P")
} else if (subset == "controls_vascular") {
  # Subset to controls vascular
  sce <- subset(sce, subset = prep == "V")
}
```

Given that some of these fraction subsets will have very few of certain celltypes, I should remove these celltypes from the downstream analysis.
I'll just define a list of celltypes and exclude them from the relevant fraction

- Seperatre out migroglia in level 1 - vascualr to vascular, parenchymal to parenchymal 

```{r}
# Level 1 vascular celltypes
vascular_celltypes_level1 <- c("Trans-Endo-to-mural", "Endothelial", "Pericyte", 
                               "SMC", "Fibroblast", "T-cell")
vascular_celltypes_level2 <- c('T-Pericyte', 'M-Pericyte', 'Pericyte', 
                               'Pericyte-2', 'Vascular-SMC', 'Arteriolar-SMC', 
                               'Vascular-SMC-LINC00486', 'Trans-Endo-to-mural', 
                               'Perivascular-FB-KAZN2', 'Perivascular-FB', 
                               'Meningeal-FB', 'Artirial-FB', 'Pericyte-FB', 
                               'Capillary', 'Arterial', 'Venous', 
                               'T-cell-vascular')
# Get celltype counts
celltype_counts <- table(Idents(sce))
# Get the names of cell types with counts above the threshold
if (level == "level1" && subset == "controls_parenchymal") {
  celltypes_to_keep <-
    names(celltype_counts)[!names(celltype_counts) %in% vascular_celltypes_level1]
  # Subset the Seurat object to exclude vascular microglia
  sce <- subset(sce, subset = subcelltype_annotations != "Microglia-vascular")
} else if (level == "level1" && subset == "controls_vascular") {
  celltypes_to_keep <-
    names(celltype_counts)[names(celltype_counts) %in% vascular_celltypes_level1]
  # Add microglia back in
  celltypes_to_keep <- c(celltypes_to_keep, "Microglia")
  # Subset the Seurat object to exclude parenchymal microglia
  sce <- subset(sce, subset = subcelltype_annotations != "Microglia-quiescent")
  sce <- subset(sce, subset = subcelltype_annotations != "Microglia-activated")
} else if (level == "level2" && subset == "controls_parenchymal") {
  celltypes_to_keep <-
    names(celltype_counts)[!names(celltype_counts) %in% vascular_celltypes_level2]
} else if (level == "level2" && subset == "controls_vascular") {
  celltypes_to_keep <-
    names(celltype_counts)[names(celltype_counts) %in% vascular_celltypes_level2]
  celltypes_to_keep <- c(celltypes_to_keep, 'Microglia-vascular', 'T-cell-mixed')
} else {
  celltypes_to_keep <-
    names(celltype_counts)[!names(celltype_counts) %in% c("ambiguous", "low-feature-cells")]
}

# Subset the Seurat object to keep only the desired cell types
sce <- subset(sce, idents = celltypes_to_keep)
```

## Find celltype markers - normal way

<!-- - Note that I'm using MAST and adding donor as a latent variable to hopefully emulate a pseudobulk analysis -->
- Note that it probably makes sense to start this with the level 1 celltypes and then do the level two but subsetting to one level 1 celltype at a time to then check if one particular subtype is associated with the disease risk genes. It may also be the case that a highlevel type isn't associated, with the risk, but one of the level 2 types is...

```{r}
# File to save cluster markers to
file_name <-
  here::here("03_data/994_magma_inputs",
             paste0("cluster_markers_", level, "_", subset, ".tsv"))
# Only run if needed
if (!file.exists(file_name)) {
  # Set up future to use multiple cores
  plan("multisession", workers = 8)
  
  # Now run FindAllMarkers, it will use the future plan for parallel computation
  #all_markers <- FindAllMarkers(sce, min.pct = 0.25, logfc.threshold = 0.2, test.use = "MAST", latent.vars = "donor")
  all_markers <-
    FindAllMarkers(sce, min.pct = 0.25, logfc.threshold = 0.01)
  
  # Save data
  readr::write_tsv(all_markers, file_name)
} else {
  all_markers <- readr::read_tsv(file_name)
}
```

Apparently, the standard way of doing this is to take the top 10% of celltype markers by pvalue.
To my mind it makes more sense to filter to significant markers, and limit on logfc to get a smaller number of more celltype specific genes.

I guess we'll try to standard way first and check with a smaller subset later.

```{r}
#| eval: false
#| include: false
# Step 1: Split the dataframe by celltype
split_df <- split(all_markers, all_markers$cluster)

# Step 2: Calculate 10% of the number of genes per celltype and store the minimum size
top_percent <- 0.10
sizes <- sapply(split_df, function(x) ceiling(nrow(x) * top_percent))
min_size <- min(sizes)

# Step 3: Order each subset by p-value and select the top entries
top_genes_per_celltype <- lapply(split_df, function(x) {
  x <- x[order(x$p_val_adj), ]
  return(head(x, min_size))
})

# Step 4: If necessary, truncate each list to have the same number of genes
top_genes_per_celltype <- lapply(top_genes_per_celltype, function(x) head(x, min_size))

# Step 5: Combine the lists back into a single dataframe
final_df <- do.call(rbind, top_genes_per_celltype)
```

Then we need to get the data in a format where each row is a celltype and the columns are gene IDs.
Examples I've seen have entrez IDs, so will probably use those.

```{r}
# Get entrez IDs for genes
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
entrez_ids <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
                    filters = 'ensembl_gene_id',
                    values = all_markers$gene,
                    mart = ensembl)
# Remove rows with NA Entrez IDs if present
entrez_ids <- entrez_ids[!is.na(entrez_ids$entrezgene_id), ]

# Get unique Ensembl-Entrez pairs by keeping the first occurrence
entrez_ids <- entrez_ids[!duplicated(entrez_ids$ensembl_gene_id), ]

all_markers <- all_markers |>
  dplyr::left_join(unique(entrez_ids), by = join_by(gene == ensembl_gene_id))
```

Now subset to the top genes by p-value.
I'll try comparing the top 1, 5 and 10% of total genes per celltype.

```{r}
get_top_gene_subset <- function(df, percent_subset) {
  df <- df |>
    # Drop cases where entrez ID is missing
    dplyr::filter(!is.na(entrezgene_id))
  
  # Check if the minimum number of genes in a cellytpe is less than the % needed
  min_genes <- min(table(df$cluster))
  # If it is, then use the smallest number of genes possible
  if (min_genes < percent_subset) {
    print("WARNING: There are less genes than the percent subset")
    print(
      paste0(
        "There are: ",
        percent_subset,
        " genes needed, but there are only ",
        min_genes,
        " in the celltype with the lowest number of genes"
      )
    )
    percent_subset <- min_genes
  }
  
  top_genes_df <- df |>
    dplyr::group_by(cluster) |>
    slice_min(order_by = p_val_adj,
              n = percent_subset,
              with_ties = FALSE)
  # Count the number of genes for each celltype
  counts_per_celltype <- table(top_genes_df$cluster)
  # Test if all celltypes have the same number of genes
  assertthat::assert_that(all(counts_per_celltype == counts_per_celltype[1]))
  return(top_genes_df)
}
top_genes <-
  map(gene_percents, ~ get_top_gene_subset(all_markers, .x))
```

Save the data for LDscore

```{r}
# Function to extract genes for a given celltype and write them to a file
write_genes <- function(df, celltype, df_name) {
  genes <- df$gene[df$cluster == celltype]
  filename <- here::here("03_data/995_ldsc_inputs/01_celltype_markers",
                   paste0("ldsc_", celltype, "_", level, "_", subset, "_top-", 
                          df_name, "-percent.tsv"))
  writeLines(genes, filename)
}

# Function to process each dataframe
process_dataframe <- function(df, df_name) {
  unique_celltypes <- unique(df$cluster)
  map(unique_celltypes, ~write_genes(df, .x, df_name))
}

# Apply the process_dataframe function to each dataframe in the list
map(names(top_genes), ~process_dataframe(top_genes[[.x]], .x))
```

### Format data for MAGMA

Now I need to get the actual format for MAGMA.
It wants a file with no column headers, a row per celltype and space separated entrez gene IDs.

```{r}
prep_for_magma <- function(df) {
  # Group by celltype and concatenate the Entrez IDs into a space-separated string
  formatted_data <- df %>%
    dplyr::select(cluster, entrezgene_id) |>
    group_by(cluster) |>
    summarise(entrez_ids = paste(entrezgene_id, collapse = " "),
              .groups = 'drop')
  return(formatted_data)
}

formatted_data <- map(top_genes, prep_for_magma)

# Write the formatted data to a file with no headers and no row names
map2(formatted_data, names(formatted_data), ~ readr::write_tsv(.x,
                 here::here(
                   "03_data/994_magma_inputs",
                   paste0("magma_celltypes_", level, "_", subset, "_top-", .y, "-percent.tsv")
                 ),
                 col_names = FALSE))
```

# GWAS summary stats

One can search the [Open GWAS Project](https://gwas.mrcieu.ac.uk/) for traits of interest.

```{r}
#| eval: false
#### Search for datasets ####
metagwas <- MungeSumstats::find_sumstats(traits = c("parkinson","alzheimer", "stroke", "schizophrenia", "vascular dementia"), 
                                         min_sample_size = 5000)
unique(metagwas$trait)
```

The following takes the IDs of the GWAS data and downloads/formats them, returning a list of the IDs and their relevant formatted summary stats files.
Note that it saves to `tempdir()` by default, so files will be lost when the R session ends.

```{r}
#| eval: false
# There's a fair few, so I'll just get the latest major GWAS for Scz, PD and stroke
# I'll skip AD and Scz as I've already got those
ids <- c("ebi-a-GCST006906", "ieu-b-7")

datasets <- MungeSumstats::import_sumstats(ids = ids, 
                                           vcf_download = TRUE, 
                                           download_method = "axel", 
                                           nThread = max(2,future::availableCores()-2))
results_df <- data.frame(id=names(datasets),
                         path=unlist(datasets))
resutls_df
```

