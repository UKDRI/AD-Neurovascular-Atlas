---
title: Protein-protein interactions
execute:
  eval: true
#self-contained: true
code-fold: true
bibliography: references.bib
---

```{r}
here::i_am("04_data_analysis/001_snrnaseq_analysis/16_pathway_analysis.qmd")
```

# Load packages

```{r}
source(here::here("04_data_analysis/990_code_libraries/02_library-calls-for-renv.R"))
```

# Functions

Credit to Jimena for these functions, and indeed the basis for almost all the subsequent code.

```{r}

# Rescale data to range 0 to 1.
rescale01 <- function(numvect){
  rango <- range(numvect)
  rescalado <- unlist(lapply(numvect, function(x) if((x - rango[1]) == 0) { 0 } else {(x - rango[1]) / (rango[2] - rango[1])}))
  return(rescalado)
}

similar_gene_list  <- function(gene_list, attr_matrix, rango = 100){
  # attr_matrix must have at least a column with ensembl_gene_id and the rownames ordered by the attribute
  d_gl <- as.numeric(rownames(attr_matrix)[attr_matrix$ensembl_gene_id %in% gene_list])
  # Random sample of genes (most with a similar attribute)
  rango2 <- setdiff(seq(-rango/2, rango/2, 1), 0)
  rnd_ind <- sample(rango2, size = length(gene_list), replace = TRUE) 
  rnd_ind <- d_gl + rnd_ind
  # check the extremes (all should be within the range of D)
  if(length(which(rnd_ind < 1)) > 0) {
    rnd_ind[which(rnd_ind < 1)] <- sample(1:rango, 1)
  }
  if(length(which(rnd_ind > nrow(attr_matrix)))){
    rnd_ind[which(rnd_ind > nrow(attr_matrix))] <- sample(nrow(attr_matrix):(nrow(attr_matrix) - rango), 1)
  }
  # remove duplicates and replace with random genes (to keep gene number constant)
  if(length(rnd_ind) != length(unique(rnd_ind))){
    rnd_ind <- unique(rnd_ind)
    rnd_ind <- c(rnd_ind, sample(setdiff(1:nrow(attr_matrix), rnd_ind), size = (length(gene_list) - length(rnd_ind))))
  }
  rnd_smpl <- as.character(attr_matrix$ensembl_gene_id[rnd_ind])
  return(rnd_smpl)
}

# Divide genes according to an attribute #
attribute_2_list20bins <- function(attr_matrix, gene_col = 1, attr_col = 2, do_log = TRUE){
  if(do_log == TRUE){
    at <- rescale01(log(attr_matrix[, attr_col] + 1))  
  } else{
    at <- rescale01(attr_matrix[, attr_col])
  }
  bines <- seq(0, 1, .05)
  gps <- list()
  for(k in c(1:(length(bines) - 1))){
     if(k == 1){
      gps[[k]] <- as.character(union(attr_matrix[which(at <= bines[k]), gene_col],
                                     attr_matrix[which(at < bines[k + 1]), gene_col]))
     } else {
       if(k == 20){
         gps[[k]] <- as.character(intersect(attr_matrix[which(at >= bines[k]), gene_col], 
                                            attr_matrix[which(at <= bines[k +  1]), gene_col]))  
         } else {
           gps[[k]] <- as.character(intersect(attr_matrix[which(at >= bines[k]), gene_col],
                                              attr_matrix[which(at < bines[k + 1]), gene_col]))
           }
     }
  }
  return(gps)
}

```

# Read in data

```{r}
#| eval: true
# read data
#res <- readr::read_rds(df, here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control-vs-fraction_edger_subtype-annotated.rds"))
# Get DESeq2 results
res <- readr::read_rds(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated.rds")) %>%
  na.omit()
```

```{r}
#| eval: true
# read data
sce <- readr::read_rds(here::here("03_data/990_processed_data/001_snrnaseq/07_scflow_analysis/scflow-sce-annotated-highlevel.rds"))
updated_annotations <- readr::read_rds(here::here("03_data/990_processed_data/001_snrnaseq/10_cell_subtypes/subcluster_annotations.rds"))
```

# Data prep

We need ensembl IDs for the PPI, so let's get them

```{r}
# Gene ensembl IDs
gene_ensembl_ids <- data.frame(gene = rownames(sce@assays$RNA@data), ensembl = rownames(sce@assays$RNA@counts))
# Remove sce object - it's large
rm(sce)
# Join dataframes
res <- left_join(res, gene_ensembl_ids, by = "gene")
```

Filter to significant genes

```{r}
# Filter to sig genes
res_sig <- res |>
  dplyr::filter(padj < 0.05)

#write_csv(res_sig, here::here("initial_pseudobulk_sig_genes.csv"))

# Assert that there are no NAs in ensembl IDs
assertthat::are_equal(nrow(dplyr::filter(res_sig, is.na(ensembl))), 0)
```

# PPI Test 1. Links within gene set

## Background gene list

```{r}
#| eval: false

# Note that it can take a while to download the gene lists, so I've set eval 
# to false for this chunk.

# ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
# 
# # Background population (protein coding genes)
# bg <- getBM(attributes = c("ensembl_gene_id", "gene_biotype"), mart = ensembl)
# bg <- bg[which(bg$gene_biotype == "protein_coding"), ]
# write.table(bg$ensembl_gene_id, here::here("03_data/993_protein_protein_interaction_data/full_background"), 
#             sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# CDS length # 
cds <- getBM(attributes = c("ensembl_gene_id", "cds_length"),
            mart = ensembl)
colnames(cds) <- c("ensembl_gene_id", "cds_length")
cds <- cds[-which(is.na(cds$cds_length)== TRUE), ]
cds <- cds[order(cds$ensembl_gene_id), ]
cds_max <- aggregate.data.frame(cds, by = list(cds$ensembl_gene_id), FUN = max)
cds_max <- cds_max[, c("ensembl_gene_id", "cds_length")]
cds_max <- cds_max[cds_max$ensembl_gene_id %in% bg$ensembl_gene_id, ]
write.table(cds_max, here::here("03_data/993_protein_protein_interaction_data/EnsemblGeneID_MaxCDSlength.txt"), 
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
```

## Design

So I'm thinking it makes sense to do this with gene lists from the pseudobulk differential expression per celltype.

```{r}
gene_list <- res_sig |>
  dplyr::group_by(celltype) |>
  tidyr::nest()

# # # SELECT YOUR NETWORK FILE # # # 
# Merged protein protein interactions.
# my_network <- read_graph(file = here::here("03_data/993_protein_protein_interaction_data/2023May_MergedPPI_.txt"), 
#                          format = "ncol")
# For some reason updating igraph has resulted in read.graph being deprecated 
# in favour for read_graph, but this is throwing an error
# Read the file into a dataframe
# ppi_data <- read.table(here::here("03_data/993_protein_protein_interaction_data/MergedPPI_2024Feb_PIO_STRING.txt"), 
#                        header = FALSE, as.is = TRUE)
ppi_data <- read.table(here::here("03_data/993_protein_protein_interaction_data/MergedPPI_2024Feb.txt"), 
                       header = FALSE, as.is = TRUE)

# Create an igraph object from the dataframe
my_network <- graph_from_data_frame(ppi_data, directed = FALSE)
rm(ppi_data)
# Check the graph
summary(my_network)

# To include merged PPI datasets with only physical interactions from STRING
# use 2023May_MergedPPI_PIO_STRING.txt instead

edge_attr(my_network, "weight", index = E(my_network)) <- 1
```

## Background list

Could want to run against multiple backgrounds in future, but I'll just use the full list of gene from the pseudobulk across all celltypes.

```{r}
# For the background I can use the full gene list including non-significant genes
background_population <- unique(res$ensembl)
background_population <- list("full_background" = background_population)
```

```{r}
#| eval: false
# Path to background populations
bg_pop <-
  list.files(
    path = here::here("03_data/993_protein_protein_interaction_data/"),
    full.names = TRUE,
    pattern = "Background"
  ) 

# # #  INPUT YOUR BACKGROUND population # # # 
# All protein coding genes for example
background_population <- map(bg_pop, ~ read.table(file = .x, 
                                    sep = "\t", header = FALSE, 
                                    stringsAsFactors = FALSE)) |>
  purrr::set_names(basename(bg_pop))

# if(length(background_population) == 1){
#   background_population <- background_population[[1]]
# }
```


```{r}
# # #  INPUT gene attributes  # # # 
# Gene length / max CDS length
gene_length <- read.table(here::here("03_data/993_protein_protein_interaction_data/EnsemblGeneID_MaxCDSlength.txt"), 
                         sep = "\t", header = FALSE, 
                         stringsAsFactors = FALSE)
colnames(gene_length) <- c("ensembl_gene_id", "gene_length")


# # # SETUP NUMBER OF RANDOM SAMPLES to create your NULL # # #
m <- 10000

# # # Set to "D" to take into account degree, 
# # # "GL" to taken into account Gene length, 
# # # or "B" to take into account both degree and Gene length
gene_attribute <- "B"

# # # CHANGE the name of your OUTPUT FILE that will contain your test against NULL # # #
output_file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "PPI_Test1"
  )

# Min number of genes for a cluster
min_cluster_size <- 5

# Output Louvain clusters
output_file2 <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "PPI_Test1-Louvain_")
```

```{r}
# Add test type to the output file name
if(gene_attribute == "D") {
  output_file <- paste(output_file, "MatchDegree", sep = "_")} else {
  if(gene_attribute == "GL") {
  output_file <- paste(output_file, "MatchGenelength", sep = "_")} else {
    if(gene_attribute == "B"){
  output_file <- paste(output_file, "MatchDegreeAndGenelength", sep = "_")   
    }
  }
}
    
# Pull out the ensembl list for each celltype
my_gene_list <- map(gene_list$data, ~ dplyr::pull(.x, ensembl)) |>
  set_names(gene_list$celltype)
```

## Gene lists for analysis

```{r}
process_network <- function(background) {
  # Reduce my network to background population of genes tested #
  Gbg <- vertex_attr(my_network)$name
  BG <- intersect(background, intersect(Gbg, gene_length$ensembl_gene_id))
  my_network <- induced_subgraph(graph = my_network, vids = BG)
  
  # Create tables with the GENE attributes provided for the background population found in my network #
  # Calculate and order genes according to their degree in my network #
  D <- igraph::degree(my_network, mode = "all")
  D <- data.frame(ensembl_gene_id = names(D), degree = D)
  D <- D[order(D$degree, decreasing = TRUE),]
  rownames(D) <- 1:nrow(D)
  
  # Order genes by Gene length #
  gene_length <- gene_length[gene_length$ensembl_gene_id %in% BG, ]
  gene_length <- gene_length[order(gene_length$gene_length, decreasing = TRUE), ]
  rownames(gene_length) <- 1:nrow(gene_length)
  
  # Combined score Degree and Gene length
  B <- merge(D, gene_length, by = "ensembl_gene_id")
  B <- data.frame(B, 
                  scaled_degree = rescale01(B$degree), 
                  scaled_gene_length = rescale01(B$gene_length), 
                  score = rescale01(B$degree) + rescale01(B$gene_length))
  B <- B[order(B$score,  decreasing = TRUE), ]
  rownames(B) <- 1:nrow(gene_length)
  
  # Report numbers
  print(paste0("Background population: ", length(background), " genes"))
  print(paste0("Genes in the network: ", length(Gbg), " genes"))
  print(
    paste0(
      "Background population contained in the network and used for analysis: ",
      length(BG),
      " genes"
    )
  )
  
  x <- map(my_gene_list, ~ length(intersect(.x, BG)))
  x <- map2(x, names(my_gene_list), ~ print(paste0("Genes of interest contained in the network and used for analysis: ", .x, " for celltype ", .y)))
  
  return(list("BG" = BG, "network" = my_network, "D" = D, "B" = B))
}

res <- map(background_population, process_network)
```

```{r}
x <- map2(gene_list$celltype, my_gene_list, ~ print(paste0("Genes of interest: ", length(.y), " for celltype ", .x)))
x <- map2(gene_list$celltype, my_gene_list, ~ print(paste0("Genes of interest: ", length(.y), " for celltype ", .x)))
rm(x)
```

## Subnetwork plot

+ Interaction network of the genes of interest.

```{r}
rm(background_population)

# Function to intersect each cell type gene list with a single background list
intersect_with_background <- function(background_genes, cell_type_gene_list) {
  map(cell_type_gene_list, ~ intersect(.x, y = background_genes))
}
my_gene_list <- map(res, ~ intersect_with_background(.x$BG, my_gene_list))
```

```{r}
# Define subnetwork
create_subnetwork <- function(network, gene_lists) {
  map(gene_lists, ~ induced_subgraph(graph = network, vids = .x))
}
my_subgraph <- map2(res, my_gene_list, ~ create_subnetwork(.x$network, .y))

# Plot subnetwork
map(my_subgraph, ~ map2(
  .x, names(.x),
  ~ plot(
    .x,
    vertex.size = 3,
    vertex.color = "darkslateblue",
    vertex.frame.color = "darkslateblue",
    edge.color = "grey",
    rescale = TRUE,
    vertex.label = NA,
    main = paste0("Celltype: ", .y)
  )
))

```

## Test for number of interactions

```{r}
perform_permutation <- function(gene_list, gene_list_name, my_network, BG, gene_attribute, m, num_cores = detectCores() - 1) {
  
  print(paste0("Processing ", gene_list_name))
  
  # Gene population of interest
  gene_list_A <- intersect(gene_list, BG)

  # Sum of the edges within gene list A
  mynet_gl <- induced_subgraph(my_network, vids = gene_list_A)
  w_mynet_gl <- edge.attributes(mynet_gl)$weight
  o <- sum(w_mynet_gl)
  
  # Sum of the edges from within a random gene list size A
  # Use mclapply to parallelize the replicate function
  e <- mclapply(1:m, function(i) {
    rnd_smpl <- similar_gene_list(gene_list = gene_list_A, attr_matrix = gene_attribute, rango = 100)
    rnd_mynet_gl <- induced_subgraph(my_network, vids = rnd_smpl)
    rnd_w_mynet_gl <- edge.attributes(rnd_mynet_gl)$weight
    sum(rnd_w_mynet_gl)
  }, mc.cores = num_cores)
  # Convert the list to a vector
  e <- unlist(e)

  p <- length(which(e >= o)) / m

  # Write to dataframe
  df <- data.frame("gene_list" = gene_list_name, "o" = o, "e" = mean(e), "sem" = sd(e), "p" = p)
  return(df)
  
  print(paste0("Finished processing ", gene_list_name))
}

results <-
  map2(
    my_gene_list$full_background,
    names(my_gene_list$full_background),
    ~ perform_permutation(
      .x,
      .y,
      my_network = res$full_background$network,
      BG = res$full_background$BG,
      gene_attribute = res$full_background[[gene_attribute]],
      m = m
    )
  ) |>
  list_rbind()
```

### Results

```{r}
readr::write_tsv(results, paste0(output_file, ".tsv"))
#results <- readr::read_tsv(paste0(output_file, ".tsv"))
# Add adjusted pvalues
results$pval <- ifelse(results$p == 0, 1e-8, results$p)
results$padj <- p.adjust(results$pval, method = "bonferroni")
# Table with results of test
DT::datatable(
  results,
  caption = "Test if the number of interactions is higher than expected by chance",
  rownames = FALSE
) %>% formatRound(columns = c("e", "sem"), digits = c(2))
```

+ **o** observed number of interactions.

+ **e** expected number of interactions based on `{r} m` randomizations.

+ **sem** standard error of the mean based on `{r} m` randomizations.

+ **p** estimated p value based on `{r} m` randomizations.

+ **Note** If a weighted network is provided then it is a test for the sum of the edge's weights.

## Louvain clustering 

```{r}
perform_louvain_clustering <- function(subgraph, min_cluster_size, label) {
  # Louvain clustering
  cl <- cluster_louvain(subgraph)
  
  # Determine clusters smaller than the minimum size
  cluster_sizes <- table(cl$membership)
  not_assigned <- names(cluster_sizes[cluster_sizes < min_cluster_size])
  num_clusters <- names(cluster_sizes[cluster_sizes >= min_cluster_size])
  
  # Colour assignment
  cl_cols <- rainbow(n = length(num_clusters))
  
  # Vectorized color assignment
  cl_colors <- rep("grey", cl$vcount)
  membership_to_color <- setNames(cl_cols, num_clusters)
  cl_colors[cl$membership %in% num_clusters] <- membership_to_color[as.character(cl$membership[cl$membership %in% num_clusters])]
  
  # Dataframe with clustering and colours
  module_assignment <- data.frame(gene = cl$names, 
                                  module = cl$membership, 
                                  module_color = cl_colors,
                                  label = label)
  
  return(module_assignment)
}

module_assignment <-
  map2(
    my_subgraph$full_background,
    names(my_subgraph$full_background),
    ~ perform_louvain_clustering(.x, min_cluster_size, .y)
  )
```

```{r}
# Plot clustering
map2(my_subgraph$full_background, module_assignment, ~ plot(.x, 
     vertex.size = 3, 
     vertex.color = as.character(.y$module_color), 
     vertex.frame.color = .y$module_color, 
     edge.color = "grey",  
     rescale = TRUE, 
     vertex.label = NA,
     main = paste0("Celltype: ", .y$label[1])))

output_file2 <- paste(output_file2, paste("MinSize"), min_cluster_size, sep = "")

# Save clustering as file
write.table(list_rbind(module_assignment), 
            file = output_file2, 
            col.names = FALSE, 
            row.names = FALSE, 
            quote = TRUE)
```

## Module assignment

Having assigned the genes to modules the next thing to do is choose which celltypes to take forward to assign functions via GO pathways to.

```{r}
# Get modules assignment
modules <- list_rbind(module_assignment)
# Get significant celltypes
sig_celltypes <- results |>
  dplyr::filter(p < 0.05)

# Get number of genes per celltypes
gene_num <- map_dbl(my_gene_list$full_background, length)
# Check the gene numbers per celltypes of interest
gene_num <- gene_num[names(gene_num) %in% sig_celltypes$gene_list]
gene_num
# Get the celltypes with fewer than 30 genes
celltypes_with_few_genes <- names(gene_num)[gene_num < 30]
```

For cases where the number of genes is small, there isn't a need to use the clusters, though there isn't a rule of thumb for a cutoff for this.
Given 2 of the celltypes in this case have less than 30 genes, I'll run those through GO as they are, but the others I'll do per Louvain cluster.

```{r}
modules_sig <- modules |>
  # Filiter to sig celltypes
  dplyr::filter(label %in% sig_celltypes$gene_list) |>
  # Update modules for celltypes with low number of genes to all be the same
  dplyr::mutate(module_updated = case_when(
    label %in% celltypes_with_few_genes ~ 1,
    .default = module
  ))
```

```{r}
gene_list <- modules_sig %>% 
  group_by(label, module) %>% 
  tidyr::nest()
```

### GO enrichment

```{r}
convert_to_entrez <- function(gene_list) {
  tryCatch({
    bitr(gene_list, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
  }, error = function(e) {
    message("An error occurred: ", e$message)
    return(NULL) # Return NULL if the conversion fails
  })
}
# Convert Ensembl IDs to Entrez IDs
gene_list_entrez <- map(gene_list$data, ~ {
  tryCatch({
    bitr(.x$gene, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
  }, error = function(e) {
    message("An error occurred: ", e$message)
    return(NULL) # Return NULL if the conversion fails
  })
})

# Filter out any NULL entries if there were conversion errors
gene_list_entrez <- map(gene_list_entrez, ~ .x |>
                          # remove any missing data
                          dplyr::filter(!is.na(ENTREZID)) |>
                          dplyr::pull(ENTREZID))

entrez_background <- convert_to_entrez(gene_ensembl_ids$ensembl)

# Save file - it takes a while to compute
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/module_go_terms.rds"
  )

if (!file.exists(file)) {
  plan(multisession, workers = 9)
  result_list <- future_map(
    gene_list_entrez,
    ~ enrichGO(
      gene          = .x,
      OrgDb         = org.Hs.eg.db,
      keyType       = "ENTREZID",
      ont           = "ALL",
      universe      = entrez_background,
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      pAdjustMethod = "BH",
      qvalueCutoff  = 0.05,
      readable      = TRUE
    )
  ) |>
    set_names(paste0(gene_list$label, "_module", gene_list$module))
  
  readr::write_rds(result_list, file)
} else {
  result_list <- readr::read_rds(file)
}


# Remove any NULL entries
result_list <- result_list[!sapply(result_list, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(result_list, is.null)) == 0)
# Filter the list to keep only elements where the 'result' slot has rows
result_list <- result_list[sapply(result_list, function(x) nrow(x@result) > 0)]
```

### Save for MAGMA

I want to run these modules through MAGMA later so I'll save the gene lists whilst I have them in entrez.

```{r}
# Save to MAGMA
names(gene_list_entrez) <- paste0(gene_list$label, "_module", gene_list$module)
names(gene_list_entrez)
# Create a character vector where each element is a single string
lines_to_write <- sapply(names(gene_list_entrez), function(name) {
  paste(name, paste(gene_list_entrez[[name]], collapse = " "))
}, USE.NAMES = FALSE)

# Write the character vector to a file
readr::write_lines(lines_to_write, 
                   here::here("03_data/994_magma_inputs/ppi_sig_modules.magma.txt"))
```

### Treeplots

```{r}
# Plotting the first module's GO enrichment result as an example
if (length(result_list[[1]]) > 0) {
  dotplot(result_list[[1]])
}
dotplot(result_list$`Astrocyte-activated_module1`, split = "ONTOLOGY")

# Get semantic similarity of terms
result_list <- map(result_list, pairwise_termsim)
treeplot(result_list$`Astrocyte-activated_module5`)

# Define a safe version of your treeplot function that returns NULL on error
safe_treeplot <- possibly(treeplot, otherwise = NULL)
# Use map with the safe version of the function
treeplots <- map(result_list, safe_treeplot)

# Remove any NULL entries
treeplots <- treeplots[!sapply(treeplots, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(treeplots, is.null)) == 0)
treeplots <- map2(treeplots, names(treeplots), ~ .x + ggtitle(.y))

# I want to make patchwork of plots per celltype
# Extract unique cell types from the plot names
celltypes <- unique(sub("_module.*", "", names(treeplots)))

# Split the list of plots into a nested list by cell type
plots_by_celltype <- map(celltypes, ~{
  plots_for_type <- treeplots[grepl(paste0("^", .x, "_module"), names(treeplots))]
  combined_plot <- wrap_plots(plots_for_type, ncol = 1) # Adjust 'ncol' as needed
  combined_plot
})

# Name the list of combined plots by cell type
names(plots_by_celltype) <- celltypes
# save the plots nice and tall
walk2(plots_by_celltype, names(plots_by_celltype), ~ ggsave(
  filename = here::here("05_figures/990_shared_figures/ppi_modules", paste0(.y, "_combined_plot.png")),
  plot = .x,
  width = 14,
  height = 34
))

plots_by_celltype
```

### Module labels

So there isn't really a mathematical solution to this other than eyeballing the plots and assigning module functions

```{r}
# Astro module 1 has memory stuff
module_assignments <-
  c(#astro-activ
    "synapse_regulation-memory",
    "Cul3_rna_binding_complex",
    "cell_growth",
    "bbb_transport",
    "cell_leading_edge",
    "negative_reg",
    "methylation",
    "cell_fate",
    "angiogensis",
    # astro-quie
    "synaptic_transport",
    "cytoskeleton-projection",
    "glycosylation",
    "positive_reg_leukocyte",
    "extracellular_matrix",
    "vascular_trasport-sodium",
    "clathrin_vesicle",
    "long_chain_fatty",
    "negative_hypertrophy",
    "meiosis",
    # ex-neuron l2-3
    "adhesion",
    "dna_transcrip_activator",
    "microtubule",
    "extrinsic_membrane",
    "postsynaptic_protein_local",
    "carbohydrate_catabolic",
    "rna_splicing",
    "snrna_processing",
    # ex-neuron-l4-5
    "extracellular_matrix_organisation",
    "synapse_transimission-learning",
    "mitotic_spindle",
    "glycosyltransferase",
    "pain-salt",
    "bbb_transport",
    "actin",
    "nucleoside_metabolic",
    "postsynaptic_protein_reg",
    # in-neuron
    "calcium_channel",
    "microtubule",
    "purine_ribonucleotide",
    "granule_transport_complex",
    "osmotic_stress-salt",
    # M-pericyte
    "cell_sprouting_response",
    "endo_retic",
    "cellcell_adhesion",
    "plasma_membrane",
    "notch",
    # microglia-activated
    "amino_acid_transport-vascular",
    "gtpase_pos",
    "misfolded_protein",
    "cholesterol",
    "peptide_catabolic",
    "gtpase_binding",
    "positive_immune",
    "pyrimidine_metabolic",
    "glycosylation",
    # t-pericyte
    "glutamate-synaptic",
    "basal_plasma",
    "cellcell_adhesion-synapse_assembly",
    "centriole_cohesion",
    "long_chain_fatty",
    "galactosyltransferase",
    "lumen",
    # trans-endo-to-mural
    "carboxylic_acid_transport",
    "synapce_reg-chemotaxis",
    "membrane_permeability",
    "cytoskeleton_actin",
    "dendritic_spine",
    "dna_replication",
    "plasma_membrane",
    "phospholibid_transporter",
    "pyrimidine_metabolic")
module_assignments <- tibble("module" = names(treeplots), "label" = module_assignments)
```

Several of the modules have just one gene in them and I don't trust any enrichment for GO terms there, so I'll replace the module label with the gene label

```{r}
gene_num <- map_dbl(result_list, ~ length(.x@gene))
one_gene <- names(gene_num)[gene_num == 1]
genes <- map_chr(one_gene, ~ result_list[[.x]]@gene)
names(genes) <- one_gene

ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
# Retrieve gene symbols
gene_info <- getBM(attributes = c('entrezgene_id', 'hgnc_symbol'),
                   filters = 'entrezgene_id',
                   values = genes,
                   mart = ensembl)

# Print the results
print(gene_info)
# Make sure there's no NAs in the conversion
assertthat::noNA(gene_info)

# Make sure genes are arranged in the same way
module_order <- names(genes)[match(gene_info$entrezgene_id, genes)]
gene_symbols <- gene_info$hgnc_symbol
names(gene_symbols) <- module_order
# There are some modules not in the module assignment as they didn't get trees 
# for being to small. I'll exclude these modules and add them to dataframe
extra_modules <- gene_symbols[!names(gene_symbols) %in% module_assignments$module]
extra_modules <- data.frame(module = names(extra_modules), label = extra_modules)
module_assignments <- rbind(module_assignments, extra_modules)
# Update labels in the dataframe
module_assignments$label[match(names(gene_symbols), module_assignments$module)] <- gene_symbols
# Save module assignment
write_csv(
  module_assignments,
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "ppi_sig_module_labels.csv"
  )
)
```

```{r}
#| eval: false
#| include: false
manual_dotplot <- function(enrich_df, plot_title, term_num = 10) {
  # Convert GeneRatio from character to numeric
  # Assuming the format is "x/y", we'll extract "x" and convert it to numeric
  enrich_df$GeneRatio1 <-
    as.numeric(sapply(strsplit(enrich_df$GeneRatio, "/"), `[`, 1))
  enrich_df$GeneRatio2 <-
    as.numeric(sapply(strsplit(enrich_df$GeneRatio, "/"), `[`, 2))
  enrich_df$GeneRatio <- enrich_df$GeneRatio1 / enrich_df$GeneRatio2
  
  # Filter for the top term_mum terms by adjusted p-value within each ontology
  top_terms <- enrich_df %>%
    dplyr::group_by(ONTOLOGY) %>%
    dplyr::slice_max(n = term_num, order_by = p.adjust) %>%
    dplyr::ungroup()
  
  # Step 2: Plot with ggplot2
  p <-
    ggplot(top_terms,
           aes(
             x = reorder(Description,-GeneRatio),
             y = GeneRatio,
             size = Count,
             color = p.adjust
           )) +
    geom_point() +
    scale_color_gradient(low = "blue", high = "red") +
    facet_wrap( ~ ONTOLOGY, scales = "free", ncol = 1) +
    coord_flip() +  # Flip the axes
    theme_bw() +
    theme(axis.text.y = element_text(angle = 0, hjust = 1),
          # Adjust text alignment
          strip.text.x = element_text(face = "bold")) +
    labs(
      x = "",
      y = "Gene Ratio",
      size = "Count",
      color = "p.adjust"
    ) +
    ggtitle(plot_title)
  # geom_text_repel(aes(label = ifelse(nchar(Description) > 30, paste(substr(Description, 1, 27), '...'), Description)),
  #                 size = 3, direction = "y", hjust = 0, vjust = 0)
  
  return(p)
}

dotplots <- map2(result_list, names(result_list), ~ manual_dotplot(.x@result, .y))
dotplots$`Astrocyte-activated_module3`
```

<!-- ### Use rrvgo to reduce GO redundancy -->

<!-- GO terms have lots of redundancy, but `rrvgo` is a package inspired by [REVIGO](http://revigo.irb.hr/) to reduce this redundancy. -->

```{r}
#| eval: false
#| include: false
# Nest go terms into three ontologies
go_df <- map(result_list, ~ .x@result |>
               dplyr::group_by(ONTOLOGY) |>
               nest())

# In cases where there are few genes one may get a small number of GO terms and 
# a bunch of NULL qvalues. Here I remove these instances
# Define the name of the column you want to check
check_column <- "qvalue"

# Create a logical vector indicating if all values in the target_col are NA
all_na <- map(go_df, ~ map_lgl(.x$data, ~ all(is.na(.x[["qvalue"]]))))

# Filter the tibble to remove rows where the dataframe has all NA values in the target_col
go_df_filtered <- map2(go_df, all_na, ~ .x[!.y, ]) |>
  # Exclude elements where nrow is 0
  purrr::keep(~ nrow(.x) > 0)

# Make sure all the GO terms are significant
# Define a function to filter dataframes by p.adjust
filter_dfs_by_p_adjust <- function(df_list) {
  map(df_list, ~ dplyr::filter(.x, p.adjust < 0.05))
}
# Apply the filtering function to each tibble's list-column of dataframes
go_df_filtered <- map(go_df_filtered, ~ .x |>
           mutate(data = filter_dfs_by_p_adjust(data)))


# Save matrix file - it takes a while to compute
file <- here::here("03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/rrvgo_sim-matrix.rds")

if(!file.exists(file)) {
  # Prepare
  semdata_list <-
    list(
      "BP" = GOSemSim::godata("org.Hs.eg.db", ont = "BP"),
      "MF" = GOSemSim::godata("org.Hs.eg.db", ont = "MF"),
      "CC" = GOSemSim::godata("org.Hs.eg.db", ont = "CC")
    )
  # Apply rrvgo per ontology
  simMatrix <-
    future_map(go_df_filtered,
               ~ map2(
                 .x$data,
                 .x$ONTOLOGY,
                 ~ calculateSimMatrix(
                   .x$ID,
                   orgdb = "org.Hs.eg.db",
                   # Use prepared GO data - not working
                   #semdata = semdata_list[[.y]],
                   ont = .y,
                   metho = "Rel"
                 )
               ))
  
  readr::write_rds(simMatrix, file)
} else {
  simMatrix <- readr::read_rds(file)
}

scores <- map(go_df_filtered, ~ 
                map(.x$data, ~ setNames(-log10(.x$qvalue), .x$ID)))

# Function to identify non-matrix elements in a sublist
get_non_matrix_indices <- function(sublist) {
  sapply(sublist, function(x) !is.matrix(x))
}

# Apply the function to each sublist in simMatrix and get indices of non-matrices
non_matrix_indices_list <- lapply(simMatrix, get_non_matrix_indices)

# Now remove non-matrix elements from each sublist in simMatrix and scores
simMatrix_clean <- mapply(function(sim_sublist, non_matrix_indices) {
  sim_sublist[!non_matrix_indices]
}, simMatrix, non_matrix_indices_list, SIMPLIFY = FALSE)

scores_clean <- mapply(function(scores_sublist, non_matrix_indices) {
  scores_sublist[!non_matrix_indices]
}, scores, non_matrix_indices_list, SIMPLIFY = FALSE)


# Reduce terms
reduced_terms <-
  map2(simMatrix_clean, scores_clean, ~ map2(
    .x,
    .y,
    ~ reduceSimMatrix(.x,
                      .y,
                      threshold = 0.7,
                      orgdb = "org.Hs.eg.db")
  ))

reduced_terms$`Astrocyte-activated_module1`[[1]]
```

```{r}
#| eval: false
#| include: false
scatterPlot(simMatrix_clean$`Astrocyte-activated_module1`[[1]], reduced_terms$`Astrocyte-activated_module1`[[1]])
```

<!-- The reduced terms dataframe clusters the GO terms together, assigning a parent term to each cluster. -->
<!-- There's also a need to remove cases where there's only 1 row in the GO compartment. -->

```{r}
#| eval: false
#| include: false
# Remove cases where there's less than 2 rows
few_rows <- map(go_df_filtered, ~ map_lgl(.x$data, ~ nrow(.x) < 2))
# Filter the tibble to remove rows where the dataframe has all NA values in the target_col
go_df_filtered <- map2(go_df_filtered, few_rows, ~ .x[!.y, ])
```

```{r}
#| eval: false
#| include: false
# Join the list of reduced terms to the GO dataframes
# Define a function to perform left_join on corresponding pairs of dataframes
join_dfs <- function(df1, df2) {
  dplyr::left_join(df1, df2, by = join_by(ID == go))
}

# Perform the left_join for each pair of corresponding dataframes
go_reduced <- map2(go_df_filtered, reduced_terms, ~ {
  # Extract the list-column of dataframes from the current tibble
  tibble_dfs <- .x$data
  
  # Extract the corresponding list of dataframes to join
  list_dfs_to_join <- .y
  
  # Perform the join for each pair of dataframes
  joined_dfs <- map2(tibble_dfs, list_dfs_to_join, join_dfs)
  
  # Replace the original list-column with the joined dataframes
  modify_at(.x, "data", ~ joined_dfs)
})

# Assert that the rownumber shouldn't have changed in adding the reduced terms
assertthat::assert_that(sum(map2_dbl(
  go_df_filtered, go_reduced, ~ sum(
    map_dbl(.x$data, nrow) != map_dbl(.y$`Astrocyte-activated_module1`$data, nrow)
  )
)) == 0)
```

```{r}
#| eval: false
#| include: false
# Unnest data
go_reduced <- map(go_reduced, ~ unnest(.x, cols = c(data)) |> dplyr::ungroup())
# Using sapply to get a logical vector indicating if the data frame has rows
has_rows <- sapply(go_reduced, function(df) nrow(df) > 0)
# Subset the original list using the logical vector
go_reduced <- go_reduced[has_rows]

# Filter to parent terms assigned by rrvgo
go_reduced <- map(go_reduced, ~ dplyr::filter(.x, ID == parent))
```


# PPI Test 2. Links between two gene sets

I suppose one would look at comparing the gene sets of different celltypes in my case

## Prep

```{r}
# # # CHANGE the name of your OUTPUT FILE that will contain your test against NULL # # #
output_file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "PPI_Test2"
  )

# Min number of genes for a cluster
min_cluster_size <- 5

# Output Louvain clusters
output_file2 <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "PPI_Test2-Louvain_")
```

```{r}
# Add test type to the output file name
if(gene_attribute == "D") {
  output_file <- paste(output_file, "MatchDegree", sep = "_")} else {
  if(gene_attribute == "GL") {
  output_file <- paste(output_file, "MatchGenelength", sep = "_")} else {
    if(gene_attribute == "B"){
  output_file <- paste(output_file, "MatchDegreeAndGenelength", sep = "_")   
    }
  }
}
```

```{r}
gene_list <- res_sig |>
  dplyr::group_by(celltype) |>
  tidyr::nest()

# Pull out the ensembl list for each celltype
my_gene_list <- map(gene_list$data, ~ dplyr::pull(.x, ensembl)) |>
  set_names(gene_list$celltype)

my_gene_list <- map(res, ~ intersect_with_background(.x$BG, my_gene_list))
```

## Test for number of interactions

I've rewritten Jimena's code to take list of gene lists and do every pairwise comparison

```{r}
# Use map to set the names of the strings to the names of the list elements
my_gene_list <-
  map(
    names(my_gene_list$full_background),
    ~ setNames(my_gene_list$full_background[[.]], rep(
      ., length(my_gene_list$full_background[[.]])
    ))
  ) |>
  set_names(gene_list$celltype)
```


```{r}
# Function to compare two gene lists
compare_gene_lists <-
  function(gene_list_A,
           my_second_gene_list,
           my_network,
           gene_attribute,
           m,
           num_cores = detectCores() - 1) {
    
    # Get comparison name
    list_a_name <- unique(names(gene_list_A))
    list_b_name <- unique(names(my_second_gene_list))
    gene_list_name <- paste0(list_a_name, "_vs_", list_b_name)
    print(paste0("Processing ", gene_list_name))
    
    # Sum of the edges between gene list A and gene list B
    mynet_gl <-
      induced_subgraph(my_network, vids = unique(c(gene_list_A, my_second_gene_list)))
    w_mynet_gl <- edge.attributes(mynet_gl)$weight
    el_mynet_gl <- as_edgelist(mynet_gl)
    
    # Either gene involved in the PPI belong to the second gene list
    indices_be <-
      which(((el_mynet_gl[, 1] %in% my_second_gene_list) + (el_mynet_gl[, 2] %in% my_second_gene_list)
      ) == 1)
    
    # PPIs where one gene belong to both gene list A and gene list B, and the other belong the second list
    indices_ov <-
      c(intersect(which((el_mynet_gl[, 1] %in% my_gene_list) + (el_mynet_gl[, 1] %in% my_second_gene_list) == 2
      ),
      which(el_mynet_gl[, 2] %in% my_second_gene_list)),
      intersect(which((el_mynet_gl[, 2] %in% my_gene_list) + (el_mynet_gl[, 2] %in% my_second_gene_list) == 2
      ),
      which(el_mynet_gl[, 1] %in% my_second_gene_list)))
    o <- sum(w_mynet_gl[c(indices_be, indices_ov)])
    
    # Sum of the edges from within a random gene list size A #
    e <- mclapply(1:m, function(i) {
      rnd_smpl <-
        similar_gene_list(
          gene_list = gene_list_A,
          attr_matrix = gene_attribute,
          rango = 100
        )
      rnd_mynet_gl <-
        induced_subgraph(my_network, vids = unique(c(rnd_smpl, my_second_gene_list)))
      rnd_w_mynet_gl <- edge.attributes(rnd_mynet_gl)$weight
      rnd_el_mynet_gl <- as_edgelist(rnd_mynet_gl)
      
      # Either gene involved in the PPI belong to the second gene list
      rnd_indices_be <-
        which(((rnd_el_mynet_gl[, 1] %in% my_second_gene_list) + (rnd_el_mynet_gl[, 2] %in% my_second_gene_list)
        ) == 1)
      
      # PPIs where one gene belong to both gene list A and gene list B, and the other belong the second list
      rnd_indices_ov <-
        c(intersect(
          which((rnd_el_mynet_gl[, 1] %in% my_gene_list) + (rnd_el_mynet_gl[, 1] %in% my_second_gene_list) == 2
          ),
          which(rnd_el_mynet_gl[, 2] %in% my_second_gene_list)
        ),
        intersect(
          which((rnd_el_mynet_gl[, 2] %in% my_gene_list) + (rnd_el_mynet_gl[, 2] %in% my_second_gene_list) == 2
          ),
          which(rnd_el_mynet_gl[, 1] %in% my_second_gene_list)
        ))
      
      e <- sum(rnd_w_mynet_gl[c(rnd_indices_be, rnd_indices_ov)])
    }, mc.cores = num_cores)
    # Convert the list to a vector
    e <- unlist(e)
    
    p <- length(which(e >= o)) / m

    # Save results to dataframe
    df <-
      data.frame(
        "gene_list" = gene_list_name,
        "o" = o,
        "e" = mean(e),
        "sem" = sd(e),
        "p" = p
      )
    
    results_list <- list("df" = df, "indices_be" = indices_be, 
                         "indices_ov" = indices_ov)
    
    print(paste0("Finished processing ", gene_list_name))
    return(results_list)
  }
```

There's potentially a lot of comparisons to run here so I want to be sure we are only running the unique pairwise comparisons.

```{r}
# Define a function to perform the comparison on a pair of gene lists by their indices
compare_by_index <- function(index) {
  gene_list_A <- my_gene_list[[index[1]]]
  gene_list_B <- my_gene_list[[index[2]]]
  compare_gene_lists(
    gene_list_A,
    gene_list_B,
    res$full_background$network,
    gene_attribute = res$full_background[[gene_attribute]],
    m
  )
}

# Generate all unique pairwise combinations of gene list indices
gene_list_indices <- seq_along(my_gene_list)
combinations <- combn(gene_list_indices, 2)

if(!file.exists(paste0(output_file, ".tsv"))) {
  # Apply the comparison function to each unique combination
  results <- apply(combinations, 2, compare_by_index)
  
  # Extract and combine all dataframes using rbind
  results_df <- bind_rows(map(results, `[[`, 1))
  # Extract and combine the first vectors using c()
  indices_be <- unlist(map(results, `[[`, 2))
  # Extract and combine the second vectors using c()
  indices_ov <- unlist(map(results, `[[`, 3))

  # Save results
  readr::write_tsv(results_df, paste0(output_file, ".tsv"))
  readr::write_rds(list(indices_be, indices_ov), paste0(output_file, "_indicies.rds"))
} else {
  results_df <- readr::read_tsv(paste0(output_file, ".tsv"))
  results <- readr::read_rds(paste0(output_file, "_indicies.rds"))
  indices_be <- results[[1]]
  indices_ov <- results[[2]]
}
```

```{r}
# Add adjusted pvalues
results_df$pval <- ifelse(results_df$p == 0, 1e-8, results_df$p)
results_df$padj <- p.adjust(results_df$pval, method = "bonferroni")
# Table with results of test
DT::datatable(
  results_df,
  caption = "Test for number of interactions between two gene lists",
  rownames = FALSE
) %>% formatRound(columns = c("e", "sem", "padj"), digits = c(3))
# Get the number of sig interactions
sig_interactions <- results_df |> dplyr::filter(p < 0.05) |> nrow()
```

- There are `{r} sig_interactions` significant interactions between 2 gene lists.

```{r}
#| eval: false
#| include: false
x <-
  lapply(my_gene_list, function(gene_list_A) {
    sapply(my_gene_list, function(gene_list_B) {
      if (!identical(gene_list_A, gene_list_B)) {
        print(paste0(unique(names(gene_list_A)), "_vs_", 
                     unique(names(gene_list_B))))
      }
    })
  })
```

# Network

+ Nodes represent genes and edges interactions between them (i.e. PPI).

+ Nodes are coloured by their membership to the first gene list (blue), to the second gene list (red) or both (green).

+ Edges coloured in dark grey show interaction between the two sets of genes, light grey show interactions within a set.

```{r}
#| eval: true
# Define a function to plot the subgraph for a pair of gene sets
plot_subgraph <- function(gene_pair, network, save_plot_to_file = TRUE) {
  my_gene_list <- gene_pair[[1]]
  my_second_gene_list <- gene_pair[[2]]

    list_a_name <- unique(names(my_gene_list))
    list_b_name <- unique(names(my_second_gene_list))
    gene_list_name <- paste0(list_a_name, "_vs_", list_b_name)
    print(paste0("Processing ", gene_list_name))
    
  my_subgraph <- induced_subgraph(graph = network, vids = c(my_gene_list, my_second_gene_list))
  
  vcol <- rep(NA, length(V(my_subgraph)))
  vcol[V(my_subgraph)$name %in% my_gene_list] <- brewer.pal(3, "Set1")[1]
  vcol[V(my_subgraph)$name %in% my_second_gene_list] <- brewer.pal(3, "Set1")[2]
  if(length(intersect(my_gene_list, my_second_gene_list)) > 0) {
    vcol[V(my_subgraph)$name %in% intersect(my_gene_list, my_second_gene_list)] <- brewer.pal(3, "Set1")[3]
  }

  ecol <- rep("lightgrey", length(E(my_subgraph)))
  # Assuming you have some logic to define indices_be and indices_ov
  ecol[indices_be] <- "grey20"  
  ecol[indices_ov] <- "grey20" 
  
  if (save_plot_to_file) {
    # Define the file name
    file_name <-
      here::here(
        "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/network_plots",
        paste0("subgraph_plot_", gene_list_name, ".png")
      )
    # Save the plot to a file
    png(file_name)
  }
  
  plot(my_subgraph, vertex.size = 3, vertex.color = vcol,
       vertex.frame.color = NA, edge.color = ecol, main = gene_list_name,
       rescale = TRUE, vertex.label = NA, layout = layout_nicely(my_subgraph))
  
  if (save_plot_to_file) {
    dev.off()
  }

  print(paste0("Finished: ", gene_list_name))
}

# Generate all unique pairs of gene sets
gene_set_pairs <- combn(my_gene_list, 2, simplify = FALSE)
# Use map to apply the function to each pair of gene sets
map(
  gene_set_pairs,
  ~ plot_subgraph(.x, res$full_background$network, save_plot_to_file = FALSE)
)
```

```{r}
# Split celltypes from gene list
df <- results_df %>%
  separate(col = gene_list, into = c("celltype1", "celltype2"), sep = "_vs_")
# Create an edge list from the dataframe
edge_list <- df[, c("celltype1", "celltype2")]

# Create an igraph graph from the edge list
graph <- graph_from_data_frame(edge_list, directed = FALSE)

# Adding the p-value as an edge attribute
E(graph)$p_value <- df$p

# Adding a boolean attribute for more (TRUE) or less (FALSE) interactions than expected
E(graph)$more_interaction <- df$o > df$e

# Define edge width based on the significance (e.g., inverse of p-value)
#E(graph)$width <- 1 / E(graph)$p_value
# Set a threshold for the p-value to avoid division by zero or extremely small values
p_value_threshold <- 1e-8
E(graph)$width <- sapply(E(graph)$p_value, function(p) {
  if (p < p_value_threshold) {
    return(1 / p_value_threshold)  # Set a maximum width for very significant p-values
  } else {
    return(1 / p)  # Inverse of p-value
  }
})

# Set a significance level threshold, for example, p < 0.05
significance_level <- 0.05

# Add edge attributes for color and line type
E(graph)$color <- ifelse(E(graph)$p_value < significance_level, "black", "white")
E(graph)$linetype <- ifelse(E(graph)$more_interaction, "solid", "dashed")

# Create a vector that marks each edge as significant (1) or not (0)
E(graph)$significant <- ifelse(E(graph)$p_value < significance_level, 1, 0)

# Initialize a vector to store the number of significant interactions for each node
V(graph)$sig_interactions <- numeric(length(V(graph)))

# Loop over each vertex to calculate the number of significant interactions
for(node in V(graph)) {
  # Sum the significant attribute for edges connected to the node
  V(graph)$sig_interactions[node] <- sum(E(graph)[incident(graph, node, mode = "all")]$significant)
}

# Normalize the node sizes to a range that looks good in your plot
max_node_size <- 10
min_node_size <- 3
V(graph)$size <- min_node_size + (V(graph)$sig_interactions / max(V(graph)$sig_interactions) * (max_node_size - min_node_size))

# Cap edge widths to a maximum value
max_edge_width <- 5  # Adjust this value as needed
E(graph)$width <- pmin(E(graph)$width, max_edge_width)

# Plot the graph with the updated attributes
plot(graph,
     edge.width = E(graph)$width,
     edge.color = E(graph)$color,
     edge.lty = E(graph)$linetype,
     vertex.size = V(graph)$size,
     vertex.label = V(graph)$name,
     vertex.label = NA,
     layout = layout_nicely(graph)
)
```

```{r}
# Split celltypes from gene list
df <- results_df %>%
  separate(col = gene_list, into = c("celltype1", "celltype2"), sep = "_vs_") |>
  dplyr::filter(p < 0.05) |>
  dplyr::mutate(pval = ifelse(p == 0, 1/1e-8, p))
# Create an edge list from the dataframe
edge_list <- df[, c("celltype1", "celltype2")]

# Create an igraph graph from the edge list
graph <- graph_from_data_frame(edge_list, directed = FALSE)

# Adding the p-value as an edge attribute
E(graph)$p_value <- df$p

# Adding a boolean attribute for more (TRUE) or less (FALSE) interactions than expected
E(graph)$more_interaction <- df$o > df$e

# Define edge width based on the significance (e.g., inverse of p-value)
#E(graph)$width <- 1 / E(graph)$p_value
# Set a threshold for the p-value to avoid division by zero or extremely small values
p_value_threshold <- 1e-8
E(graph)$width <- sapply(E(graph)$p_value, function(p) {
  if (p < p_value_threshold) {
    return(1 / p_value_threshold)  # Set a maximum width for very significant p-values
  } else {
    return(1 / p)  # Inverse of p-value
  }
})

# Set a significance level threshold, for example, p < 0.05
significance_level <- 0.05

# Add edge attributes for color and line type
E(graph)$color <- ifelse(E(graph)$p_value < significance_level, "black", "white")
E(graph)$linetype <- ifelse(E(graph)$more_interaction, "solid", "dashed")

# Create a vector that marks each edge as significant (1) or not (0)
E(graph)$significant <- ifelse(E(graph)$p_value < significance_level, 1, 0)

# Initialize a vector to store the number of significant interactions for each node
V(graph)$sig_interactions <- numeric(length(V(graph)))

# Loop over each vertex to calculate the number of significant interactions
for(node in V(graph)) {
  # Sum the significant attribute for edges connected to the node
  V(graph)$sig_interactions[node] <- sum(E(graph)[incident(graph, node, mode = "all")]$significant)
}

# Normalize the node sizes to a range that looks good in your plot
max_node_size <- 10
min_node_size <- 3
V(graph)$size <- min_node_size + (V(graph)$sig_interactions / max(V(graph)$sig_interactions) * (max_node_size - min_node_size))

# Cap edge widths to a maximum value
max_edge_width <- 5  # Adjust this value as needed
E(graph)$width <- pmin(E(graph)$width, max_edge_width)

# Plot the graph with the updated attributes
plot(graph,
     edge.width = E(graph)$width,
     edge.color = E(graph)$color,
     edge.lty = E(graph)$linetype,
     vertex.size = V(graph)$size,
     vertex.label = V(graph)$name,
     vertex.label = NA,
     layout = layout_with_fr(graph)
)
# Get the coordinates of the nodes
layout <- matrix(layout.norm(as.matrix(layout.circle(graph))), ncol=2)

# Add labels with a background color
text(layout[,1], layout[,2], labels=V(graph)$name, pos=4, cex=0.8, col="black", bg="white")
```


```{r}
library(ggraph)
ggraph(graph, layout = 'nicely') +
    geom_edge_link(aes(edge_width = width, edge_color = color, edge_linetype = linetype, alpha = 0.8)) +
    geom_node_point(aes(size = size)) +
    geom_node_text(aes(label = name), repel = TRUE, size = 4)  # Adjust size as needed
```

```{r}
# Split celltypes from gene list
df <- results_df %>%
  separate(col = gene_list, into = c("celltype1", "celltype2"), sep = "_vs_") |>
  dplyr::filter(p < 0.05) |>
  dplyr::mutate(pval = ifelse(p == 0, 1/1e-8, p))
```

```{r}
library(networkD3)
# Create a list of all unique cell types
unique_cell_types <- unique(c(df$celltype1, df$celltype2))

# Create a data frame for nodes
nodes <- data.frame(name = unique_cell_types)
nodes$group <- NA

# Function to match cell types to their numeric ID
match_ids <- function(celltype, nodes) {
  match(celltype, nodes$name) - 1  # -1 because JavaScript is 0-indexed
}

# Add numeric source and target IDs to the edge list
df$Source <- sapply(df$celltype1, match_ids, nodes = nodes)
df$Target <- sapply(df$celltype2, match_ids, nodes = nodes)
# Create a force-directed network graph
network <- forceNetwork(Links = df[, c("Source", "Target", "o", "e", "pval")],
                        Nodes = nodes,
                        Source = "Source",
                        Target = "Target",
                        Value = "pval",  # or any other column that you want to use to determine the width of the edges
                        NodeID = "name",
                        Group = "group",
                        opacity = 0.8,
                        zoom = TRUE)

# Render the network
network
```
