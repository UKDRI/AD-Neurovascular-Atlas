---
title: Pathway analysis - subtypes
execute:
  eval: true
#self-contained: true
---

```{r}
here::i_am("04_data_analysis/001_snrnaseq_analysis/16_pathway_analysis.qmd")
```

# Load packages

```{r}
source(here::here("04_data_analysis/990_code_libraries/02_library-calls-for-renv.R"))
```

# APOE status

For the sake on simplicity, I'm just gonna set a variable here as to whether to process the data with or without APOE as a covariate

```{r}
include_apoe = FALSE
```

# Read in data

```{r}
#| eval: true
# read data
#res <- readr::read_rds(df, here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control-vs-fraction_edger_subtype-annotated.rds"))
# Get DESeq2 results
# res <- readr::read_rds(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated.rds")) %>%
#   na.omit()
if(include_apoe) {
res <- readr::read_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated_apoe.csv")) %>%
  na.omit()
} else {
res <- readr::read_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated_no-apoe.csv")) %>%
  na.omit()
}
```

# Data prep

```{r}
# filter to sig genes
res_sig <- dplyr::filter(res, padj < 0.05) |>
  dplyr::filter(!celltype %in% c("ambiguous", "low-feature-cells"))

# get gene names per celltype
genes_sum <- res_sig %>%
  dplyr::group_by(celltype, deg_direction) %>%
  dplyr::summarise(list_of_columns = list(gene))
genes <- genes_sum$list_of_columns
names(genes) <- paste0(genes_sum$celltype, "_", genes_sum$deg_direction)
```

```{r}
#| eval: false
#| include: false
# Zam wants vascular celltype DEGs for report
vascular_celltypes_level2 <- c('T-Pericyte', 'M-Pericyte', 'Pericyte', 
                               'Pericyte-2', 'Vascular-SMC', 'Arteriolar-SMC', 
                               'Vascular-SMC-LINC00486', 'Trans-Endo-to-mural', 
                               'Perivascular-FB-KAZN2', 'Perivascular-FB', 
                               'Meningeal-FB', 'Artirial-FB', 'Pericyte-FB', 
                               'Capillary', 'Arterial', 'Venous', 
                               'T-cell-vascular', 'T-cell-mixed', 
                               'Microglia-vascular')
vascular_sig_degs <- res_sig |>
  dplyr::filter(celltype %in% vascular_celltypes_level2)
readr::write_csv(vascular_sig_degs, here::here("vascular_degs.csv"))
```

## Complement gene list

```{r}
complement_gene_list <- read_excel(here("03_data/991_external_data/complement_gene_list.xlsx")) |>
  janitor::clean_names() |>
  dplyr::mutate(gene_name_cap = toupper(gene_name))

sig_complement_genes <- res_sig |>
  dplyr::filter(gene %in% complement_gene_list$gene_name_cap)
# Save data
if(include_apoe) {
  readr::write_csv(
    sig_complement_genes,
    here(
      "03_data/991_external_data/sig_complement_genes_apoe.csv"
    )
  )
} else {
  readr::write_csv(
    sig_complement_genes,
    here(
      "03_data/991_external_data/sig_complement_genes_no-apoe.csv"
    )
  )
}
```

## Save for IPA

Caleb mentioned it can be useful to see what IPA pulls out in terms of pathways and such, but I need to save the data in a csv first

```{r}
# save data for IPA
# Define a function to save each subset as a CSV file
save_celltype_df <- function(cell_type, df, file_name_root) {
  # Subset the dataframe for the current cell type
  celltype_df <- df %>% dplyr::filter(celltype == cell_type) |>
    # Select relevant columns
    dplyr::select(gene, log2FoldChange, padj) |>
    # Help IPA figure the columns out
    rename(pvalue_adjust = padj)
  
  # Create a filename based on the cell type
  filename <- paste0(file_name_root, "_", cell_type, ".csv")
  
  # Save the subset dataframe to a CSV file
  readr::write_csv(celltype_df, filename)
}

# Use map to iterate over each unique cell type and save a file
if(include_apoe) {
  map(unique(res$celltype),
      ~ save_celltype_df(
        .x,
        res,
        here::here(
          "03_data/990_processed_data/001_snrnaseq/08_pseudobulk/01_ipa_data/pseudobulk_ad-vs-control_deseq2_subtype-annotated_apoe"
        )
      ))
} else {
  map(unique(res$celltype),
      ~ save_celltype_df(
        .x,
        res,
        here::here(
          "03_data/990_processed_data/001_snrnaseq/08_pseudobulk/01_ipa_data/pseudobulk_ad-vs-control_deseq2_subtype-annotated_no-apoe"
        )
      ))
}
```

So apparently IPA is too stupid to handle more than 20 observations.
I love it when extremely expensive closed-source software barely usable garbage!

```{r}
# Step 1: Prepare the data
# Get a list of all unique cell types
all_celltypes <- unique(res$celltype)
# remove unneeded ones
all_celltypes <- all_celltypes[!all_celltypes %in% c("low-feature-cells", "ambiguous")]

# Split the list of cell types into two groups of 20
celltypes_group1 <- all_celltypes[1:20]
celltypes_group2 <- all_celltypes[21:40]

res |> 
  dplyr::filter(celltype %in% celltypes_group1) |>
  dplyr::select(gene, log2FoldChange, pvalue, padj, celltype) |>
  pivot_wider(names_from = celltype, values_from = c(log2FoldChange, pvalue, padj)) |>
  readr::write_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/01_ipa_data/pseudobulk_ad-vs-control_deseq2_subtype-annotated_wide_group1.csv"))
res |> 
  dplyr::filter(celltype %in% celltypes_group2) |>
  dplyr::select(gene, log2FoldChange, pvalue, padj, celltype) |>
  pivot_wider(names_from = celltype, values_from = c(log2FoldChange, pvalue, padj)) |>
  readr::write_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/01_ipa_data/pseudobulk_ad-vs-control_deseq2_subtype-annotated_wide_group2.csv"))
```


```{r}
#| eval: false
# Copy the gene names straight to the clipboard
# Note this only works on MacOS, Windows/Linux would need adapted versions
write.table(unique(res_sig$gene) |> paste0(collapse = ","), pipe("pbcopy"), sep = "")
```



<!-- There are a quite a lot of unique pairwise comparisons when looking at 2 factors (fraction and disease status in this case), and the cross groups can probably be dropped for now to prioritise the most interesting comparisons. -->
<!-- In this case, I'd think the most interesting comparisons are within the same fraction across disease status, and across fractions within the same disease state. -->

# Bar plots

Let's make some simple bar plots to show the number sig DEGs per celltype

```{r}
# Create a list of plots, one for each celltype
plots <- lapply(unique(res_sig$celltype), function(celltype) {
  # subset to celltype
  df <- res_sig[res_sig$celltype == celltype, ]
  # order genes based on the foldchange
  df$gene <- factor(df$gene, levels = df$gene[order(df$log2FoldChange)])
  # make barplot
  ggplot(df, aes(x = gene, y = log2FoldChange)) +
    geom_bar(stat = "identity", aes(fill = log2FoldChange > 0)) +
    scale_fill_manual(values = c("red", "blue"),
                      labels = c("Down", "Up")) +
    labs(
      title = paste("Significant DEGs for ", celltype),
      x = "Gene",
      y = expression(Log[2] ~ "Fold Change"),
      fill = ""
    ) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
})
names(plots) <- unique(res_sig$celltype)
plots$`Microglia-activated`

map_dbl(plots, ~ .x$data |> nrow())
# Save plots
map2(plots, names(plots), ~ {
  
  # There's a need to adjust the width of the plot based on the number of genes
  n_genes <- nrow(.x$data)
  if(n_genes < 30) {
    plot_width <- 8
  } else if (n_genes < 100) {
    plot_width <- 15
  } else if (n_genes < 300) {
    plot_width <- 25
  } else {
    plot_width <- 45
  }
  svg(here::here(
    "05_figures/990_shared_figures/002_pseudobulk",
    paste0(.y, "_sig_deg_barplot.svg")), width = plot_width)
  print(.x)
  dev.off()
})
```

# Hypergeometric enrichment

Need to get all the genes in the object as a universe

```{r}
tar_load(gene_ids)
```

```{r}
plan("multisession", workers = parallel::detectCores() - 1)
go_results_bp <- future_map(genes, ~ enrichGO(gene = .x, OrgDb = "org.Hs.eg.db", 
                                    keyType = "SYMBOL", ont = "BP",
                                    universe = gene_ids$gene), 
                            .options = furrr_options(seed = 123))
go_results_cc <- future_map(genes, ~ enrichGO(gene = .x, OrgDb = "org.Hs.eg.db", 
                                    keyType = "SYMBOL", ont = "CC",
                                    universe = gene_ids$gene), 
                            .options = furrr_options(seed = 123))
go_results_mf <- future_map(genes, ~ enrichGO(gene = .x, OrgDb = "org.Hs.eg.db", 
                                    keyType = "SYMBOL", ont = "MF",
                                    universe = gene_ids$gene), 
                            .options = furrr_options(seed = 123))
go_results_all2 <- future_map(genes, ~ enrichGO(gene = .x, OrgDb = "org.Hs.eg.db", 
                                    keyType = "SYMBOL", ont = "ALL",
                                    universe = gene_ids$gene), 
                            .options = furrr_options(seed = 123))
update_names_with_ontology <- function(list, ontology){
  names(list) <- paste0(names(list), "_", ontology)
  return(list)
}
go_results_bp <- update_names_with_ontology(go_results_bp, "BP")
go_results_cc <- update_names_with_ontology(go_results_cc, "CC")
go_results_mf <- update_names_with_ontology(go_results_mf, "MF")
go_results_all <- c(go_results_bp, go_results_cc, go_results_mf)
```

```{r}
# exclude cases where no pathways were found
go_results_filtered <- go_results_all2 |>
  purrr::keep(~ !is.null(.)) |>
  purrr::keep(~ nrow(.) > 0)

# Apply pairwise_termism where possible
go_results_filtered <- map(go_results_filtered, ~{
  if(length(.x$ID) >= 2) {
    pairwise_termsim(.x)
  } else {
    .x
  }
})

if(include_apoe) {
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/09_pathway_analysis/go-hypergeometic_subtypes_apoe_deg_direction.qs"
  )
} else {
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/09_pathway_analysis/go-hypergeometic_subtypes_no-apoe_deg_direction.qs"
  )
}
qs::qsave(go_results_filtered, file)
#go_results_filtered <- qs::qread(file)

# dotplots
dotplots <-
  map2(
    go_results_filtered,
    names(go_results_filtered),
    ~ dotplot(.x, showCategory = 20, split = "ONTOLOGY") + facet_grid(. ~ ONTOLOGY) +
      ggtitle(paste0(.y, " - Sig genes only"))
  )
map2(dotplots, names(dotplots), ~ {
  if (include_apoe) {
    png(
      here::here(
        "05_figures/990_shared_figures/002_pseudobulk/go_sig_genes_only",
        paste0(.y, "_apoe.png")
      ), height = 18, width = 10, units = "in", res = 300
    )
  } else {
    png(
      here::here(
        "05_figures/990_shared_figures/002_pseudobulk/go_sig_genes_only",
        paste0(.y, "_no-apoe.png")
      ), height = 18, width = 10, units = "in", res = 300
    )
  }
  print(.x)
  dev.off()
})
```

# Gene set enrichment analysis (GSEA)

- Note that GSEA takes pval and foldchange into account when computing the enrichment, so we don't filter the gene list

```{r}
#| eval: false
#| include: false

# Note this is for more complex contrasts
# nest data by celltype
gsea_df <- res %>%
  # group by celltype
  dplyr::group_by(celltype, contrast) %>%
  tidyr::nest() %>%
  dplyr::mutate(celltype_contrast = paste0(celltype, "_", contrast))
```

```{r}
# nest data by celltype
gsea_df <- res |>
  # group by celltype
  dplyr::group_by(celltype) |>
  tidyr::nest() 
```


```{r}
#| message: false
#| warning: false
# Function: Adjacency matrix to list -------------------------
matrix_to_list <- function(pws){
  pws.l <- list()
  for (pw in colnames(pws)) {
    pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
  }
  return(pws.l)
}

## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE) {
  # for debug
  #file <- gmt_files[1]
  #genes_in_data <- df$gene_symbol
  
  # Read in gmt file
  gmt <- gmtPathways(gmt_file)
  hidden <- unique(unlist(gmt))
  
  # Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
  mat <- matrix(
    NA,
    dimnames = list(hidden, names(gmt)),
    nrow = length(hidden),
    ncol = length(gmt)
  )
  for (i in 1:dim(mat)[2]) {
    mat[, i] <- as.numeric(hidden %in% gmt[[i]])
  }
  
  #Subset to the genes that are present in our data to avoid bias
  hidden1 <- intersect(genes_in_data, hidden)
  mat <-
    mat[hidden1, colnames(mat)[which(colSums(mat[hidden1, ]) > 5)]] # filter for gene sets with more than 5 genes annotated
  # And get the list again
  final_list <-
    matrix_to_list(mat) # for this we use the function we previously defined
  
  if (savefile) {
    saveRDS(final_list, file = paste0(
      gsub('.gmt', '', gmt_file),
      '_subset_',
      format(Sys.time(), '%d%m'),
      '.RData'
    ))
  }
  
  print('Wohoo! .gmt conversion successfull!:)')
  return(final_list)
}

# Get all the genes in dataset and assign them to my_genes 
my_genes <- res$gene

# Download gene sets .gmt files
#https://www.gsea-msigdb.org/gsea/msigdb/human/collections.jsp
# I've downloaded several background sets to try
gmt_files <- list.files(here::here("03_data/991_external_data"), pattern = "\\.gmt$", full.names = TRUE)

gmt <- map(gmt_files, ~ prepare_gmt(.x, my_genes))
```

```{r}
#| eval: false
#| include: false

# This is the per celltype version - not using fgsea at the moment so I'll skip
# this for now
# Get all the genes in your dataset and assign them to my_genes 
my_genes <- map(gsea_df$data, ~ .x$gene) %>%
  purrr::set_names(gsea_df$celltype)

gmt <- map(gmt_files, function(gmt) {
  map(my_genes, function(genes) {
    prepare_gmt(gmt, genes)
  }
)})
```

Get the gene rankings

```{r}
# Genes need to be ranked for GSEA as named gene list
# Here I'll use use the signed p values from spatial DGE as ranking

# Function to sort rankings
sort_rankings <- function(log2fc, pvals, gene_names, group, plot = FALSE) {
  rankings <- sign(log2fc) * (-log10(pvals))
  # genes as names
  names(rankings) <- gene_names
  head(rankings)
  
  # sort genes by ranking
  rankings <- sort(rankings, decreasing = TRUE)
  if (plot) {
    plot(rankings, main = group)
  }
  
  # Some genes have such low p values that the signed pval is +- inf, we need to
  # change it to the maximum * constant to avoid problems with fgsea
  max_ranking <- max(rankings[is.finite(rankings)])
  min_ranking <- min(rankings[is.finite(rankings)])
  # change any inf values to 10 times the min/max non-inf value
  rankings <-
    replace(rankings, rankings > max_ranking, max_ranking * 10)
  rankings <-
    replace(rankings, rankings < min_ranking, min_ranking * 10)
  rankings <-
    sort(rankings, decreasing = TRUE) # sort genes by ranking
  
  return(rankings)
}

```

```{r}
#| eval: false
#| include: false

# Again for more complex contrasts
rankings <-
  map2(gsea_df$data, gsea_df$celltype_contrast, ~ (sort_rankings(.x$log2FoldChange,
                                                        .x$pvalue,
                                                        .x$gene,
                                                        .y))) %>%
  purrr::set_names(gsea_df$celltype_contrast)
```

```{r}
rankings <-
  map2(gsea_df$data, gsea_df$celltype, ~ (sort_rankings(.x$log2FoldChange,
                                                        .x$pvalue,
                                                        .x$gene,
                                                        .y))) %>%
  purrr::set_names(gsea_df$celltype)
```



```{r}
ggplot(data.frame(
  gene_symbol = names(rankings$Arterial)[1:50],
  ranks = rankings$Arterial[1:50]
),
aes(gene_symbol, ranks)) +
  geom_point() +
  theme_classic() +
  theme(axis.text.x = element_text(
    angle = 90,
    vjust = 0.5,
    hjust = 1
  )) +
  ggtitle("Arterial top 50 ranked genes",
          subtitle = "Control VS AD")
```

## Run GSEA

```{r}
#| message: false
#| results: hide
## Run GSEA ---------------------------------------------------------------
gsea_res <- map(gmt, function(pathway) {
  map(rankings, function(rank) {
    fgsea(
      pathways = pathway,
      # List of gene sets to check
      stats = rank,
      # in this case we have both pos and neg rankings. if only pos or neg, set
      # to 'pos', 'neg'
      scoreType = 'std',
      minSize = 10,
      maxSize = 500,
      # for parallelisation
      nproc = parallel::detectCores() - 1
    )
  })
}) %>%
  purrr::set_names(basename(gmt_files))
```


```{r}
# get log2 FC as a vector with the respective gene names, sorted in decreasing 
# order
named_vectors <- res_sig %>%
  dplyr::group_by(celltype) %>%
  tidyr::nest() %>%
  dplyr::mutate(gene_list = map(data, ~setNames(.x$log2FoldChange, .x$gene) %>%
                                  sort(decreasing = TRUE)))
```

## Gene Ontology

```{r}
# Define the file path to save the resulting object
if(include_apoe) {
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/09_pathway_analysis/gene-set-enrichment_go_subtypes_apoe.qs"
  )
} else {
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/09_pathway_analysis/gene-set-enrichment_go_subtypes_no-apoe.qs"
  )
}

# Check if the file exists
#if (!file.exists(result_file)) {
#  # Code for your time-consuming analysis
#  gse <-
#    map(
#      rankings,
#      ~ gseGO(
#        .x,
#        OrgDb = "org.Hs.eg.db",
#        ont = "ALL",
#        keyType = "SYMBOL"
#      )
#    ) 
#  
#  # Save the resulting object
#  readr::write_rds(gse, result_file)
#} else {
#  # Load the existing resulting object
#  gse <- readr::read_rds(result_file)
#}
if (!file.exists(file)) {
  plan("multisession", workers = parallel::detectCores() - 1)
  result_list_bp <- future_map(
    rankings,
    ~ gseGO(
      gene          = .x,
      OrgDb         = org.Hs.eg.db,
      keyType       = "SYMBOL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont           = "BP",
      pAdjustMethod = "BH"
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(names(rankings), "_BP"))
  result_list_cc <- future_map(
    rankings,
    ~ gseGO(
      gene          = .x,
      OrgDb         = org.Hs.eg.db,
      keyType       = "SYMBOL",
      ont           = "CC",
      pAdjustMethod = "BH"
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(names(rankings), "_CC"))
  result_list_mf <- future_map(
    rankings,
    ~ gseGO(
      gene          = .x,
      OrgDb         = org.Hs.eg.db,
      keyType       = "SYMBOL",
      ont           = "MF",
      pAdjustMethod = "BH"
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(names(rankings), "_MF"))
  result_list <- c(result_list_bp, result_list_mf, result_list_cc)
  rm(result_list_bp, result_list_cc, result_list_mf)
  
  qs::qsave(result_list, file)
} else {
  result_list <- qs::qread(file)
}


# Remove any NULL entries
result_list <- result_list[!sapply(result_list, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(result_list, is.null)) == 0)
# Filter the list to keep only elements where the 'result' slot has rows
#result_list <- result_list[sapply(result_list, function(x) nrow(x@result) > 0)]
# Filter to only those wtih sig enrichments
#result_list <- result_list[sapply(result_list, function(x) sum(x@result$p.adjust < 0.05) > 0)]
```

```{r}
# remove any with no pathways found
gse <- result_list %>%
  purrr::keep(~ nrow(.) > 0)
```

### Insulin pathways

Zam is interested in pathways related to insulin, so I'll filter to celltypes where such terms are present

```{r}
# Function to check for the presence of 'insulin' in the pathway description
find_insulin <- function(df) {
  df <- as_tibble(df)
  grepl("insulin", df$Description, ignore.case = TRUE)
}

# Apply the function to each dataframe in the list
insulin_related <- lapply(gse, find_insulin)

# Now, determine which celltypes have any insulin-related pathways
celltypes_with_insulin <- names(insulin_related)[sapply(insulin_related, any)]

# Print the celltypes with insulin-related pathways
print(celltypes_with_insulin)

# Remove ambiguous
celltypes_with_insulin <-
  celltypes_with_insulin[!celltypes_with_insulin == "ambiguous"]

print("Celltype with 'insulin' in pathway description:")
paste0(celltypes_with_insulin, collapse = ", ")
```

Get the genes of these celltypes too

```{r}
#| eval: false

# Save the dotplots of this subset
insulin_pathways <- gse[names(gse) %in% celltypes_with_insulin]
dotplots <-
  map2(
    insulin_pathways,
    names(insulin_pathways),
    ~ dotplot(.x, showCategory = 10, split = ".sign") + facet_grid(. ~ .sign) +
      ggtitle(.y)
  )

# Specify the filename for the PDF
if(include_apoe) {
pdf_file <- here::here("insulin_celltype_dotplots_apoe.pdf")
} else {
pdf_file <- here::here("insulin_celltype_dotplots_no-apoe.pdf")
}
# Open the PDF device
pdf(pdf_file)
dotplots
# Close the PDF device
dev.off()

insulin_genes <- res_sig |>
  dplyr::filter(celltype %in% celltypes_with_insulin)
insulin_genes |> dplyr::filter(celltype == "Capillary") |> dim()
if(include_apoe) {
readr::write_csv(insulin_genes, here::here("insulin_celltypes_sig_genes_apoe.csv"))
} else {
readr::write_csv(insulin_genes, here::here("insulin_celltypes_sig_genes_no-apoe.csv"))
}
```

### Plots

```{r}
dotplots <-
  map2(
    gse,
    names(gse),
    ~ dotplot(.x, showCategory = 10, split = ".sign") + facet_grid(. ~ .sign) +
      ggtitle(paste0(.y, " - GSEA"))
  )

dotplots
if(include_apoe) {
readr::write_rds(dotplots, here::here("03_data/990_processed_data/001_snrnaseq/09_pathway_analysis/go-dotplots_subtypes_apoe.rds"))
} else{
readr::write_rds(dotplots, here::here("03_data/990_processed_data/001_snrnaseq/09_pathway_analysis/go-dotplots_subtypes_no-apoe.rds"))
}
```

```{r}
# Use the sub function to extract the substring before the first underscore
celltypes <- sub("_.*", "", names(dotplots)) |> unique()

merge_plots <- function(celltype, dotplot_list) {
  # subset to relevant plots
  plots <- dotplot_list[grepl(paste0("^", celltype, "_"), names(dotplot_list))]
  # Merge plots
  #plot <- plots[[1]] + plots[[2]] + plots[[3]]
    # Check if there are any plots available
  if (length(plots) > 0) {
    # Use Reduce to combine the plots
    final_plot <- Reduce(`+`, plots)
  } else {
    warning("No plots available for the specified celltype.")
    final_plot <- NULL
  }
  
  return(final_plot)
}

plots <- map(celltypes, merge_plots, dotplots) |> set_names(celltypes)

plots

# Save plots
map2(plots, names(plots), ~ ggsave(here::here("05_figures/990_shared_figures/002_pseudobulk/gsea", paste0(.y, ".png")), plot = .x, width = 18, height = 10))
```


```{r}
#| eval: false
#| include: false
map2(gse,
     names(gse),
     ~ emapplot(.x, showCategory = 10) +
                  ggtitle(.y))
```

```{r}
map2(gse,
     names(gse),
     ~ ridgeplot(.x) +
       labs(x = "enrichment distribution") +
                  ggtitle(.y))
```

Note, one can change which pathway is plotted here by setting the title and `geneSetID` accordingly

```{r}
map2(gse,
     names(gse),
     ~ gseaplot(.x, by = "all", title = .x$Description[1], geneSetID = 1))
```

