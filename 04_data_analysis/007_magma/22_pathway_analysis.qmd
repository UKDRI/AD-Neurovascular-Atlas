---
title: Pathway analysis - MAGMA genes
execute:
  eval: true
#self-contained: true
code-fold: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

```{r}
here::i_am("04_data_analysis/007_magma/22_pathway_analysis.qmd")
```

# Load packages

```{r}
source(here::here("04_data_analysis/990_code_libraries/02_library-calls-for-renv.R"))
```

# Read in data

Here we're looking at the significant celltypes from MAGMA again AD in all controls.
The genes are the genes MAGMA found to be significant after correction for each celltype.
Note that each celltype was adjusted separately and via Bonferroni.

```{r}
#| eval: true
# read data of sig magma genes from sig celltypes for AD all controls
#res <- readr::read_tsv(here::here("03_data/994_magma_inputs/results/sig_celltype_sig_genes.tsv"))
res <- readr::read_tsv(here::here("03_data/994_magma_inputs/sig_genelist", "all_sig_magma_set_genes.tsv")) |>
  dplyr::rename(celltype = SetName)
```

# Data prep

```{r}
# filter to sig genes
res_sig <- dplyr::filter(res, padj < 0.05)

# get gene names per celltype
genes <- res_sig %>%
  dplyr::group_by(celltype) %>%
  dplyr::summarise(list_of_columns = list(hgnc_symbol)) %>%
  dplyr::pull(list_of_columns)
names(genes) <- unique(res_sig$celltype)
```

# Hypergeometric enrichment

```{r}
go_results_bp <- map(genes, ~ enrichGO(gene = .x, OrgDb = "org.Hs.eg.db", 
                                    keyType = "SYMBOL", ont = "BP"))
names(go_results_bp) <- paste0(names(go_results_bp), "_bp")
go_results_cc <- map(genes, ~ enrichGO(gene = .x, OrgDb = "org.Hs.eg.db", 
                                    keyType = "SYMBOL", ont = "CC"))
names(go_results_cc) <- paste0(names(go_results_cc), "_cc")
go_results_mf <- map(genes, ~ enrichGO(gene = .x, OrgDb = "org.Hs.eg.db", 
                                    keyType = "SYMBOL", ont = "MF"))
names(go_results_mf) <- paste0(names(go_results_mf), "_mf")
go_results <- c(go_results_bp, go_results_cc, go_results_mf)
rm(go_results_bp, go_results_cc, go_results_mf)
```

```{r}
# exclude cases where no pathways were found
go_results_filtered <- go_results |>
  purrr::keep(~ !is.null(.)) |>
  purrr::keep(~ nrow(.) > 0)

# treeplots
go_results_filtered <- map(go_results_filtered, pairwise_termsim)

treeplots <-
  map2(
    go_results_filtered,
    names(go_results_filtered),
    ~ treeplot(.x) +
      ggtitle(.y)
  )

# Use the sub function to extract the substring before the first underscore
celltypes <- sub("_.*", "", names(treeplots)) |> unique()

merge_plots <- function(celltype, dotplot_list) {
  # subset to relevant plots
  plots <- dotplot_list[grepl(celltype, names(dotplot_list))]
  # Merge plots
  plot <- plots[[1]] + plots[[2]] + plots[[3]]
}

plots <- map(celltypes, merge_plots, treeplots) |> set_names(celltypes)

plots

# Save plots
map2(plots, names(plots), ~ ggsave(here::here("05_figures/990_shared_figures/001_magma/magma_pathways", paste0(.y, "_sig_genes_only", ".png")), plot = .x, width = 32, height = 10))

dotplots <-
  map2(
    go_results_filtered,
    names(go_results_filtered),
    ~ dotplot(.x, showCategory = 20) +
      ggtitle(.y)
  )

plots <- map(celltypes, merge_plots, dotplots) |> set_names(celltypes)

map2(plots, names(plots), ~ ggsave(here::here("05_figures/990_shared_figures/001_magma/magma_pathways", paste0(.y, "_sig_genes_only-dotplots", ".png")), plot = .x, width = 26, height = 12))
```

```{r}

celltypes <- sub("_.*", "", names(go_results_filtered)) |> unique()

merged_go_plot <- function(celltype, go_results_list) {
  
  # Subset to celltype
  gos <- go_results_list[grepl(celltype, names(go_results_list))]
  
  # Extract results and add ontology information
  combined_df <- do.call(rbind, lapply(names(gos), function(name) {
    df <- as.data.frame(gos[[name]]@result)
    df$Ontology <- gsub(".*_(.*)", "\\1", name)  # Extract ontology from name
    return(df)
  }))
  return(combined_df)
}

go_combined <- map(celltypes, merged_go_plot, go_results_filtered) |>
  set_names(celltypes)
# Save
qs::qsave(go_combined, here::here("05_figures/990_shared_figures/003_final_figures/001_data_for_plots/go_data_sig_gene_only.qs"))
```

## Save for IPA

Caleb mentioned it can be useful to see what IPA pulls out in terms of pathways and such, but I need to save the data in a csv first

```{r}
#| eval: false
# save data for IPA
# Define a function to save each subset as a CSV file
save_celltype_df <- function(cell_type, df, file_name_root) {
  # Subset the dataframe for the current cell type
  celltype_df <- df %>% dplyr::filter(celltype == cell_type) |>
    # Select relevant columns
    dplyr::select(gene, log2FoldChange, padj) |>
    # Help IPA figure the columns out
    rename(pvalue_adjust = padj)
  
  # Create a filename based on the cell type
  filename <- paste0(file_name_root, "_", cell_type, ".csv")
  
  # Save the subset dataframe to a CSV file
  readr::write_csv(celltype_df, filename)
}

# Use map to iterate over each unique cell type and save a file
  map(unique(res$celltype),
      ~ save_celltype_df(
        .x,
        res,
        here::here(
          "03_data/990_processed_data/001_snrnaseq/08_pseudobulk/01_ipa_data/magma_sig_genes"
        )
      ))
```

So apparently IPA is too stupid to handle more than 20 observations.
I love it when extremely expensive closed-source software barely usable garbage!

```{r}
#| eval: false
# Step 1: Prepare the data
# Get a list of all unique cell types
all_celltypes <- unique(res$celltype)
# remove unneeded ones
all_celltypes <- all_celltypes[!all_celltypes %in% c("low-feature-cells", "ambiguous")]

# Split the list of cell types into two groups of 20
celltypes_group1 <- all_celltypes[1:20]
celltypes_group2 <- all_celltypes[21:40]

res |> 
  dplyr::filter(celltype %in% celltypes_group1) |>
  dplyr::select(gene, log2FoldChange, pvalue, padj, celltype) |>
  pivot_wider(names_from = celltype, values_from = c(log2FoldChange, pvalue, padj)) |>
  readr::write_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/01_ipa_data/pseudobulk_ad-vs-control_deseq2_subtype-annotated_wide_group1.csv"))
res |> 
  dplyr::filter(celltype %in% celltypes_group2) |>
  dplyr::select(gene, log2FoldChange, pvalue, padj, celltype) |>
  pivot_wider(names_from = celltype, values_from = c(log2FoldChange, pvalue, padj)) |>
  readr::write_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/01_ipa_data/pseudobulk_ad-vs-control_deseq2_subtype-annotated_wide_group2.csv"))
```


```{r}
#| eval: false
# Copy the gene names straight to the clipboard
# Note this only works on MacOS, Windows/Linux would need adapted versions
write.table(unique(res_sig$gene) |> paste0(collapse = ","), pipe("pbcopy"), sep = "")
```



<!-- There are a quite a lot of unique pairwise comparisons when looking at 2 factors (fraction and disease status in this case), and the cross groups can probably be dropped for now to prioritise the most interesting comparisons. -->
<!-- In this case, I'd think the most interesting comparisons are within the same fraction across disease status, and across fractions within the same disease state. -->

# Gene set enrichment analysis (GSEA)

- Note that GSEA takes pval and foldchange into account when computing the enrichment, so we don't filter the gene list

```{r}
# nest data by celltype
gsea_df <- res |>
  # group by celltype
  dplyr::group_by(celltype) |>
  tidyr::nest() 
```


```{r}
#| message: false
#| warning: false
# Function: Adjacency matrix to list -------------------------
matrix_to_list <- function(pws){
  pws.l <- list()
  for (pw in colnames(pws)) {
    pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
  }
  return(pws.l)
}

## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE) {
  # for debug
  #file <- gmt_files[1]
  #genes_in_data <- df$gene_symbol
  
  # Read in gmt file
  gmt <- gmtPathways(gmt_file)
  hidden <- unique(unlist(gmt))
  
  # Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
  mat <- matrix(
    NA,
    dimnames = list(hidden, names(gmt)),
    nrow = length(hidden),
    ncol = length(gmt)
  )
  for (i in 1:dim(mat)[2]) {
    mat[, i] <- as.numeric(hidden %in% gmt[[i]])
  }
  
  #Subset to the genes that are present in our data to avoid bias
  hidden1 <- intersect(genes_in_data, hidden)
  mat <-
    mat[hidden1, colnames(mat)[which(colSums(mat[hidden1, ]) > 5)]] # filter for gene sets with more than 5 genes annotated
  # And get the list again
  final_list <-
    matrix_to_list(mat) # for this we use the function we previously defined
  
  if (savefile) {
    saveRDS(final_list, file = paste0(
      gsub('.gmt', '', gmt_file),
      '_subset_',
      format(Sys.time(), '%d%m'),
      '.RData'
    ))
  }
  
  print('Wohoo! .gmt conversion successfull!:)')
  return(final_list)
}

# Get all the genes in dataset and assign them to my_genes 
my_genes <- res$hgnc_symbol

# Download gene sets .gmt files
#https://www.gsea-msigdb.org/gsea/msigdb/human/collections.jsp
# I've downloaded several background sets to try
gmt_files <- list.files(here::here("03_data/991_external_data"), pattern = "\\.gmt$", full.names = TRUE)

gmt <- map(gmt_files, ~ prepare_gmt(.x, my_genes))
```

```{r}
#| eval: false
#| include: false

# This is the per celltype version - not using fgsea at the moment so I'll skip
# this for now
# Get all the genes in your dataset and assign them to my_genes 
my_genes <- map(gsea_df$data, ~ .x$gene) %>%
  purrr::set_names(gsea_df$celltype)

gmt <- map(gmt_files, function(gmt) {
  map(my_genes, function(genes) {
    prepare_gmt(gmt, genes)
  }
)})
```

Get the gene rankings

```{r}
# Genes need to be ranked for GSEA as named gene list
# Here I'll use use the signed p values from spatial DGE as ranking

# Function to sort rankings
sort_rankings <- function(log2fc, pvals, gene_names, group, plot = FALSE) {
  rankings <- sign(log2fc) * (-log10(pvals))
  # genes as names
  names(rankings) <- gene_names
  head(rankings)
  
  # sort genes by ranking
  rankings <- sort(rankings, decreasing = TRUE)
  if (plot) {
    plot(rankings, main = group)
  }
  
  # Some genes have such low p values that the signed pval is +- inf, we need to
  # change it to the maximum * constant to avoid problems with fgsea
  max_ranking <- max(rankings[is.finite(rankings)])
  min_ranking <- min(rankings[is.finite(rankings)])
  # change any inf values to 10 times the min/max non-inf value
  rankings <-
    replace(rankings, rankings > max_ranking, max_ranking * 10)
  rankings <-
    replace(rankings, rankings < min_ranking, min_ranking * 10)
  rankings <-
    sort(rankings, decreasing = TRUE) # sort genes by ranking
  
  return(rankings)
}

```

```{r}
#| eval: false
#| include: false

# Again for more complex contrasts
rankings <-
  map2(gsea_df$data, gsea_df$celltype_contrast, ~ (sort_rankings(.x$log2FoldChange,
                                                        .x$pvalue,
                                                        .x$gene,
                                                        .y))) %>%
  purrr::set_names(gsea_df$celltype_contrast)
```

```{r}
rankings <-
  map2(gsea_df$data, gsea_df$celltype, ~ (sort_rankings(.x$ZSTAT,
                                                        .x$P,
                                                        .x$hgnc_symbol,
                                                        .y))) %>%
  purrr::set_names(gsea_df$celltype)
```



```{r}
ggplot(data.frame(
  gene_symbol = names(rankings$`Microglia-activated`)[1:50],
  ranks = rankings$`Microglia-activated`[1:50]
),
aes(gene_symbol, ranks)) +
  geom_point() +
  theme_classic() +
  theme(axis.text.x = element_text(
    angle = 90,
    vjust = 0.5,
    hjust = 1
  )) +
  ggtitle("Microglia-activated top 50 ranked genes",
          subtitle = "MAGMA sig genes")
```

## Run GSEA

```{r}
#| message: false
#| results: hide
## Run GSEA ---------------------------------------------------------------
gsea_res <- map(gmt, function(pathway) {
  map(rankings, function(rank) {
    fgsea(
      pathways = pathway,
      # List of gene sets to check
      stats = rank,
      # in this case we have both pos and neg rankings. if only pos or neg, set
      # to 'pos', 'neg'
      scoreType = 'std',
      minSize = 10,
      maxSize = 500,
      # for parallelisation
      nproc = 8
    )
  })
}) %>%
  purrr::set_names(basename(gmt_files))
```


```{r}
# get log2 FC as a vector with the respective gene names, sorted in decreasing 
# order
named_vectors <- res_sig %>%
  dplyr::group_by(celltype) %>%
  tidyr::nest() %>%
  dplyr::mutate(gene_list = map(data, ~setNames(.x$ZSTAT, .x$hgnc_symbol) %>%
                                  sort(decreasing = TRUE)))
```

## Gene Ontology

```{r}
# Define the file path to save the resulting object
result_file <-
  here::here(
    "03_data/990_processed_data/007_magma/001_pathway_analysis/gene-set-enrichment_go_magma.rds"
  )

# Check if the file exists
if (!file.exists(result_file)) {
  plan(multisession, workers = parallel::detectCores() - 1)
  # Code for your time-consuming analysis
  gse_bp <-
    future_map(
      rankings,
      ~ gseGO(
        .x,
        OrgDb = "org.Hs.eg.db",
        ont = "BP",
        keyType = "SYMBOL"
      ), .options = furrr_options(seed = 123)
    ) 
  gse_cc <-
    future_map(
      rankings,
      ~ gseGO(
        .x,
        OrgDb = "org.Hs.eg.db",
        ont = "CC",
        keyType = "SYMBOL"
      ), .options = furrr_options(seed = 123)
    ) 
  gse_mf <-
    future_map(
      rankings,
      ~ gseGO(
        .x,
        OrgDb = "org.Hs.eg.db",
        ont = "MF",
        keyType = "SYMBOL"
      ), .options = furrr_options(seed = 123)
    ) 
  
  names(gse_bp) <- paste0(names(gse_bp), "_BP")
  names(gse_mf) <- paste0(names(gse_mf), "_MF")
  names(gse_cc) <- paste0(names(gse_cc), "_CC")
  gse <- c(gse_bp, gse_mf, gse_cc)
  rm(gse_bp, gse_mf, gse_cc)
  
  # Save the resulting object
  readr::write_rds(gse, result_file)
} else {
  # Load the existing resulting object
  gse <- readr::read_rds(result_file)
}
```

```{r}
# remove any with no pathways found
gse <- gse %>%
  purrr::keep(~ nrow(.) > 0)
```

### Insulin pathways

Zam is interested in pathways related to insulin, so I'll filter to celltypes where such terms are present

```{r}
# Function to check for the presence of 'insulin' in the pathway description
find_insulin <- function(df) {
  df <- as_tibble(df)
  grepl("insulin", df$Description, ignore.case = TRUE)
}

# Apply the function to each dataframe in the list
insulin_related <- lapply(gse, find_insulin)

# Now, determine which celltypes have any insulin-related pathways
celltypes_with_insulin <- names(insulin_related)[sapply(insulin_related, any)]

# Print the celltypes with insulin-related pathways
print(celltypes_with_insulin)

# Remove ambiguous
celltypes_with_insulin <-
  celltypes_with_insulin[!celltypes_with_insulin == "ambiguous"]

print("Celltype with 'insulin' in pathway description:")
paste0(celltypes_with_insulin, collapse = ", ")
```

Get the genes of these celltypes too

```{r}
#| eval: false

# Save the dotplots of this subset
insulin_pathways <- gse[names(gse) %in% celltypes_with_insulin]
dotplots <-
  map2(
    insulin_pathways,
    names(insulin_pathways),
    ~ dotplot(.x, showCategory = 10, split = ".sign") + facet_grid(. ~ .sign) +
      ggtitle(.y)
  )

# Specify the filename for the PDF
if(include_apoe) {
pdf_file <- here::here("insulin_celltype_dotplots_apoe.pdf")
} else {
pdf_file <- here::here("insulin_celltype_dotplots_no-apoe.pdf")
}
# Open the PDF device
pdf(pdf_file)
dotplots
# Close the PDF device
dev.off()

insulin_genes <- res_sig |>
  dplyr::filter(celltype %in% celltypes_with_insulin)
insulin_genes |> dplyr::filter(celltype == "Capillary") |> dim()
if(include_apoe) {
readr::write_csv(insulin_genes, here::here("insulin_celltypes_sig_genes_apoe.csv"))
} else {
readr::write_csv(insulin_genes, here::here("insulin_celltypes_sig_genes_no-apoe.csv"))
}
```

### Plots

```{r}
dotplots <-
  map2(
    gse,
    names(gse),
    ~ dotplot(.x, showCategory = 10, split = ".sign") + facet_grid(. ~ .sign) +
      ggtitle(.y)
  )

# Use the sub function to extract the substring before the first underscore
celltypes <- sub("_.*", "", names(dotplots)) |> unique()

merge_plots <- function(celltype, dotplot_list) {
  # subset to relevant plots
  plots <- dotplot_list[grepl(celltype, names(dotplot_list))]
  # Merge plots
  plot <- plots[[1]] + plots[[2]] + plots[[3]]
}

plots <- map(celltypes, merge_plots, dotplots) |> set_names(celltypes)

plots

# Save plots
map2(plots, names(plots), ~ ggsave(here::here("05_figures/990_shared_figures/001_magma/magma_pathways", paste0(.y, ".png")), plot = .x, width = 18))
```


```{r}
#| eval: false
#| include: false
map2(gse,
     names(gse),
     ~ emapplot(.x, showCategory = 10) +
                  ggtitle(.y))
```

```{r}
map2(gse,
     names(gse),
     ~ ridgeplot(.x) +
       labs(x = "enrichment distribution") +
                  ggtitle(.y))
```

Note, one can change which pathway is plotted here by setting the title and `geneSetID` accordingly

```{r}
map2(gse,
     names(gse),
     ~ gseaplot(.x, by = "all", title = .x$Description[1], geneSetID = 1))
```

