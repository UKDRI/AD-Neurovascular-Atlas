---
title: EndoMT pseudotime
execute:
  eval: true
code-fold: true
---

```{r}
here::i_am("04_data_analysis/001_snrnaseq_analysis/16_pathway_analysis.qmd")
```

The "EndoMT" population looks to be some kind of transitioning celltype, perhaps endothelial cells transitioning to mural cells, or some more broad stem cell population that could go in both/more directions.

# Load packages

```{r}
source(here::here("04_data_analysis/990_code_libraries/02_library-calls-for-renv.R"))
Sys.setenv(TAR_PROJECT = here::here())
tar_config_set(store = here::here("_targets"))
library(SeuratWrappers)
library(monocle3)
library(slingshot)
library(GGally)
```

```{r}
# Get seurat object
tar_load(sce)
tar_load(gene_ids)
tar_load(translated_id)

assertthat::assert_that(sum(rownames(sce@assays$RNA@counts) ==
                              gene_ids$ensembl) == nrow(gene_ids))
```

```{r}
DimPlot(sce, reduction = "umap", group.by = "highlevel_manual_annotations",
        label = TRUE)
DimPlot(sce, reduction = "umap", group.by = "subcelltype_annotations",
        label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "highlevel_manual_annotations",
        label = TRUE)
```

## EndoMT

### Subset to celltypes

```{r}
# Subset to EndoMT
rownames(sce@assays$RNA@data) <- gene_ids$ensembl
sce <- subset(sce, highlevel_manual_annotations %in% c("SMC", "Pericyte", "mystery-cluster", "Endothelial"))
# remove unneded cells
sce <- subset(sce, subcelltype_annotations %in% c("Oligo-A", "Astrocyte-activated"), invert = TRUE)
```

```{r}
sce <- NormalizeData(sce)
sce <- FindVariableFeatures(sce)
sce <- ScaleData(sce)
```

```{r}
sce <- RunPCA(sce, dims = 1:30)
sce <- RunUMAP(sce, dims = 1:30)
ElbowPlot(sce, ndims = 30)
```

```{r}
# This resolution is good to recapture the level 2 celltypes
#sce <- FindClusters(sce, resolution = 0.3)
# this is good to reduce the celltypes to three main clusters
sce <- FindClusters(sce, resolution = 0.05)
```


```{r}
DimPlot(sce, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(sce, reduction = "umap", group.by = "highlevel_manual_annotations",
              label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "seurat_clusters",
              label = TRUE)
```

```{r}
p1 <- DimPlot(sce, reduction = "umap", group.by = "subcelltype_annotations",
              label = TRUE)
p2 <- DimPlot(sce, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)
p1|p2
p1 <- DimPlot(sce, reduction = "umap", group.by = "highlevel_manual_annotations",
              label = TRUE)
p2 <- DimPlot(sce, reduction = "pca", group.by = "highlevel_manual_annotations",
              label = TRUE)
p1|p2
```

```{r}
# Extract PCA embeddings
pca_embeddings <- Embeddings(sce, reduction = "pca")

# Create a data frame for the first two principal components
pca_df <- data.frame(PC1 = pca_embeddings[, 1], PC2 = pca_embeddings[, 2],
                     celltype = sce$highlevel_manual_annotations)

library(ggpointdensity)
# Generate the density plot
p1 <- ggplot(pca_df, aes(x = PC1, y = PC2)) +
  geom_pointdensity() +
  #geom_point(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Density Plot of First Two Principal Components",
       x = "PC1",
       y = "PC2") +
  facet_wrap(~celltype)
p2 <- ggplot(pca_df, aes(x = PC1, y = PC2, colour = celltype)) +
  geom_pointdensity() +
  #geom_point(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Density Plot of First Two Principal Components",
       x = "PC1",
       y = "PC2")
p1|p2
```

```{r}
# Create a data frame for the first 30 principal components and cell type annotations
pca_df <- data.frame(pca_embeddings[, 1:30], CellType = sce$highlevel_manual_annotations)

# Function to create scatter plots for each pair of PCs
plot_pcs <- function(i) {
  pc_x <- paste0("PC_", i)
  pc_y <- paste0("PC_", i + 1)
  ggplot(pca_df, aes_string(x = pc_x, y = pc_y, color = "CellType")) +
    geom_point(alpha = 0.5) +
    theme_minimal() +
    labs(title = paste(pc_x, "vs", pc_y),
         x = pc_x,
         y = pc_y,
         color = "Cell Type")
}

# Generate scatter plots for PC1 vs PC2, PC3 vs PC4, ..., PC29 vs PC30 using lapply
plots <- lapply(seq(1, 29, by = 2), plot_pcs)

# Arrange plots in a grid
plots <- do.call(grid.arrange, c(plots, ncol = 3))
ggsave(here::here("05_figures/990_shared_figures/004_pseudotime/first_30_pcs.png"), plots, width = 20, height = 15)

# Function to create scatter plots for each pair of PCs
plot_pcs <- function(i) {
  pc_x <- paste0("PC_", i)
  pc_y <- paste0("PC_", i + 1)
  ggplot(pca_df, aes_string(x = pc_x, y = pc_y)) +
    geom_pointdensity() +
    theme_minimal() +
    labs(title = paste(pc_x, "vs", pc_y),
         x = pc_x,
         y = pc_y,
         color = "Cell Type") +
    facet_wrap(~ CellType)
}

# Generate scatter plots for PC1 vs PC2, PC3 vs PC4, ..., PC29 vs PC30 using lapply
plots <- lapply(seq(1, 29, by = 2), plot_pcs)

# Arrange plots in a grid
plots <- do.call(grid.arrange, c(plots, ncol = 3))
ggsave(here::here("05_figures/990_shared_figures/004_pseudotime/first_30_pcs_facet.png"), plots, width = 20, height = 15)
```

```{r}
sce <- RunPCA(sce, npcs = 2)
# This splits the pericyte and smcs
sce <- FindClusters(sce, resolution = 0.1)
sce <- RunUMAP(sce, dims = 1:2)
```

```{r}
sce$highlevel_manual_annotations <- if_else(sce$highlevel_manual_annotations == "mystery-cluster", "EndoMT", sce$highlevel_manual_annotations)
```

```{r}
# Subset to just your transitionary population
Idents(sce) <- sce$highlevel_manual_annotations
endo_transition <- subset(sce, idents = "EndoMT")

# Rerun preprocessing on just this population
options(future.globals.maxSize = 30000 * 1024^2) ## 30 GB
endo_transition <- SCTransform(endo_transition)
endo_transition <- RunPCA(endo_transition, npcs = 2)
endo_transition <- RunUMAP(endo_transition, dims = 1:2)

# Find subclusters
endo_transition <- FindNeighbors(endo_transition, dims = 1:2)
endo_transition <- FindClusters(endo_transition, resolution = 0.02)

DimPlot(endo_transition, reduction = "pca", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(endo_transition, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)

# Get new clusters
subclusters <- case_when(
  Idents(endo_transition) == 0 ~ "EndoMT_1",
  Idents(endo_transition) == 1 ~ "EndoMT_2",
  Idents(endo_transition) == 2 ~ "EndoMT_1",
  .default = NA)

names(subclusters) <- colnames(endo_transition)

# Create a vector the same length as your original object, filled with NAs
new_clusters <- rep(NA, ncol(sce))
names(new_clusters) <- colnames(sce)

# Fill in the subcluster identities for the transitionary cells
new_clusters[names(subclusters)] <- subclusters

# Add this as a new metadata column
sce$endomt_subclusters <- new_clusters

# Update Idents
new_clusters[is.na(new_clusters)] <- sce$highlevel_manual_annotations[is.na(new_clusters)]
qs::qsave(new_clusters,
          here("03_data/990_processed_data/008_pseudotime",
          "endomt_subclusters.qs"))
Idents(sce) <- new_clusters
sce$level1_celltypes_with_endomt_subclusters <- Idents(sce)
```


```{r}
DimPlot(sce, reduction = "umap", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(sce, reduction = "umap", group.by = "highlevel_manual_annotations",
              label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "seurat_clusters",
              label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "level1_celltypes_with_endomt_subclusters",
              label = TRUE)
DimPlot(sce, reduction = "pca", group.by = "diagnosis",
              label = TRUE)
```

### Slingshot

The PCA plot looks to capture the lineages quite nicely by itself, so I'll use that as the basis.

```{r}
# Convert Seurat object to SingleCellExperiment
sce_slingshot <- as.SingleCellExperiment(sce)
```

```{r}
sce_slingshot <- slingshot(
  sce_slingshot,
  clusterLabels = 'level1_celltypes_with_endomt_subclusters',
  start.clus = "Endothelial",
  reducedDim = 'PCA'
)
png(here::here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca_endothelial_start_ndim2_res0.1.png"))
plot(reducedDims(sce_slingshot)$PCA, col = sce$level1_celltypes_with_endomt_subclusters, pch = 16, asp = 1)
lines(SlingshotDataSet(sce_slingshot), lwd = 2)
dev.off()
```

```{r}
# 1. Plot PCA with Slingshot trajectory
pca <- reducedDims(sce_slingshot)$PCA
lineages <- slingCurves(sce_slingshot)

qs::qsave(sce_slingshot, here("03_data/990_processed_data/008_pseudotime",
                              "slingshot_obj.qs"))
# sce_slingshot <- qs::qread(here("03_data/990_processed_data/008_pseudotime",
#                               "slingshot_obj.qs"))

celltype <- sce_slingshot$level1_celltypes_with_endomt_subclusters
#celltype <- sce_slingshot$subcelltype_annotations
celltype <- str_replace(celltype, "_", "-")

# Plot PCA colored by cell type
# Flip x-axis
p_pca <- ggplot(as.data.frame(pca), aes(x = -PC_1, y = PC_2)) +
  geom_point(aes(color = celltype),
             size = 0.8, alpha = 0.6) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  labs(x = "PC1", y = "PC2", color = "Celltype &\nLineage") +
  scale_color_npg()
  #scale_color_brewer(palette = "Dark2")

# Add arrows to the curves
curves <- map2_dfr(lineages, names(lineages), ~ .x$s |>
           as.data.frame() |>
           mutate(lineage = .y)) |>
  mutate(lineage = if_else(lineage == "Lineage1", "EndoMT-SMC Lienage",
                           "EndoMT-PC Lineage"))

# Add arrows using geom_path and arrow.decoration
p_pca <- p_pca +
  geom_path(data = curves,
            aes(x = -PC_1, y = PC_2, colour = lineage), # Note the negative PC_1
            linewidth = 1.1,
            arrow = arrow(type = "closed",
                         length = unit(0.1, "inches"),
                         ends = "last"))

# Calculate centroids for each cell type
centroids <- data.frame(
  PC_1 = pca[, 1],
  PC_2 = pca[, 2],
  CellType = celltype) |>
  group_by(CellType) |>
  summarise(
    mean_PC1 = mean(PC_1),
    mean_PC2 = mean(PC_2)
  )
 p_pca_labeled <- p_pca +
  geom_text_repel(
    data = centroids,
    aes(x = -mean_PC1, y = mean_PC2, label = CellType),
    color = "black",
    size = 3,
    box.padding = 0.5,
    point.padding = 0.5,
    force = 10,
    segment.color = "grey50",
    segment.size = 0.5,
    max.overlaps = Inf
  )

print(p_pca_labeled)

ggsave(here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca_npc2_res0.1.png"), height = 8, width = 10)
#ggsave(here("05_figures/990_shared_figures/004_pseudotime/slingshot_pca_npc2_res0.1_level-2-celltypes.png"), height = 8, width = 10)


# Extract pseudotimes
pseudotime <- slingPseudotime(sce_slingshot)

# Convert to data frame for ggplot
pseudotime_df <- data.frame(
  Pseudotime1 = pseudotime[,1],
  Pseudotime2 = pseudotime[,2],
  Group = sce_slingshot$diagnosis
)

# Plot Pseudotime for Lineage 1
p1 <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 1", x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 2
p2 <- ggplot(pseudotime_df, aes(x = Pseudotime2, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 2", x = "Pseudotime", y = "Density")

# Combine the density plots side by side
p_density <- plot_grid(p1, p2, labels = c("A", "B"))

print(p_density)

# Convert to data frame for ggplot
pseudotime_df <- data.frame(
  Cell = colnames(sce_slingshot),
  Pseudotime1 = pseudotime[,1],
  Pseudotime2 = pseudotime[,2],
  Group = sce_slingshot$diagnosis,
  CellType = sce_slingshot$level1_celltypes_with_endomt_subclusters
)

# Plot Pseudotime for Lineage 1
p1_diagnosis <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 1", x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 2
p2_diagnosis <- ggplot(pseudotime_df, aes(x = Pseudotime2, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 2", x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 1 with Cell Type
p1_no_facet <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 1 by Cell Type", x = "Pseudotime", y = "Density")

p2_no_facet <- ggplot(pseudotime_df, aes(x = Pseudotime2, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Pseudotime Distribution for Lineage 2 by Cell Type", x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 2 with Cell Type
p1 <- ggplot(pseudotime_df, aes(x = Pseudotime1, fill = CellType)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  facet_wrap(~ Group) +  # Separate plots for cases and controls
  labs(x = "Pseudotime", y = "Density")

# Plot Pseudotime for Lineage 2 with Cell Type
p2 <- ggplot(pseudotime_df, aes(x = Pseudotime2, fill = CellType)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  facet_wrap(~ Group) +  # Separate plots for cases and controls
  labs(x = "Pseudotime", y = "Density")

# Combine the density plots side by side
p_density <- plot_grid(p1, p2, labels = c("A", "B"))

(p1_no_facet + p2_no_facet) / (p1 + p2)

ggsave(here("05_figures/990_shared_figures/004_pseudotime/slingshot_density_npc2_res0.1.png"), height = 8, width = 10)

print(p_density)


p1 <- ggplot(data.frame(pca, pseudotime), aes(PC_1, PC_2, color = Lineage1)) +
  geom_point(alpha = 0.7) +
  scale_color_viridis_c(option = 'plasma', name = 'Pseudotime') +
  labs(x = 'PC1', y = 'PC2') +
  theme_minimal()
```

```{r}
metadata <- data.frame(
  donor = colData(sce_slingshot)$donor,
  celltype = sce_slingshot@colData$level1_celltypes_with_endomt_subclusters,
  diagnosis = sce_slingshot@colData$diagnosis
)

percent_overall <- metadata |>
  dplyr::count(donor, celltype, diagnosis) |>
  dplyr::mutate(percent = n / sum(n) * 100, .by = donor)
# get the percent of endomt in endothelial cells per donor
percent_endomt <- metadata |>
  dplyr::filter(!celltype %in% c("Pericyte", "SMC")) |>
  dplyr::mutate(celltype = if_else(grepl("EndoMT", celltype), "EndoMT", celltype)) |>
  dplyr::count(donor, celltype, diagnosis) |>
  dplyr::mutate(percent = n / sum(n) * 100, .by = donor) |>
  dplyr::filter(grepl("EndoMT", celltype)) |>
  dplyr::arrange(percent)

metadata |>
  dplyr::filter(donor %in% c("donor-31", "donor-11", "donor-23")) |>
  dplyr::count(donor, celltype, diagnosis) |>
  dplyr::mutate(percent = n / sum(n) * 100, .by = donor)

# Reshape data: Wide format (each cell type as a column)
wide_df <- percent_overall |>
  select(donor, celltype, percent, diagnosis) |>
  pivot_wider(names_from = celltype, values_from = percent, values_fill = 0)

# Move diagnosis column to rownames for annotation
rownames(wide_df) <- wide_df$donor
diagnosis_annotation <- wide_df %>%
  select(donor, diagnosis) %>%
  column_to_rownames("donor")

# Remove non-numeric columns before correlation
wide_numeric <- wide_df %>% select(-donor, -diagnosis)

pdf(here::here(
  "05_figures/990_shared_figures/003_final_figures",
  "001_data_for_plots", "donor-celltype-percent-corrgram.pdf"
))
corrgram::corrgram(wide_numeric,
  main = "Endothelial and mural celltype proportions",
  lower.panel = panel.pts, upper.panel = panel.conf,
  diag.panel = panel.density
)
dev.off()

# Compute correlation matrix
cor_matrix <- cor(wide_numeric, use = "pairwise.complete.obs")

# Plot
ggcorrplot(cor_matrix,
  method = "circle", # or "square" for heatmap-like look
  type = "upper", # Show only upper triangle
  lab = TRUE, # Show correlation values
  outline.col = "white",
  colors = c("#6D9EC1", "white", "#E46726") # Custom color palette
) +
  ggtitle("Endothelial and mural celltype proportions") +
  theme_minimal()

ggpairs(
  wide_numeric,
  lower = list(continuous = wrap("points", alpha = 0.5, size = 1.5)), # Scatterplots
  diag = list(continuous = wrap("densityDiag")), # Density plots on diagonal
  upper = list(continuous = wrap("cor", size = 6)) # Correlation coefficients
) +
  ggtitle("Endothelial and mural celltype proportions") +
  theme_minimal(base_size = 14)


# Compute correlation matrix (Spearman)
cor_matrix <- cor(wide_numeric, method = "spearman", use = "pairwise.complete.obs")

# Plot heatmap with case/control annotation
hmap <- pheatmap(as.matrix(wide_numeric),
  annotation_row = diagnosis_annotation, # Annotate donors by diagnosis
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  main = "Cell Type Proportions per Donor"
)
hmap

pdf(
  here::here(
    "05_figures/990_shared_figures/003_final_figures",
    "001_data_for_plots", "donor-celltype-percent.pdf"
  ),
  height = 15, width = 12
)
print(hmap)
dev.off()

pheatmap(cor_matrix,
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  display_numbers = TRUE,
  main = "Cell Type Proportion Correlations"
)



# Scatterplot: EndoMT vs Pericytes with color by Diagnosis
ggplot(wide_df, aes(x = EndoMT_2, y = Pericyte, color = diagnosis)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle("EndoMT vs Pericytes (Colored by Diagnosis)") +
  theme_minimal()

# Scatterplot: EndoMT vs SMC with color by Diagnosis
ggplot(wide_df, aes(x = EndoMT_2, y = SMC, color = diagnosis)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle("EndoMT vs SMC (Colored by Diagnosis)") +
  theme_minimal()


# Move donor column to rownames
wide_df <- wide_df |>
  as.data.frame()
rownames(wide_df) <- wide_df$donor
wide_numeric <- wide_df %>% dplyr::select(-donor, -diagnosis) # Remove donor column for numeric operations

# Compute correlation of EndoMT with all other cell types across donors
cor_vector <- cor(wide_numeric, method = "spearman", use = "pairwise.complete.obs")[, "EndoMT_2"]

# Convert to a dataframe for visualization
cor_df <- data.frame(CellType = names(cor_vector), Correlation = cor_vector)

# Heatmap of correlations
pheatmap(matrix(cor_vector, ncol = 1, dimnames = list(names(cor_vector), "Correlation")),
  display_numbers = TRUE,
  main = "Correlation of EndoMT with Other Cell Types Across Donors"
)
```

```{r}
# Pivot to wide format
percent_wide <- percent_overall %>%
  select(donor, celltype, percent) %>%
  pivot_wider(names_from = celltype, values_from = percent, values_fill = 0) %>%
  column_to_rownames("donor")

pca_res <- prcomp(percent_wide, scale. = TRUE, center = TRUE)

# Extract PC scores
pca_scores <- as.data.frame(pca_res$x)
pca_scores$donor <- rownames(pca_scores)
percent_wide$donor <- rownames(percent_wide)

# Merge PCA scores with original proportions
pca_merged <- left_join(pca_scores, percent_wide, by = "donor")

# Compute correlation of PC1 with EndoMT and other cell types
cor_results <- cor(pca_merged$PC1, pca_merged$EndoMT_1, method = "spearman")

print(cor_results)

rownames(pca_merged) <- pca_merged$donor
pca_merged$donor <- NULL
correlations <- cor(pca_merged[, grep("^PC", colnames(pca_merged))],
  pca_merged[, -grep("^PC", colnames(pca_merged))],
  method = "spearman"
)

print(correlations)

ggplot(pca_merged, aes(x = PC1, y = EndoMT_1)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(title = "PC1 vs EndoMT_1", x = "PC1", y = "EndoMT_1 proportion")

# Convert PCA scores to long format
pca_long <- pca_scores |>
  pivot_longer(cols = starts_with("PC"), names_to = "PC", values_to = "PC_value")


# Convert cell type proportions to long format
proportions_long <- percent_wide |>
  pivot_longer(cols = -donor, names_to = "celltype", values_to = "percent")

# Merge PCA scores and cell type proportions
plot_data <- left_join(pca_long, proportions_long, by = "donor")

ggplot(plot_data, aes(x = PC_value, y = percent)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE, color = "blue") + # Add trendline
  facet_grid(celltype ~ PC, scales = "free") + # Facet by both PC and cell type
  labs(x = "PC Value", y = "Cell Type Proportion", title = "PCA vs Cell Type Proportions") +
  theme_minimal() +
  theme(strip.text = element_text(size = 10, face = "bold"))
```

### Density plot

```{r}
pseudotime_data <- data.frame(slingPseudotime(sce_slingshot))
pseudotime_data <- pseudotime_data |>
  dplyr::mutate(
    Group = sce_slingshot$diagnosis,
    CellType = sce_slingshot$level1_celltypes_with_endomt_subclusters
  ) |>
  pivot_longer(cols = starts_with("Lineage"),
               names_to = "lineage",
               values_to = "Pseudotime") |>
  dplyr::mutate(celltype_reduced = case_when(
    CellType %in% c("EndoMT_1", "EndoMT_2") ~ "EndoMT-1/2",
    CellType %in% c("Pericyte", "SMC") ~ "Pericyte/SMC",
    .default = CellType)) |>
  dplyr::filter(!is.na(Pseudotime))
```

```{r}
#| eval: false

# Calculate cell type abundance per pseudotime bin
celltype_abundance <- pseudotime_data |>
  dplyr::group_by(Pseudotime = cut(Pseudotime, breaks = 5)) %>%
  dplyr::count(celltype_reduced) %>%
  dplyr::group_by(Pseudotime) %>%
  dplyr::slice_max(n, n = 1) %>%
  dplyr::ungroup()

density <- celltype_abundance$Pseudotime |>
  str_remove_all("]") |> str_remove_all("\\(") |> str_split(",") |>
  map_dfr(~ data.frame("min" = as.numeric(.x[1]), "max" = as.numeric(.x[2]))) |>
  cbind("celltype" = celltype_abundance$celltype_reduced) |>
  dplyr::mutate(Pseudotime = 10)

# Prepare density data for each lineage and group
density_data <- lapply(lineage_names, function(lineage) {
  pseudotime_data %>%
    filter(!is.na(Pseudotime[, lineage])) %>%
    group_by(Group) %>%
    summarise(
      density = density(Pseudotime[, lineage],
                        from = min(Pseudotime[, lineage], na.rm = TRUE),
                        to = max(Pseudotime[, lineage], na.rm = TRUE))
    )
})

density_plot <- ggplot(pseudotime_data, aes(x = Pseudotime, fill = Group)) +
  geom_density(alpha = 0.7) +
  theme_minimal() +
  labs(x = "Pseudotime", y = "Density") +
  facet_wrap(~lineage) +
  geom_rect(data = density,
            aes(xmin = min, xmax = max, ymin = 0, ymax = 0.15,
                fill = celltype), alpha = 0.2)
density_plot
```

```{r}
pseudotime_data <- pseudotime_data |>
  dplyr::mutate(Group = if_else(Group == "Case", "AD", Group),
                lineage = if_else(lineage == "Lineage1", "EndoMT-SMC Lienage",
                           "EndoMT-PC Lineage"))

# Calculate cell type proportions per pseudotime bin
celltype_proportions <- pseudotime_data |>
  dplyr::group_by(Pseudotime = cut(Pseudotime, breaks = 5), lineage) |>
  dplyr::group_by(Pseudotime, lineage, celltype_reduced) |>
  dplyr::summarise(count = n(), .groups = "drop") |>
  dplyr::group_by(Pseudotime, lineage) |>
  dplyr::mutate(proportion = count / sum(count)) |>
  dplyr::slice_max(proportion, n = 1) |>
  dplyr::ungroup()

# Create initial bar positions and consolidate consecutive same cell types
annotation_bars <- celltype_proportions |>
  dplyr::mutate(
    interval = Pseudotime |>
      str_remove_all("]") |>
      str_remove_all("\\(") |>
      str_split(","),
    xmin = map_dbl(interval, ~ as.numeric(.x[1])),
    xmax = map_dbl(interval, ~ as.numeric(.x[2]))
  ) |>
  # Group by lineage and cell type, then consolidate consecutive bins
  dplyr::group_by(lineage) |>
  dplyr::arrange(lineage, xmin) |>
  dplyr::mutate(
    group_id = cumsum(celltype_reduced != dplyr::lag(celltype_reduced, default = dplyr::first(celltype_reduced)))
  ) |>
  dplyr::group_by(lineage, celltype_reduced, group_id) |>
  dplyr::summarise(
    xmin = min(xmin),
    xmax = max(xmax),
    .groups = "drop"
  ) |>
  dplyr::mutate(
    x_mid = (xmin + xmax) / 2,
    ymin = 0.15,
    ymax = 0.16,
    label_y = 0.165
  )

# Create the density plot with consolidated annotation bars
density_plot <- ggplot() +
  geom_density(data = pseudotime_data,
               aes(x = Pseudotime, fill = Group),
               alpha = 0.7) +
  geom_rect(data = annotation_bars,
            aes(xmin = xmin, xmax = xmax,
                ymin = ymin, ymax = ymax,
                fill = celltype_reduced),
            inherit.aes = FALSE) +
  geom_text(data = annotation_bars,
            aes(x = x_mid, y = label_y, label = celltype_reduced),
            size = 2,
            #angle = 45,
            hjust = 0.5,
            inherit.aes = FALSE) +
  scale_fill_manual(
    values = c(
      "Control" = "#DC0000FF",
      "AD" = "#4DBBD4FF",
      "EndoMT-1/2" = "#E64B35FF",
      "Pericyte/SMC" = "#91D1C2FF",
      "Endothelial" = "#F39B7FFF",
      "Fibroblast" = "#7E6148FF"
    ),
    breaks = c("Control", "AD")
  ) +
  #scale_fill_npg(breaks = c("Control", "AD")) +
  theme_minimal() +
  labs(x = "Pseudotime", y = "Density", fill = "") +
  facet_wrap(~lineage) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.2)))
  #theme(plot.margin = margin(t = 40, r = 20, b = 20, l = 20, unit = "pt"))

density_plot
```

Make a density plot faceted by donor

```{r}
pseudotime_data <- data.frame(slingPseudotime(sce_slingshot))
pseudotime_data <- pseudotime_data |>
  dplyr::mutate(
    Group = sce_slingshot$diagnosis,
    CellType = sce_slingshot$level1_celltypes_with_endomt_subclusters,
    donor = sce_slingshot$donor
  ) |>
  pivot_longer(cols = starts_with("Lineage"),
               names_to = "lineage",
               values_to = "Pseudotime") |>
  dplyr::mutate(celltype_reduced = case_when(
    CellType %in% c("EndoMT_1", "EndoMT_2") ~ "EndoMT-1/2",
    CellType %in% c("Pericyte", "SMC") ~ "Pericyte/SMC",
    .default = CellType)) |>
  dplyr::filter(!is.na(Pseudotime))

pseudotime_data <- pseudotime_data |>
  dplyr::mutate(Group = if_else(Group == "Case", "AD", Group),
                lineage = if_else(lineage == "Lineage1", "EndoMT-SMC Lienage",
                           "EndoMT-PC Lineage"))

# Convert the donor column to a factor with the specified order
pseudotime_data$donor <- factor(pseudotime_data$donor, levels = percent_endomt$donor)

density_plot_donor <- ggplot() +
  geom_density(data = pseudotime_data,
               aes(x = Pseudotime, fill = Group),
               alpha = 0.7) +
  scale_fill_manual(
    values = c(
      "Control" = "#DC0000FF",
      "AD" = "#4DBBD4FF",
      "EndoMT-1/2" = "#E64B35FF",
      "Pericyte/SMC" = "#91D1C2FF",
      "Endothelial" = "#F39B7FFF",
      "Fibroblast" = "#7E6148FF"
    ),
    breaks = c("Control", "AD")
  ) +
  #scale_fill_npg(breaks = c("Control", "AD")) +
  theme_minimal() +
  labs(x = "Pseudotime", y = "Density", fill = "") +
  facet_wrap(vars(donor, lineage)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.2)))
  #theme(plot.margin = margin(t = 40, r = 20, b = 20, l = 20, unit = "pt"))

density_plot_donor

ggsave(filename = here("05_figures/990_shared_figures/003_final_figures",
                       "001_data_for_plots", "donor-density-plots.pdf"),
       height = 15, width = 12)
```

#### switchDE for pericyte lineage

```{r}
# This gives you the lineage-specific pseudotimes (rows = cells, columns = lineages)
pseudotime <- slingPseudotime(sce_slingshot)
# Lineage-specific weights (how much a cell is associated with a lineage)
weights <- slingCurveWeights(sce_slingshot)

# Get pseudotime for lineage 2
pt_pericyte <- pseudotime[, 2]  # adjust index if lineage order is different

# Get weights for lineage 2
w_pericyte <- weights[, 2]

# Choose cells strongly associated with the lineage (e.g., weight > 0.5)
cells_pericyte <- which(w_pericyte > 0.5 & !is.na(pt_pericyte))
```

```{r}
library(switchde)

counts <- assay(sce_slingshot, "logcounts")[, cells_pericyte]
# filter out genes based on mean expression and at least 20% of cells should express it.
counts <- counts[rowMeans(counts) > 0.1 & rowMeans(counts > 0) > 0.2,]
pt <- pt_pericyte[cells_pericyte]

file <- here::here("03_data/990_processed_data/008_pseudotime",
  "pericyte_switchde_results.qs")
if(!file.exists(file)) {
  res <- switchde(as.matrix(counts), pseudotime = pt)
  res <- res[order(res$qval), ]
  head(res)
  
  qs::qsave(res, file)
} else {
  res <- qs::qread(file)
}
```

In the switchDE results the `mu0` column is the mean expression prior to the switch.
`k` is the estimated slope or steepness of the switch (higher = sharper switch).
`t0` is the estimated switch point along pseudotime (where expression changes most)

```{r}
res <- res |>
  dplyr::left_join(translated_id, by = join_by(gene == ensembl_gene_id))

res_sig <- res |>
  dplyr::filter(pval == 0)


tf_link_table <- readr::read_tsv(here("03_data/991_external_data/TFLink_Homo_sapiens_interactions_All_simpleFormat_v1.0.tsv")) |> 
  dplyr::select(!contains("Target"))
head(tf_link_table)

res_sig <- res_sig |>
  dplyr::mutate(is_tf = hgnc_symbol %in% tf_link_table$Name.TF)

res_sig_tf <- res_sig |>
  dplyr::filter(is_tf & qval < 0.05)


top_tf_hits <- res_sig_tf[order(-abs(res_sig_tf$k)), ]  # strongest effect
head(top_tf_hits, 10)

res_sig_tf |>
  dplyr::filter(hgnc_symbol == "FOXP2")

```

```{r}
#| eval: false
# Create individual plots
plots <- lapply(top_tf_hits$gene, function(g) {
  df <- data.frame(
    pseudotime = pt,
    expression = counts[g, ],
    gene = g
  )
  
  ggplot(df, aes(x = pseudotime, y = expression)) +
    geom_point(alpha = 0.4, size = 1) +
    geom_smooth(method = "loess", se = FALSE, color = "steelblue") +
    labs(title = g, x = "Pseudotime", y = "Expression") +
    theme_minimal()
})

# Combine into a grid
plot_grid(plotlist = plots, ncol = 2)
```
### tradeseq results

The associationTest function gives the wald stat, the degrees of freedom and the unadjusted p-vals associated with each gene.
By default it doesn't test for each lineage independently.


```{r}
library(tradeSeq)
# Read in data from hawk
sce_subset <- qs::qread(here("03_data/990_processed_data/008_pseudotime/slingshot_tradeseq_3k_case_and_control.qs"))
```

```{r}
asso_res <- associationTest(sce_subset, lineages = TRUE)
asso_res_overall <- associationTest(sce_subset)
asso_res |> head(2) |> write_tsv("temp.txt")
# asso_res_consec <- associationTest(sce_subset, lineages = TRUE, contrastType = "consecutive")
# asso_res_consec |> head()

# Function to tidy the tradeseq output
tidy_tradeseq <- function(data) {
  # First, get the base columns that don't need splitting
  base_cols <- c("waldStat", "df", "pvalue")

  data <- data |>
    rownames_to_column("ensembl_gene_id")

  # Find columns that need to be split (those containing underscores)
  split_cols <- names(data)[grepl("_", names(data))]

  # Create the base dataframe with non-split columns
  base_df <- data[c(base_cols, "ensembl_gene_id")] |>
    dplyr::mutate(lineage = "overall")

  # Process the split columns
  if (sum(grepl("condition", split_cols)) > 0) {
    base_df$condition <- "overall"
    split_data <- data |>
      dplyr::select(all_of(split_cols)) |>
      pivot_longer(
        cols = -ensembl_gene_id,
        names_to = c(".value", "lineage", "condition"),
        names_pattern = "(.*)_lineage(\\d+)_condition(.*)"
      )
  } else {
    split_data <- data |>
      dplyr::select(all_of(split_cols)) |>
      pivot_longer(
        cols = -ensembl_gene_id,
        names_to = c(".value", "lineage"),
        names_pattern = "(.*)_lineage(\\d+)"
      )
  }

  result <- rbind(split_data, base_df)
  # Add logfc back in
  if (sum(grepl("condition", split_cols)) > 0) {
  result <- data[c("ensembl_gene_id", "meanLogFC")] |>
    dplyr::left_join(x = result, y = _, by = "ensembl_gene_id")
  }
  return(result)
}

asso_res_tidy <- tidy_tradeseq(asso_res) |>
  dplyr::left_join(translated_id, by = "ensembl_gene_id")

# Get top 10 genes per condition and lineage
top_genes <- asso_res_tidy |>
  dplyr::filter(hgnc_symbol != "" | !is.na(hgnc_symbol)) |>
  dplyr::group_by(condition, lineage) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE) |>
  dplyr::ungroup() |>
  dplyr::filter(pvalue == 0)

table(top_genes$lineage, top_genes$condition)

top_controls <- top_genes |>
  dplyr::filter(condition == "Control") |>
  slice_max(waldStat, n = 25, with_ties = FALSE, by = c(condition, lineage)) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)

pdf(here("05_figures/990_shared_figures/004_pseudotime/01_tradeseq/",
                       "top_controls_pseudotime_degs.pdf"),
       height = 12, width = 20)
map2(top_controls$ensembl_gene_id, top_controls$hgnc_symbol, ~ plotSmoothers(sce_subset, counts, .x) +
    ggtitle(.y))
dev.off()

# CNTN1 looks unique to lineage 1!
lineage_genes <- c("CHF", "TFPI", "PDK4", "ITGA3", "JARID2", "CYTH3", "ZNF207",
                   "SLC6A13", "FYN", "MRC2", "DCN", "RUFY3", "CNTN1", "ATP1A2",
                   "NR1H3", "PRKCH", "ZFHX3", "FLT1", "ATP10A", "PLEKHG1",
                   "RORA", "IGF1R", "SLC6A1", "LAMA2", "SLC6A12", "SORBS1",
                   "SEC14L1", "PDE3A")

top_lineage_degs <- top_genes |>
  dplyr::filter(hgnc_symbol %in% lineage_genes)

# Get stats for the all genes overall across all lineages and conditions
plot_gene_pseudotime <- function(gene, gene_symbol, sce, counts) {
  plot <- plotSmoothers(sce, counts, gene, curvesCols = pal_npg("nrc")(4)) +
    scale_colour_npg(labels = c("EndoMT-SMC - AD", "EndoMT-SMC - Control",
                                "EndoMT-PC - AD",
                                "EndoMT-PC - Control")) +
    ggtitle(if_else(gene_symbol == "", gene, gene_symbol)) +
    labs(colour = "Lineage") +
    theme(legend.position = "none")
  return(plot)
}

counts <- assays(sce_subset)$counts

plot_lineages <- map2(unique(top_lineage_degs$ensembl_gene_id),
                      unique(top_lineage_degs$hgnc_symbol),
              plot_gene_pseudotime, sce_subset, counts)

plot_lineages[[5]] <- plot_lineages[[5]] +
  theme(legend.position = "right")


plot <- plot_grid(plotlist = plot_lineages, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "top_lineage_pseudotime_degs.png"),
       height = 14, width = 18)
```

## Key genes for figure

```{r}
key_genes <- translated_id |>
  dplyr::filter(hgnc_symbol %in% c("BACE2", "APOD"))

plot_lineages <- map2(unique(key_genes$ensembl_gene_id),
                      unique(key_genes$hgnc_symbol),
              plot_gene_pseudotime, sce_subset, counts)
apod <- plot_lineages[[2]] +
  theme(legend.position = "bottom")

# extract a legend that is laid out horizontally
legend_b <- get_legend(
  apod +
    guides(color = guide_legend(nrow = 1)) +
    theme(legend.position = "bottom")
)
prow <- plot_grid(apod + theme(legend.position = "none"), plot_lineages[[1]])
key_genes_plot <- plot_grid(prow, legend_b, ncol = 1, rel_heights = c(1, 0.1))

key_genes <- translated_id |>
  dplyr::filter(grepl("^ANG", hgnc_symbol)) |>
  dplyr::filter(ensembl_gene_id %in% rownames(counts))

plot_lineages <- map2(unique(key_genes$ensembl_gene_id),
                      unique(key_genes$hgnc_symbol),
              plot_gene_pseudotime, sce_subset, counts)
plot_lineages[[5]] <- plot_lineages[[5]] +
  theme(legend.position = "right")


plot <- plot_grid(plotlist = plot_lineages, ncol = 3)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "ANG_genes.png"),
       height = 14, width = 18)
```

## Build figure

```{r}
plot <- plot_grid(p_pca_labeled, density_plot, key_genes_plot,
                   ncol = 1, labels = "AUTO",
                  rel_heights = c(1.2, 1, 1))
plot
ggsave(here::here("05_figures/990_shared_figures/003_final_figures",
                  "endomt_fig.pdf"), plot, width = 7, height = 9, units = "in")
#plot_grid(p_pca_labeled, density_plot, key_genes_plot, labels = "AUTO", nrow = 3)
```


```{r}
x <- predictSmooth(sce_subset, "ENSG00000000971")

x <- x |> dplyr::mutate(lineage_condition = paste0("Lienage-", lineage, "_", condition))
plot_example <- plotSmoothers(sce_subset, counts, "ENSG00000000971")


ggplot(x, aes(x = time, y = log(yhat + 1), colour = lineage_condition)) +
  geom_point() +
#  geom_smooth(linewidth = 1) +
  # Add confidence interval ribbon if you have SE columns
  # geom_ribbon(aes(ymin = yhat - 2 * SE, ymax = yhat + 2 * SE),
  #             alpha = 0.2,
  #             fill = "blue")+
  theme_bw() +
  labs(x = "Pseudotime",
       y = "Expression",
       title = "Gene Expression over Pseudotime") +
  theme(panel.grid.minor = element_blank())

```

### Get best lineage genes

It's difficult to identify the genes most differential between lineages for the EndoMTs.
I'll get the area under the curve between a range of pseudotime I'm interested in for each group and then get the mean AUC for each lineage and the difference between cases and controls for the lineage.
Then I can try to identify the genes with the biggest lineage AUC difference and plots those to see if this works, and hopefully identify the most relevant genes.

```{r}
# Get all genes with a p-value of 0
all_top_genes <- top_genes |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)

table(all_top_genes$condition, all_top_genes$lineage)

smoothed_values <- predictSmooth(sce_subset,
                                 gene = unique(all_top_genes$ensembl_gene_id),
                                 nPoints = 100)
library(pracma)

compute_auc <- function(pseudotime, expression) {
  auc <- trapz(pseudotime, expression)
  return(auc)
}

pseudotime_ranges = list(c(0, 10), c(11, 20), c(21, 30),
                         c(31, max(smoothed_values$time)), c(15, 28),
                         c(0, max(smoothed_values$time)))
names(pseudotime_ranges) <- c("0-10", "11-20", "21-30", "30+", "15-28", "overall")
subset_smoothed_values <- map(pseudotime_ranges, ~ {
  smoothed_values |>
    dplyr::filter(time >= .x[1] & time <= .x[2])
})

auc_results <- map2(subset_smoothed_values, names(subset_smoothed_values), ~ {
  .x |>
    summarize(AUC = compute_auc(time, yhat),
              pseudotime_range = .y,
              .by = c(gene, lineage, condition))
}) |>
  list_rbind()
```

```{r}
# Get the difference between lineage 1 and 2 for controls
lin_diff <- auc_results |>
  as_tibble() |>
  dplyr::filter(condition == "Control") |>
  dplyr::summarise(lin1_minus_lin2 = AUC[lineage == 1] - AUC[lineage == 2], .by = c(pseudotime_range, gene))

top_lin_diff <- lin_diff |>
  dplyr::left_join(translated_id, by = join_by(gene == ensembl_gene_id)) |>
  dplyr::filter(hgnc_symbol != "") |>
  dplyr::slice_max(abs(lin1_minus_lin2), by = pseudotime_range, n = 12) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)
head(top_lin_diff)

top_lin_plots <- map2(top_lin_diff$gene, top_lin_diff$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

top_lin_plots[[1]]
top_lin_plots[[5]] <- top_lin_plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = top_lin_plots, ncol = 5)
plot
ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "top_lineage_4_pseudotime_bins.png"),
       height = 18, width = 18)
```

```{r}
# Get the difference between cases and controls per lineage
condition_diff <- auc_results |>
  as_tibble() |>
  dplyr::summarise(case_minus_control = AUC[condition == "Case"] -
                     AUC[condition == "Control"],
                   .by = c(pseudotime_range, gene, lineage))

top_cond_diff <- condition_diff |>
  dplyr::left_join(translated_id, by = join_by(gene == ensembl_gene_id)) |>
  dplyr::filter(hgnc_symbol != "") |>
  dplyr::slice_max(abs(case_minus_control), by = c(pseudotime_range, lineage),
                   n = 10) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)
head(top_cond_diff)

top_cond_plots <- map2(top_cond_diff$gene, top_cond_diff$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)
top_cond_plots[[5]] <- top_cond_plots[[5]] +
  theme(legend.position = "right")
plot <- plot_grid(plotlist = top_cond_plots, ncol = 5)
plot
ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "top_condition_4_pseudotime_bins.png"),
       height = 15, width = 18)
```


### patternTest

tradeseq has a function to check lineage sig gene

```{r}
lineage_genes <- patternTest(sce_subset)

# adjust pval and filter on fold change
get_top_genes <- function(df, fc_column, fc_filter = 2) {
  top_genes <- df |>
    rownames_to_column("ensembl_gene_id") |>
    as_tibble() |>
    dplyr::mutate(padj = p.adjust(pvalue, "bonferroni")) |>
    dplyr::filter(padj == 0 & abs({{ fc_column }}) > fc_filter) |>
    left_join(translated_id, by = "ensembl_gene_id") |>
    dplyr::filter(hgnc_symbol != "") |>
    dplyr::arrange(desc({{ fc_column }}))
  return(top_genes)
}

top_lin_genes <- get_top_genes(lineage_genes, fcMedian)

readr::write_csv(top_lin_genes,
                 here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_lineage_genes.csv"))

lineage_genes |>
    rownames_to_column("ensembl_gene_id") |>
    readr::write_csv(here("03_data/990_processed_data/008_pseudotime",
                      "all_pseudotime_lineage_genes.csv"))

dim(top_lin_genes)
top_genes <- top_lin_genes |>
  slice_max(fcMedian, n = 20)

plots <- map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[5]]
plots[[5]] <- plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "lineage_patterntest_top20.png"),
       height = 8, width = 18)
```

#### Lineage differentiating genes

List of genes that appear to be different between lineages, but not cases/controls:

- UST, CAP2, SLC12A7, FILIP1, CASQ2, TMEM131L, NR4A1, RHOJ, FOXP2, MYH11, PDZD2, TRPC3, MYOCD, ACKR3, DENND2A, PARD3, JPH2, SCN3A, PID1, ABCA9, SORBS2, ADAMTS1, PDE1C, TTN, COLEC12, PLXDC1, PDE7B, SH3RF3, SLC19A1, ERBB4, GRM8, LAMA2, RYR2, NR2F1âˆ’AS1, MIR100HG
- Note: RHOJ is also different in cases for lienage 2 at least
### Top early genes

#### Condition differential genes

- SLC38A2, SSTR2, RHOJ, LINC00472, LINC00882

```{r}
diff_early_genes <- tradeSeq::earlyDETest(sce_subset)

top_diff_early_genes <- get_top_genes(diff_early_genes, fcMedian)

readr::write_csv(top_diff_early_genes,
                 here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_diff_early_genes.csv"))

top_genes <- top_diff_early_genes |>
  slice_max(logFC1_2, n = 20)

plots <- map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[5]]
plots[[5]] <- plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "diff_early_genes_top20.png"),
       height = 10, width = 18)
```

### Top end genes

```{r}
# Assuming you've already run fitGAM
# Test for differential expression across pseudotime
# For lineage-specific differences
diff_end_genes <- tradeSeq::diffEndTest(sce_subset)

# Adjust p-values and filter logfc
top_diff_end_genes <- get_top_genes(diff_end_genes, logFC1_2)

readr::write_csv(top_diff_end_genes,
                 here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_diff_end_genes.csv"))

top_genes <- top_diff_end_genes |>
  # get genes that are unique to end genes
  dplyr::filter(!(ensembl_gene_id %in% top_diff_early_genes$ensembl_gene_id)) |>
  slice_max(logFC1_2, n = 20)

plots <- map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[5]]
plots[[5]] <- plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "diff_end_genes_top20.png"),
       height = 10, width = 18)
```

### Condition test

The `conditionTest` function test genes across conditions.
It can give overall genes, and per lineage, so I'll check both

```{r}
lineages <- conditionTest(sce_subset, lineages = TRUE, pairwise = TRUE)

lineages_tidy <- tidy_tradeseq(lineages)

top_genes_condition <- lineages_tidy |>
  dplyr::filter(pvalue == 0) |>
  dplyr::left_join(translated_id, by = "ensembl_gene_id") |>
  dplyr::filter(hgnc_symbol != "" & !is.na(hgnc_symbol))

length(unique(top_genes_condition$hgnc_symbol))
table(top_genes_condition$lineage)

readr::write_csv(top_genes_condition,
                 here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_condition_genes.csv"))

top_genes <- top_genes_condition |>
  slice_sample(n = 10, by = lineage)

plots <- map2(top_genes$ensembl_gene_id,
              top_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[5]]
plots[[5]] <- plots[[5]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 5)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "top_condition_genes.png"),
       height = 14, width = 18)
```

#### Hypergeometric pathways

It seems only lineage 2 has any pathway enrichment, and only in MF.

```{r}
genes <- top_genes_condition |>
  tidyr::nest(.by = lineage)

# plan("multisession", workers = parallel::detectCores() - 1)
go_results_all <- map(genes$data, ~ enrichGO(gene = .x$ensembl_gene_id, OrgDb = "org.Hs.eg.db",
                                    keyType = "ENSEMBL", ont = "ALL",
                                    universe = rownames(sce_subset)))
                           # .options = furrr_options(seed = 123))

names(go_results_all) <- genes$lineage

go_results_filtered <- go_results_all |>
  purrr::keep(~ !is.null(.)) |>
  purrr::keep(~ nrow(.) > 0)

# Apply pairwise_termism where possible
go_results_filtered <- map(go_results_filtered, ~{
  if(length(.x$ID) >= 2) {
    pairwise_termsim(.x)
  } else {
    .x
  }
})

# dotplots
dotplots <-
  map2(
    go_results_filtered,
    names(go_results_filtered),
    ~ dotplot(.x, showCategory = 20, split = "ONTOLOGY") + facet_grid(. ~ ONTOLOGY) +
      ggtitle(paste0(.y, " - Sig genes only"))
  )
dotplots
```


### All genes of interest

It might be nice to make a list and perhaps pdf of all the unique genes of interest accross the comparisons

```{r}
df <- list(top_diff_early_genes, top_diff_end_genes, top_genes_condition,
           top_lin_genes)
names(df) <- c("top_early_genes", "top_end_genes", "top_genes_condition",
  "top_lin_genes")
genes <- map(df, dplyr::pull, hgnc_symbol)
genes <- unique(unlist(genes))

head(df)
test <- df

cat("Number of unique genes of interest:", length(genes))

qs::qsave(test, here::here("05_figures/990_shared_figures/003_final_figures",
  "001_data_for_plots/tradeseq_sig_degs.qs"))
readr::write_rds(df, here::here("05_figures/990_shared_figures/003_final_figures",
  "001_data_for_plots/tradeseq_sig_degs.rds"))
```

### Additional genes to plot


```{r}
additional_genes <- translated_id |>
  dplyr::filter(hgnc_symbol %in% c("BACE2", "APOD", "MEF2C", "NOTCH1")) |>
  dplyr::distinct(hgnc_symbol, .keep_all = TRUE)

plots <- map2(additional_genes$ensembl_gene_id,
              additional_genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plots[[2]]
plots[[2]] <- plots[[2]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 2)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "additional_genes.png"),
       height = 6, width = 12)
```

### Transcription factors

Check if the genes are transcription factors, it might be of particular interest if there's some in the early diff genes.

```{r}
# Load required libraries
library(org.Hs.eg.db)
library(dplyr)
library(httr)
library(jsonlite)

# Function to check transcription factors using multiple methods
comprehensive_tf_check <- function(gene_list) {
  # Initialize results dataframe
  results <- data.frame(
    Gene = gene_list,
    Is_TF = NA,
    TF_Sources = NA,
    stringsAsFactors = FALSE
  )

  # 1. GO Annotation Check
  go_tf_term <- "GO:0003700"  # Transcription factor activity
  go_results <- tryCatch({
    go_annotations <- AnnotationDbi::select(org.Hs.eg.db,
                             keys = gene_list,
                             columns = c("GOALL"),
                             keytype = "SYMBOL")
    go_tf_genes <- go_annotations$SYMBOL[grep(go_tf_term, go_annotations$GOALL)]
    go_tf_genes
  }, error = function(e) c())

  # 2. TFClass Database Check (via manual API/web query simulation)
  tfclass_check <- sapply(gene_list, function(gene) {
    tryCatch({
      # Note: This is a simulated approach as TFClass doesn't have a direct R API
      url <- paste0("http://tfclass.bioinf.med.uni-goettingen.de/tfclass/cgi-bin/tfclass.py?VERSION=1.22&DATASET=TF&SPECIES=Homo%20sapiens&GENE=", gene)
      response <- GET(url)
      content <- content(response, "text")
      grepl("Transcription Factor", content)
    }, error = function(e) FALSE)
  })

  # 3. Literature-based TF Databases (simulated with known TFs)
  known_tfs <- c(
    "STAT3", "TP53", "MYC", "FOXO1", "NRF2", "CREB1",
    "ELK1", "SP1", "NFKB1", "HIF1A", "REST", "BRCA1"
  )

  # Combine results
  for (i in seq_along(gene_list)) {
    gene <- gene_list[i]
    sources <- c()

    # Check GO annotation
    if (gene %in% go_tf_genes) {
      sources <- c(sources, "GO_Annotation")
    }

    # Check TFClass
    if (tfclass_check[gene]) {
      sources <- c(sources, "TFClass")
    }

    # Check known TFs
    if (gene %in% known_tfs) {
      sources <- c(sources, "Literature_Known_TFs")
    }

    # Determine overall TF status
    results$Is_TF[i] <- length(sources) > 0
    results$TF_Sources[i] <- ifelse(length(sources) > 0,
                                    paste(sources, collapse = "; "),
                                    "No TF Evidence")
  }

  return(results)
}


# Early transcrition factors
early_tf <- comprehensive_tf_check(unique(top_diff_early_genes$hgnc_symbol))
table(early_tf$TF_Sources)
early_tf <- early_tf |>
  dplyr::filter(Is_TF) |>
  dplyr::left_join(translated_id, by = join_by(Gene == hgnc_symbol))

tf_link_match <- top_diff_early_genes |>
  dplyr::filter(hgnc_symbol %in% tf_link_table$Name.TF & !hgnc_symbol %in% early_tf$Gene)

all_tfs <- data.frame(gene = c(early_tf$Gene, tf_link_match$hgnc_symbol),
  ensembl_gene_id = c(early_tf$ensembl_gene_id, tf_link_match$ensembl_gene_id))

plots <- map2(all_tfs$ensembl_gene_id,
              all_tfs$gene,
              plot_gene_pseudotime, sce_subset, counts)

plots[[4]]
plots[[4]] <- plots[[4]] +
  theme(legend.position = "right")

plot <- plot_grid(plotlist = plots, ncol = 4)
plot

ggsave(filename = here("05_figures/990_shared_figures/004_pseudotime",
                       "01_tradeseq", "early_diff_tf_genes.png"),
       height = 6, width = 14)


all_tf <- comprehensive_tf_check(unique(genes))
all_tf <- all_tf |>
  dplyr::filter(Is_TF) |>
  dplyr::left_join(translated_id, by = join_by(Gene == hgnc_symbol))

readr::write_csv(all_tf,
                 here("03_data/990_processed_data/008_pseudotime",
                      "all_transcription_factors.csv"))

plots <- map2(all_tf$ensembl_gene_id,
              all_tf$Gene,
              plot_gene_pseudotime, sce_subset, counts)

plots[[4]]
plots[[4]] <- plots[[4]] +
  theme(legend.position = "right")

# Vectorized PDF creation
pdf(here::here("05_figures/990_shared_figures/004_pseudotime",
         "01_tradeseq", "all_transcription_factors.pdf"),
    width = 11, height = 8)

# Split the plot list into chunks of 4
plot_chunks <- split(plots, ceiling(seq_along(plots)/4))

# Use map to apply grid.arrange to each chunk
walk(plot_chunks, function(chunk) {
  do.call(grid.arrange, c(chunk, ncol = 2, nrow = 2))
})

dev.off()

table(all_tf$TF_Sources)
```


```{r}
# make supp figure of the TFs of interest
genes <- c("FOXP2", "RORA", "ZBTB7C", "PRDM16", "NR4A1")
genes <- translated_id |>
  dplyr::filter(hgnc_symbol %in% genes)

plots <- map2(genes$ensembl_gene_id,
              genes$hgnc_symbol,
              plot_gene_pseudotime, sce_subset, counts)

plot <- plot_grid(plotlist = plots, nrow = 2)

# extract the legend from one of the plots
legend <- get_legend(
  # create some space to the left of the legend
  plots[[1]] + theme(legend.position = "right", legend.box.margin = margin(0, 0, 0, 12))
)

plot_grid(plots[[3]], plots[[1]], plots[[2]], plots[[4]], plots[[5]], 
  legend, nrow = 2, labels = c("A", "B", "C", "D", "E", ""))

ggsave(filename = here("05_figures/990_shared_figures/003_final_figures",
                       "000_sup_figures", "endomt-lineage-transcription-factors.pdf"),
       width = 7, height = 7, units = "in")
```
Zam flagged there TFs as being visually interesting

```{r}
lineage1_genes <- c("ZBTB7C", "PRDM17", "JPH2", "NR4A1", "PPARG", "ZFHX3", "NR4A3", "FOSL2", "ETV6")
lineage2_genes <- c("RORA", "FOXP2", "ESRRG", "DACH1", "TCF4")

# If you want a named vector approach
lineage_genes <- c(
  setNames(lineage1_genes, rep("Lineage1", length(lineage1_genes))),
  setNames(lineage2_genes, rep("Lineage2", length(lineage2_genes)))
)
```

```{r}
# If you used fitGAM, you can extract information directly
cell_data <- data.frame(
  pseudotime = slingPseudotime(sce_subset),
  condition = sce_slingshot$diagnosis,
  lineage = slingLineages(sce_slingshot)
)

pseudotime <- slingPseudotime(sce_slingshot) |>
  as.data.frame()
pseudotime$condition <- colData(sce_slingshot)$diagnosis

# Extract count matrix from slingshot object
count_matrix <- assay(sce_slingshot)

genes_to_check <- translated_id |>
  dplyr::filter(hgnc_symbol %in% c("BACE2"))
# Extract expression for your gene of interest
gene_expr <- count_matrix[genes_to_check$ensembl_gene_id, ]

# Combine pseudotime and gene expression
plot_data <- data.frame(
  cell = colnames(count_matrix),
  expression = gene_expr,
  pseudotime_lineage1 = pseudotime$Lineage1,
  pseudotime_lineage2 = pseudotime$Lineage2,
  condition = sce_slingshot$diagnosis
)

head(plot_data)
assertthat::assert_that(sum(rownames(pseudotime) != plot_data$cell) == 0)

# Melt the data for easier plotting
plot_data <- plot_data |>
  pivot_longer(contains("_lineage"), names_to = "lineage", values_to = "pseudotime") |>
  dplyr::filter(!is.na(pseudotime)) |>
  dplyr::mutate(lineage = str_remove(lineage, "pseudotime_"))

# Plotting
ggplot(plot_data,
       aes(x = pseudotime,
           y = expression,
           color = condition,
           group = interaction(condition, lineage))) +
  geom_density(alpha = 0.5) +
#  geom_smooth(method = "loess", se = TRUE) +
  facet_wrap(~ lineage, scales = "free") +
  labs(
    title = paste("Expression of", "blah", "Across Pseudotime"),
    x = "Pseudotime",
    y = "Normalized Expression"
  ) +
  theme_minimal()
```

## Condiment differential trajectory analysis

```{r}
library(tradeSeq)

sds <- SlingshotDataSet(sce_slingshot)
# Set up parallel processing
BPPARAM <- BiocParallel::bpparam()
BPPARAM$workers <- parallel::detectCores() - 2
BPPARAM

# Evaluate the optimal number of knots
set.seed(123)  # For reproducibility
k_values <- evaluateK(counts = assays(sce_slingshot)$counts, sds = sds,
                      nGenes = 500, k = 3:10, parallel = TRUE, BPPARAM = BPPARAM)
k_values
# Plot the evaluation results to choose the best k
plot(k_values)

optimal_k <- which.min(k_values$ic$BIC)
# Having a hard time running evaluateK, it's slow and seems to crash, I'll just try progressing with nknots of 6 (the default)
# Fit GAMs for each gene along the pseudotime
sce_slingshot <- fitGAM(counts = assays(sce_slingshot)$counts, pseudotime = slingPseudotime(sds, na = FALSE), cellWeights = slingCurveWeights(sds), nknots = 6, parallel = TRUE, BPPARAM = BPPARAM)

# Extract the model results
gam_results <- rowData(sce_slingshot)$tradeSeq
```
