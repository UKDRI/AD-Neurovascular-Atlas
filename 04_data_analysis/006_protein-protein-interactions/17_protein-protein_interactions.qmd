---
title: Protein-protein interactions
execute:
  eval: true
---

```{r}
here::i_am(
  "04_data_analysis/006_protein-protein-interactions/17_protein-protein_interactions.qmd"
)
```

# Load packages

```{r}
source(here::here(
  "04_data_analysis/990_code_libraries/02_library-calls-for-renv.R"
))
tar_config_set(store = here::here("_targets"))
```

# Functions

Credit to Jimena for these functions, and indeed the basis for almost all the subsequent code.

```{r}
# Rescale data to range 0 to 1.
rescale01 <- function(numvect) {
  rango <- range(numvect)
  rescalado <- unlist(lapply(numvect, function(x) {
    if ((x - rango[1]) == 0) {
      0
    } else {
      (x - rango[1]) / (rango[2] - rango[1])
    }
  }))
  return(rescalado)
}

similar_gene_list <- function(gene_list, attr_matrix, rango = 100) {
  # attr_matrix must have at least a column with ensembl_gene_id and the rownames ordered by the attribute
  d_gl <- as.numeric(rownames(attr_matrix)[
    attr_matrix$ensembl_gene_id %in% gene_list
  ])
  # Random sample of genes (most with a similar attribute)
  rango2 <- setdiff(seq(-rango / 2, rango / 2, 1), 0)
  rnd_ind <- sample(rango2, size = length(gene_list), replace = TRUE)
  rnd_ind <- d_gl + rnd_ind
  # check the extremes (all should be within the range of D)
  if (length(which(rnd_ind < 1)) > 0) {
    rnd_ind[which(rnd_ind < 1)] <- sample(1:rango, 1)
  }
  if (length(which(rnd_ind > nrow(attr_matrix)))) {
    rnd_ind[which(rnd_ind > nrow(attr_matrix))] <- sample(
      nrow(attr_matrix):(nrow(attr_matrix) - rango),
      1
    )
  }
  # remove duplicates and replace with random genes (to keep gene number constant)
  if (length(rnd_ind) != length(unique(rnd_ind))) {
    rnd_ind <- unique(rnd_ind)
    rnd_ind <- c(
      rnd_ind,
      sample(
        setdiff(1:nrow(attr_matrix), rnd_ind),
        size = (length(gene_list) - length(rnd_ind))
      )
    )
  }
  rnd_smpl <- as.character(attr_matrix$ensembl_gene_id[rnd_ind])
  return(rnd_smpl)
}

# Divide genes according to an attribute #
attribute_2_list20bins <- function(
  attr_matrix,
  gene_col = 1,
  attr_col = 2,
  do_log = TRUE
) {
  if (do_log == TRUE) {
    at <- rescale01(log(attr_matrix[, attr_col] + 1))
  } else {
    at <- rescale01(attr_matrix[, attr_col])
  }
  bines <- seq(0, 1, .05)
  gps <- list()
  for (k in c(1:(length(bines) - 1))) {
    if (k == 1) {
      gps[[k]] <- as.character(union(
        attr_matrix[which(at <= bines[k]), gene_col],
        attr_matrix[which(at < bines[k + 1]), gene_col]
      ))
    } else {
      if (k == 20) {
        gps[[k]] <- as.character(intersect(
          attr_matrix[which(at >= bines[k]), gene_col],
          attr_matrix[which(at <= bines[k + 1]), gene_col]
        ))
      } else {
        gps[[k]] <- as.character(intersect(
          attr_matrix[which(at >= bines[k]), gene_col],
          attr_matrix[which(at < bines[k + 1]), gene_col]
        ))
      }
    }
  }
  return(gps)
}
```

# Read in data

```{r}
#| eval: true
# read data
# Get DESeq2 results
res <- readr::read_csv(here::here(
  "03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated_no-apoe.csv"
)) |>
  na.omit() |>
  dplyr::mutate(apoe_included = "no_apoe")
res <- readr::read_csv(here::here(
  "03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated_apoe.csv"
)) |>
  na.omit() |>
  dplyr::mutate(apoe_included = "apoe") |>
  rbind(res)
```

```{r}
x = res |>
  dplyr::filter(padj < 0.05)
table(x$celltype)
```

# Data prep

We need ensembl IDs for the PPI, so let's get them

```{r}
# Gene ensembl IDs
tar_load(gene_ids)
gene_ensembl_ids <- gene_ids
# remove duplicated gene IDs
unique_ids = gene_ensembl_ids[which(!duplicated(gene_ensembl_ids$gene)), ]

# Join dataframes
res <- left_join(res, unique_ids, by = "gene")
```

Filter to significant genes

```{r}
# Filter to sig genes
res_sig <- res |>
  dplyr::filter(padj < 0.05)

x = res_sig |>
  dplyr::filter(apoe_included == "no_apoe")
table(x$celltype)

# Assert that there are no NAs in ensembl IDs
assertthat::are_equal(nrow(dplyr::filter(res_sig, is.na(ensembl))), 0)

readr::write_csv(
  res_sig,
  here::here(
    "../../../gmbh_results_summaries/2024-04-52_ad_bbb/pseudobulk_sig_degs.csv"
  )
)
```

## MAGMA genes

Add in the sig MAGMA celltype sig gene list

```{r}
tar_load(translated_id)

magma_sig <-
  readr::read_tsv(here::here(
    "03_data/994_magma_inputs/sig_celltype_sig_genes.tsv"
  )) |>
  janitor::clean_names() |>
  dplyr::rename(entrezgene_id = gene) |>
  # Exclude the top one percents
  dplyr::filter(!percent == "top-one-percent") |>
  # Filter to level 2
  #dplyr::filter(celltype_level == "level2") |>
  dplyr::filter(padj < 0.05) |>
  dplyr::filter(grepl("Bellgenguez|EUROPEUKBB", group)) |>
  dplyr::left_join(translated_id, by = join_by(entrezgene_id))

assertthat::assert_that(
  sum(!magma_sig$entrezgene_id %in% translated_id$entrezgene_id) == 0
)
# get gene lists per celltype, gwas and percent
magma_list <- magma_sig |>
  dplyr::rename(ensembl = ensembl_gene_id) |>
  dplyr::mutate(
    case_or_control = if_else(grepl("_Case_", group), "case", "control")
  ) |>
  dplyr::group_by(
    gwas_background,
    input_gene_list,
    case_or_control,
    percent,
    celltype_level,
    set_name
  ) |>
  tidyr::nest() |>
  dplyr::rename(celltype = set_name) |>
  dplyr::mutate(celltype = paste0(celltype, "_sig-magma-sig-genes"))
```

I'd be nice to have a PPI for all the gene across all three celltypes of interest as well

```{r}
sig_celltypes_magma <- magma_sig |>
  dplyr::rename(ensembl = ensembl_gene_id) |>
  dplyr::filter(
    set_name %in%
      c("Microglia-activated", "Pericyte-2", "Perivascular-FB-KAZN2") &
      input_gene_list == "all_controls" &
      percent == "top-ten-percent" &
      gwas_background == "EUROPEUKBB_35k10k"
  )
sig_celltypes_magma <- tibble(
  celltype = "sig_magma_celltypes",
  data = list(sig_celltypes_magma)
)
```

There're a few genes that have overlapping expression in the celltypes, it'd be good to add those together and see what the interactions look like.

```{r}
x <- sig_celltypes_magma$data[[1]] |>
  dplyr::left_join(unique_ids, by = join_by(ensembl)) |>
  dplyr::group_by(set_name) |>
  dplyr::summarise(genes = gene)
extra_genes <- data.frame(
  set_name = c("Microglia-activated"),
  genes = c("ADAM17", "MARCHF7", "PLEKHA1", "MINK1")
)
mg <- x |>
  dplyr::filter(set_name == "Microglia-activated") |>
  rbind(extra_genes)
extra_genes <- data.frame(set_name = c("Pericyte-2"), genes = c("IQCK"))
p2 <- x |> dplyr::filter(set_name == "Pericyte-2") |> rbind(extra_genes)
extra_genes <- data.frame(
  set_name = c("Perivascular-FB-KAZN2"),
  genes = c("TRANK1", "EGFR")
)
all <- x |>
  dplyr::filter(set_name == "Perivascular-FB-KAZN2") |>
  rbind(extra_genes) |>
  rbind(mg) |>
  rbind(p2) |>
  dplyr::left_join(unique_ids, by = join_by(genes == gene)) |>
  dplyr::group_by(set_name) |>
  tidyr::nest() |>
  dplyr::mutate(
    celltype = case_when(
      set_name == "Microglia-activated" ~
        "Microglia-activated_sig_magma_extended",
      set_name == "Pericyte-2" ~ "Pericyte-2_sig_magma_extended",
      set_name == "Perivascular-FB-KAZN2" ~
        "Perivascular-FB-KAZN2_sig_magma_extended",
      .default = set_name
    ),
    input_gene_list = "all_controls",
    percent = "top-ten-percent",
    gwas_background = unique(sig_celltypes_magma$data[[1]]$gwas_background)
  ) |>
  dplyr::ungroup() |>
  dplyr::select(celltype, input_gene_list, gwas_background, percent, data)

assertthat::assert_that(
  map_lgl(all$data, ~ nrow(.x) == nrow(unique(.x))) |> sum() != 0
)
```

## Pseudotime

```{r}
pseudotime <- readr::read_csv(here(
  "03_data/990_processed_data/008_pseudotime",
  "top_pseudotime_condition_genes.csv"
))
head(pseudotime)

pseudotime_list <- pseudotime |>
  dplyr::rename(ensembl = ensembl_gene_id, celltype = lineage) |>
  dplyr::group_by(celltype) |>
  tidyr::nest()
```

## Merge data

```{r}
gene_list <- res_sig |>
  dplyr::group_by(celltype, apoe_included) |>
  tidyr::nest() |>
  dplyr::mutate(celltype = paste0(celltype, "_pseudobulk"))

# Merge pseudobulk and magma data
gene_list <- rbind(gene_list, magma_list) |>
  rbind(sig_celltypes_magma) |>
  rbind(all) |>
  rbind(pseudotime_list)
rm(all, mg, p2)
```

# PPI Test 1. Links within gene set

## Background gene list

```{r}
#| eval: false

# Note that it can take a while to download the gene lists, so I've set eval
# to false for this chunk.

# ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
#
# # Background population (protein coding genes)
# bg <- getBM(attributes = c("ensembl_gene_id", "gene_biotype"), mart = ensembl)
# bg <- bg[which(bg$gene_biotype == "protein_coding"), ]
# write.table(bg$ensembl_gene_id, here::here("03_data/993_protein_protein_interaction_data/full_background"),
#             sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# CDS length #
cds <- getBM(attributes = c("ensembl_gene_id", "cds_length"), mart = ensembl)
colnames(cds) <- c("ensembl_gene_id", "cds_length")
cds <- cds[-which(is.na(cds$cds_length) == TRUE), ]
cds <- cds[order(cds$ensembl_gene_id), ]
cds_max <- aggregate.data.frame(cds, by = list(cds$ensembl_gene_id), FUN = max)
cds_max <- cds_max[, c("ensembl_gene_id", "cds_length")]
cds_max <- cds_max[cds_max$ensembl_gene_id %in% bg$ensembl_gene_id, ]
write.table(
  cds_max,
  here::here(
    "03_data/993_protein_protein_interaction_data/EnsemblGeneID_MaxCDSlength.txt"
  ),
  sep = "\t",
  quote = FALSE,
  row.names = FALSE,
  col.names = FALSE
)
```

## Design

Let's do this with gene lists from the pseudobulk differential expression per celltype.

### Choose PPI network

We can either use the full PPI network, or just the known interactions

```{r}
use_known_interactions_only = TRUE
```

```{r}
# # # SELECT YOUR NETWORK FILE # # #
# Merged protein protein interactions.
if (use_known_interactions_only) {
  ppi_data <- read.table(
    here::here(
      "03_data/993_protein_protein_interaction_data/MergedPPI_2024Feb.txt"
    ),
    header = FALSE,
    as.is = TRUE
  )
} else {
  ppi_data <- read.table(
    here::here(
      "03_data/993_protein_protein_interaction_data/MergedPPI_2024Feb.txt"
    ),
    header = FALSE,
    as.is = TRUE
  )
}

# Create an igraph object from the dataframe
my_network <- graph_from_data_frame(ppi_data, directed = FALSE)
rm(ppi_data)
# Check the graph
summary(my_network)

# To include merged PPI datasets with only physical interactions from STRING
# use 2023May_MergedPPI_PIO_STRING.txt instead

edge_attr(my_network, "weight", index = E(my_network)) <- 1
```

## Background list

Could want to run against multiple backgrounds in future, but I'll just use the full list of gene from the pseudobulk across all celltypes.

```{r}
# For the background I can use the full gene list including non-significant genes
background_population <- unique(res$ensembl)
background_population <- list("full_background" = background_population)
```

```{r}
# # #  INPUT gene attributes  # # #
# Gene length / max CDS length
gene_length <- read.table(
  here::here(
    "03_data/993_protein_protein_interaction_data/EnsemblGeneID_MaxCDSlength.txt"
  ),
  sep = "\t",
  header = FALSE,
  stringsAsFactors = FALSE
)
colnames(gene_length) <- c("ensembl_gene_id", "gene_length")


# # # SETUP NUMBER OF RANDOM SAMPLES to create your NULL # # #
m <- 10000

# # # Set to "D" to take into account degree,
# # # "GL" to taken into account Gene length,
# # # or "B" to take into account both degree and Gene length
gene_attribute <- "B"

# # # CHANGE the name of your OUTPUT FILE that will contain your test against NULL # # #
output_file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "PPI_Test1"
  )

# Min number of genes for a cluster
min_cluster_size <- 5

# Output Louvain clusters
output_file2 <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "PPI_Test1-Louvain_"
  )
```

```{r}
# Add test type to the output file name
if (gene_attribute == "D") {
  output_file <- paste(output_file, "MatchDegree", sep = "_")
} else {
  if (gene_attribute == "GL") {
    output_file <- paste(output_file, "MatchGenelength", sep = "_")
  } else {
    if (gene_attribute == "B") {
      output_file <- paste(output_file, "MatchDegreeAndGenelength", sep = "_")
    }
  }
}

if (use_known_interactions_only) {
  output_file <- paste(output_file, "known-interactions", sep = "_")
  output_file2 <- paste(output_file2, "known-interactions", sep = "_")
}

# Pull out the ensembl list for each celltype
my_gene_list <- map(gene_list$data, ~ dplyr::pull(.x, ensembl) |> unique()) |>
  set_names(paste(
    gene_list$celltype,
    gene_list$apoe_included,
    gene_list$gwas_background,
    gene_list$input_gene_list,
    gene_list$percent,
    gene_list$celltype_level,
    gene_list$case_or_control,
    sep = "_"
  ))
names(my_gene_list) <- str_replace(
  names(my_gene_list),
  "_NA_NA_NA_NA_NA",
  ""
) |>
  str_replace("_NA_NA", "") |>
  str_replace("_NA", "")
```

## Gene lists for analysis

```{r}
process_network <- function(background) {
  # Reduce my network to background population of genes tested #
  Gbg <- vertex_attr(my_network)$name
  BG <- intersect(background, intersect(Gbg, gene_length$ensembl_gene_id))
  my_network <- induced_subgraph(graph = my_network, vids = BG)

  # Create tables with the GENE attributes provided for the background population found in my network #
  # Calculate and order genes according to their degree in my network #
  D <- igraph::degree(my_network, mode = "all")
  D <- data.frame(ensembl_gene_id = names(D), degree = D)
  D <- D[order(D$degree, decreasing = TRUE), ]
  rownames(D) <- 1:nrow(D)

  # Order genes by Gene length #
  gene_length <- gene_length[gene_length$ensembl_gene_id %in% BG, ]
  gene_length <- gene_length[
    order(gene_length$gene_length, decreasing = TRUE),
  ]
  rownames(gene_length) <- 1:nrow(gene_length)

  # Combined score Degree and Gene length
  B <- merge(D, gene_length, by = "ensembl_gene_id")
  B <- data.frame(
    B,
    scaled_degree = rescale01(B$degree),
    scaled_gene_length = rescale01(B$gene_length),
    score = rescale01(B$degree) + rescale01(B$gene_length)
  )
  B <- B[order(B$score, decreasing = TRUE), ]
  rownames(B) <- 1:nrow(gene_length)

  # Report numbers
  print(paste0("Background population: ", length(background), " genes"))
  print(paste0("Genes in the network: ", length(Gbg), " genes"))
  print(
    paste0(
      "Background population contained in the network and used for analysis: ",
      length(BG),
      " genes"
    )
  )

  x <- map(my_gene_list, ~ length(intersect(.x, BG)))
  x <- map2(
    x,
    names(my_gene_list),
    ~ print(paste0(
      "Genes of interest contained in the network and used for analysis: ",
      .x,
      " for celltype ",
      .y
    ))
  )

  return(list("BG" = BG, "network" = my_network, "D" = D, "B" = B))
}

res <- map(background_population, process_network)
```

```{r}
x <- map2(
  names(my_gene_list),
  my_gene_list,
  ~ print(paste0("Genes of interest: ", length(.y), " for celltype ", .x))
)
rm(x)
```

## Subnetwork plot

+ Interaction network of the genes of interest.

```{r}
rm(background_population)

# Function to intersect each cell type gene list with a single background list
intersect_with_background <- function(background_genes, cell_type_gene_list) {
  map(cell_type_gene_list, ~ intersect(.x, y = background_genes))
}
my_gene_list <- map(res, ~ intersect_with_background(.x$BG, my_gene_list))
```

```{r}
# Define subnetwork
create_subnetwork <- function(network, gene_lists) {
  map(gene_lists, ~ induced_subgraph(graph = network, vids = .x))
}
my_subgraph <- map2(res, my_gene_list, ~ create_subnetwork(.x$network, .y))
```

I'll disable the code that generates the plots as they also can be plotted with their clusters later.

```{r}
#| eval: false
# Plot subnetwork
map(
  my_subgraph,
  ~ map2(
    .x,
    names(.x),
    ~ plot(
      .x,
      vertex.size = 3,
      vertex.color = "darkslateblue",
      vertex.frame.color = "darkslateblue",
      edge.color = "grey",
      rescale = TRUE,
      vertex.label = NA,
      main = paste0("Celltype: ", .y)
    )
  )
)
```

## Test for number of interactions

```{r}
perform_permutation <- function(
  gene_list,
  gene_list_name,
  my_network,
  BG,
  gene_attribute,
  m,
  num_cores = detectCores() - 1
) {
  print(paste0("Processing ", gene_list_name))

  # Gene population of interest
  gene_list_A <- intersect(gene_list, BG)

  # Sum of the edges within gene list A
  mynet_gl <- induced_subgraph(my_network, vids = gene_list_A)
  w_mynet_gl <- edge.attributes(mynet_gl)$weight
  o <- sum(w_mynet_gl)

  # Sum of the edges from within a random gene list size A
  # Use mclapply to parallelize the replicate function
  e <- mclapply(
    1:m,
    function(i) {
      rnd_smpl <- similar_gene_list(
        gene_list = gene_list_A,
        attr_matrix = gene_attribute,
        rango = 100
      )
      rnd_mynet_gl <- induced_subgraph(my_network, vids = rnd_smpl)
      rnd_w_mynet_gl <- edge.attributes(rnd_mynet_gl)$weight
      sum(rnd_w_mynet_gl)
    },
    mc.cores = num_cores
  )
  # Convert the list to a vector
  e <- unlist(e)

  p <- length(which(e >= o)) / m

  # Write to dataframe
  df <- data.frame(
    "gene_list" = gene_list_name,
    "o" = o,
    "e" = mean(e),
    "sem" = sd(e),
    "p" = p
  )
  return(df)

  print(paste0("Finished processing ", gene_list_name))
}

results <-
  map2(
    my_gene_list$full_background,
    names(my_gene_list$full_background),
    ~ perform_permutation(
      .x,
      .y,
      my_network = res$full_background$network,
      BG = res$full_background$BG,
      gene_attribute = res$full_background[[gene_attribute]],
      m = m
    )
  ) |>
  list_rbind()
```

### Results

```{r}
# Make group column for pseudobulk/lineage/magma genes
results <- results |>
  dplyr::mutate(
    input_type = case_when(
      grepl("_pseudobulk", gene_list) ~ "pseudobulk",
      gene_list == "1" | gene_list == "2" | gene_list == "overall" ~ "lineage",
      .default = "magma"
    )
  )
results <- results |>
  dplyr::mutate(
    apoe = case_when(
      grepl("_no_apoe", gene_list) ~ "no_apoe",
      input_type == "pseudobulk" ~ "apoe",
      .default = NA
    )
  ) |>
  dplyr::mutate(
    case_control = case_when(
      grepl("_case", gene_list) & input_type == "magma" ~ "case",
      !grepl("_case", gene_list) & input_type == "magma" ~ "control",
      .default = NA
    )
  )
# Add adjusted pvalues
results$pval <- ifelse(results$p == 0, 1e-8, results$p)
results <- results |>
  dplyr::group_by(input_type, case_control, apoe) |>
  dplyr::mutate(padj = p.adjust(pval, method = "bonferroni"))

results <- results |>
  dplyr::mutate(
    gene_list = if_else(
      gene_list %in% c("1", "2", "overall"),
      paste0("lineage_", gene_list),
      gene_list
    )
  )

readr::write_tsv(results, paste0(output_file, ".tsv"))
#results <- readr::read_tsv(paste0(output_file, ".tsv"))
sig_celltypes <- results |>
  dplyr::filter(padj < 0.05)
# Table with results of test
results |>
  dplyr::filter(padj < 0.05) |>
  DT::datatable(
    caption = "Test if the number of interactions is higher than expected by chance",
    rownames = FALSE
  ) |>
  formatRound(columns = c("e", "sem"), digits = c(2))
```

+ **o** observed number of interactions.

+ **e** expected number of interactions based on `{r} m` randomizations.

+ **sem** standard error of the mean based on `{r} m` randomizations.

+ **p** estimated p value based on `{r} m` randomizations.

+ **Note** If a weighted network is provided then it is a test for the sum of the edge's weights.

## Louvain clustering

- run through funciton code and make sure it's working

```{r}
perform_louvain_clustering <- function(
  graph,
  min_cluster_size = 1,
  color_palette = "Dark2",
  default_color = "grey",
  label
) {
  # Perform Louvain clustering
  louvain <- cluster_louvain(graph)

  # Get module membership
  module_membership <- membership(louvain)
  # Get the sizes of each module
  module_sizes <- sizes(louvain)
  # Filter out small clusters
  large_modules <- names(module_sizes[module_sizes >= min_cluster_size])

  # Create a filtered membership vector
  filtered_membership <- ifelse(
    module_membership %in% large_modules,
    module_membership,
    0
  )
  # Get the number of remaining modules
  num_modules <- length(unique(filtered_membership[filtered_membership != 0]))

  # Generate distinct colors for each module
  colors <- brewer.pal(n = num_modules, name = color_palette)

  # Create a color vector with the default color for small clusters
  module_colors <- rep(default_color, length(filtered_membership))
  # Assign colors to large modules
  module_colors[
    filtered_membership != 0
  ] <- colors[as.integer(factor(filtered_membership[filtered_membership != 0]))]

  # Get gene names
  gene_names <- V(graph)$name

  # Create dataframe
  result <- data.frame(
    gene = gene_names,
    module = filtered_membership,
    module_color = module_colors,
    label = label
  )

  return(result)
}

# remove any subgraphs that are empty
subgraphs <- my_subgraph$full_background[map_lgl(
  my_subgraph$full_background,
  ~ length(.x) > 0
)]


names(subgraphs) <- if_else(
  names(subgraphs) %in% c("1", "2", "overall"),
  paste0("lineage_", names(subgraphs)),
  names(subgraphs)
)

module_assignment <-
  map2(
    subgraphs,
    names(subgraphs),
    ~ perform_louvain_clustering(.x, min_cluster_size = 3, label = .y)
  )
```

```{r}
ddd <- load(here::here(
  "04_data_analysis/994_scripts_from_emeka/table_gene_full.Rdata"
))
info_annot_gene <- read.table(
  here::here("04_data_analysis/994_scripts_from_emeka/NCBI37.3.gene.loc"),
  h = F,
  sep = "\t"
)
colnames(info_annot_gene) <- c(
  'entrezid',
  'chr',
  'start',
  'stop',
  'strand',
  "hgnc_symbol"
)
table_gene_du_id <- merge(table_gene_du, info_annot_gene, by = c("hgnc_symbol"))
colnames(table_gene_du_id)[2] <- "gene"

module_assignment <- map(
  module_assignment,
  dplyr::left_join,
  table_gene_du_id,
  by = "gene"
)
module_assignment <- map(
  module_assignment,
  ~ .x |>
    dplyr::left_join(gene_ids, by = join_by(gene == ensembl)) |>
    dplyr::mutate(
      gene_symbol = if_else(is.na(hgnc_symbol), gene.y, hgnc_symbol)
    )
)
```

```{r}
modules <- list_rbind(module_assignment) |>
  dplyr::filter(label %in% sig_celltypes$gene_list) |>
  dplyr::filter(!grepl("low-feature-cell", label))

ad_all_controls <- list(
  "Microglia-activated_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2_control" = c(
    "1" = "Lymphocyte activation",
    "2" = "Amyloid",
    "3" = "Dephosphorylation"
  ),
  "Pericyte-2_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2_control" = c(
    "1" = "Amyloid",
    "3" = "Supramolecular fibre organisation"
  ),
  "Perivascular-FB-KAZN2_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2_control" = c(
    "2" = "Amyloid",
    "4" = "Viral process",
    "1" = "Axon terminus"
  ),
  "Microglia-activated_sig_magma_extended_EUROPEUKBB_35k10k_all_controls_top-ten-percent" = c(
    "1" = "Amyloid",
    "2" = "Cell adhesion",
    "3" = "Lymphocyte activation"
  ),
  "Perivascular-FB-KAZN2_sig_magma_extended_EUROPEUKBB_35k10k_all_controls_top-ten-percent" = c(
    "1" = "Viral process",
    "2" = "Actin filament",
    "3" = "Amyloid"
  ),
  "Pericyte-2_sig_magma_extended_EUROPEUKBB_35k10k_all_controls_top-ten-percent" = c(
    "1" = "Amyloid",
    "3" = "Supramolecular fibre organisation"
  )
)

# function to make df per vector
make_ppi_df <- function(
  module_labels,
  celltype,
  gwas,
  fraction,
  ontology = NA
) {
  df <-
    tibble(
      module_label = module_labels,
      module = as.numeric(names(module_labels)),
      label = celltype,
      gwas = gwas,
      fraction = fraction,
      ontology = ontology
    )
  return(df)
}

module_labels <-
  map2(
    ad_all_controls,
    names(ad_all_controls),
    make_ppi_df,
    "Bellenguez",
    "all_controls",
    "all"
  ) |>
  list_rbind()

modules <- modules |>
  left_join(module_labels, by = join_by(label, module))

modules$label <- str_replace_all(
  modules$label,
  "Perivascular-FB-KAZN2",
  "Perivascular-FB-2"
)
```

```{r}
plot_network_ggraph <- function(
  group,
  module_df,
  overall_network = my_network,
  network_layout = "auto"
) {
  require(ggraph)
  require(tidygraph)

  df <- module_df |>
    dplyr::filter(label == group) |>
    dplyr::group_by(module) |>
    dplyr::mutate(genes_in_module = n()) |>
    dplyr::ungroup() |>
    dplyr::filter(genes_in_module > 1) |>
    # If there's no module labels just replace with module numbers
    dplyr::mutate(module_label = if_else(is.na(module_label), NA, module_label))

  # Add filter to isolated nodes
  if (grepl("Perivascular-FB-KAZN2", group)) {
    df <- df |>
      dplyr::filter(!hgnc_symbol %in% c("JAZF1", "ZNF652"))
  }

  subgraph <- induced_subgraph(graph = overall_network, vids = df$gene)
  # Create a named vector for easy lookup
  ensembl_to_symbol <- setNames(df$hgnc_symbol, df$gene)

  # Add gene symbols to the graph vertices
  V(subgraph)$hgnc_symbol <- ensembl_to_symbol[V(subgraph)$name]
  # Convert igraph to tidygraph
  tbl_graph <- as_tbl_graph(subgraph)

  # Add module information to the graph
  tbl_graph <- tbl_graph |>
    activate(nodes) |>
    mutate(
      module_number = df$module,
      module_color = df$module_color,
      module_label = df$module_label,
      group = df$label,
      gene_name = df$gene_symbol
    ) |>
    dplyr::filter(centrality_degree() > 1)

  # Plot using ggraph
  p <- ggraph(tbl_graph, layout = network_layout) + # 'fr' layout for Fruchterman-Reingold
    geom_edge_link(
      aes(edge_alpha = 0.5),
      edge_colour = "grey",
      edge_linetype = "solid",
      show.legend = FALSE
    ) +
    geom_node_point(aes(color = module_label), size = 1.2, alpha = 0.7) +
    geom_node_text(aes(label = gene_name), repel = TRUE, size = 1.8) +
    scale_color_manual(values = setNames(df$module_color, df$module_label)) +
    theme_void() +
    labs(color = "Module Function", title = unique(df$celltype)) +
    theme(
      legend.position = "top",
      plot.title = element_text(size = 5, hjust = 0.5, face = "bold"),
      legend.text = element_text(size = 4),
      legend.title = element_text(size = 4, hjust = 0.5, vjust = -7),
      legend.spacing.x = unit(0.1, "mm"),
      legend.spacing.y = unit(0.1, "mm"),
      legend.key.width = unit(0.8, "mm"),
      legend.key.spacing.x = unit(1, "mm"),
      legend.title.position = "top"
    ) +

    if (length(unique(df$label)) > 1) {
      p <- p + facet_wrap(~group) # Facet by group
    }

  return(p)
}

# Define the function to subset a single string up to the last underscore
subset_until_last_underscore <- function(input_string) {
  # Find the position of the last underscore
  last_underscore_position <- str_locate_all(input_string, "_")[[1]][, 1] |>
    max()

  # Subset the string up to the last underscore
  if (!is.na(last_underscore_position)) {
    return(str_sub(input_string, 1, last_underscore_position - 1))
  } else {
    return(input_string)
  }
}

# Apply the function to each element of the vector
modules$celltype_label_full <- sapply(
  modules$label,
  subset_until_last_underscore
)
# Extract substring up to the first underscore
modules$celltype <- str_extract(modules$label, "^[^_]*")

# I want to make sure the Amyloid groups get the same colour label
# Function to assign colors
assign_amyloid_color <- function(df, amyloid_color) {
  df <- df |>
    dplyr::group_by(label) |>
    dplyr::mutate(
      # Check if "Amyloid" is in the group
      amyloid_present = any(module_label == "Amyloid"),
      # Get the original color of "Amyloid" if present
      original_amyloid_color = ifelse(
        module_label == "Amyloid",
        module_color,
        NA
      ),
      original_amyloid_color = dplyr::first(na.omit(original_amyloid_color))
    ) |>
    dplyr::ungroup() |>
    dplyr::mutate(
      # Assign the desired color to "Amyloid"
      module_color = case_when(
        module_label == "Amyloid" ~ amyloid_color,
        .default = module_color
      )
    ) |>
    # Swap the original "Amyloid" color with the new "Amyloid" color in other labels
    dplyr::mutate(
      module_color = case_when(
        module_color == amyloid_color & module_label != "Amyloid" ~
          original_amyloid_color,
        .default = module_color
      )
    ) |>
    dplyr::select(-amyloid_present, -original_amyloid_color)

  return(df)
}
modules <- assign_amyloid_color(modules, "#D95F02")

plots <- map(
  unique(modules$label),
  plot_network_ggraph,
  modules,
  network_layout = "fr"
) |>
  set_names(unique(modules$label))

qs::qsave(
  plots,
  here::here(
    "05_figures/990_shared_figures/003_final_figures/001_data_for_plots/ppi_network_plots.qs"
  )
)
map2(
  plots,
  unique(modules$label),
  ~ ggsave(
    here::here(
      "05_figures/990_shared_figures/002_pseudobulk/ppi_sig_networks",
      paste0(.y, ".png")
    ),
    plot = .x,
    height = 12,
    width = 14
  )
)
```

## Joint plots

Want to try making a joint plot for the three celltypes of interest

Need to make a table that has one row per gene and a join factor of celltype and one for module function
Also should make a column to denote if a gene is unique in 2 or three celltypes.
Make a master amyloid column as well

```{r}
celltype_abbrev_df <- readr::read_tsv(here::here(
  "05_figures/990_shared_figures/003_final_figures/001_data_for_plots/celltype_abbreviations.tsv"
))
```

```{r}
module_sub <- modules |>
  dplyr::filter(grepl("all_controls_top-ten-percent", label)) |>
  dplyr::filter(!grepl("_extended_", label)) |>
  dplyr::left_join(celltype_abbrev_df, by = join_by(celltype)) |>
  dplyr::mutate(
    celltypes_abbrev = if_else(
      is.na(celltypes_abbrev),
      celltype,
      celltypes_abbrev
    ),
    case_control = if_else(grepl("_case", label), "case", "control"),
    celltype_level = if_else(grepl("level1", label), "level1", "level2")
  )

# Summarise the presence of each gene in the case_control groups
gene_summary <- module_sub |>
  summarize(
    in_case = any(case_control == "case"),
    in_control = any(case_control == "control"),
    .by = c(celltypes_abbrev, celltype_level, gene_symbol)
  )

# Join the summary back to the original dataframe
module_sub <- module_sub |>
  left_join(
    gene_summary,
    by = join_by(celltypes_abbrev, celltype_level, gene_symbol)
  ) |>
  dplyr::mutate(
    unique_genes_per_celltype = case_when(
      in_case & !in_control ~ "case_only",
      !in_case & in_control ~ "control_only",
      in_case & in_control ~ "both",
      .default = NA
    )
  ) |>
  dplyr::select(-in_case, -in_control)

# Do the same for overall genes
gene_summary <- module_sub |>
  summarize(
    in_case = any(case_control == "case"),
    in_control = any(case_control == "control"),
    .by = c(gene_symbol)
  )

module_sub <- module_sub |>
  left_join(gene_summary, by = join_by(gene_symbol)) |>
  dplyr::mutate(
    unique_genes_overall = case_when(
      in_case & !in_control ~ "case_only",
      !in_case & in_control ~ "control_only",
      in_case & in_control ~ "both",
      .default = NA
    )
  ) |>
  dplyr::select(-in_case, -in_control)

table(module_sub$unique_genes_per_celltype)

df <- module_sub |>
  dplyr::filter(celltypes_abbrev == "Microglia-A")

overall_network = my_network
network_layout = "auto"


set.seed(1234)
subgraph <- induced_subgraph(graph = overall_network, vids = df$gene)
all_genes <- unique(df$hgnc_symbol)
# Create a named vector for easy lookup
ensembl_to_symbol <- setNames(df$hgnc_symbol, df$gene)

# Add gene symbols to the graph vertices
V(subgraph)$hgnc_symbol <- ensembl_to_symbol[V(subgraph)$name]
# Convert igraph to tidygraph
tbl_graph <- as_tbl_graph(subgraph)

microglia_risk_genes <- df |>
  dplyr::select(
    gene,
    gene_symbol,
    unique_genes_per_celltype,
    celltypes_abbrev
  ) |>
  dplyr::distinct() |>
  pivot_wider(
    names_from = unique_genes_per_celltype,
    values_from = unique_genes_per_celltype
  ) |>
  unite("case_control", case_only:control_only, na.rm = TRUE)

# Add module information to the graph
tbl_graph <- tbl_graph |>
  activate(nodes) |>
  mutate(
    group = microglia_risk_genes$case_control,
    gene_name = microglia_risk_genes$gene_symbol
  )

# Plot using ggraph
p <- ggraph(tbl_graph, layout = network_layout) + # 'fr' layout for Fruchterman-Reingold
  geom_edge_link(
    aes(edge_alpha = 0.5),
    edge_colour = "grey",
    edge_linetype = "solid",
    show.legend = FALSE
  ) +
  geom_node_point(aes(color = group), size = 5) +
  geom_node_text(aes(label = gene_name), repel = TRUE, size = 5) +
  theme_void() +
  theme(legend.position = "right") +
  guides(color = guide_legend(override.aes = list(size = 5))) +
  labs(color = "case_control", title = microglia_risk_genes$celltypes_abbrev)

p
ggsave(
  here::here(
    "05_figures/990_shared_figures/001_magma/ppi_sig_networks",
    "microglia-a_case-control.png"
  ),
  height = 12,
  width = 14
)
```

```{r}
df <- module_sub |>
  dplyr::filter(
    celltype_level == "level2" & grepl("Pericyte", celltypes_abbrev)
  )

gene_summary <- df |>
  summarize(
    in_case = any(case_control == "case"),
    in_control = any(case_control == "control"),
    .by = c(gene_symbol)
  )

# Join the summary back to the original dataframe
df <- df |>
  left_join(gene_summary, by = join_by(gene_symbol)) |>
  dplyr::mutate(
    unique_genes_per_celltype = case_when(
      in_case & !in_control ~ "case_only",
      !in_case & in_control ~ "control_only",
      in_case & in_control ~ "both",
      .default = NA
    )
  ) |>
  dplyr::select(-in_case, -in_control)

overall_network = my_network
network_layout = "auto"

set.seed(1234)
subgraph <- induced_subgraph(graph = overall_network, vids = df$gene)
all_genes <- unique(df$hgnc_symbol)
# Create a named vector for easy lookup
ensembl_to_symbol <- setNames(df$hgnc_symbol, df$gene)

# Add gene symbols to the graph vertices
V(subgraph)$hgnc_symbol <- ensembl_to_symbol[V(subgraph)$name]
# Convert igraph to tidygraph
tbl_graph <- as_tbl_graph(subgraph)

df <- df |>
  dplyr::select(gene, gene_symbol, unique_genes_per_celltype) |>
  dplyr::distinct() |>
  pivot_wider(
    names_from = unique_genes_per_celltype,
    values_from = unique_genes_per_celltype
  ) |>
  unite("case_control", both:control_only, na.rm = TRUE)

# Add module information to the graph
tbl_graph <- tbl_graph |>
  activate(nodes) |>
  mutate(group = df$case_control, gene_name = df$gene_symbol)

# Plot using ggraph
p <- ggraph(tbl_graph, layout = network_layout) + # 'fr' layout for Fruchterman-Reingold
  geom_edge_link(
    aes(edge_alpha = 0.5),
    edge_colour = "grey",
    edge_linetype = "solid",
    show.legend = FALSE
  ) +
  geom_node_point(aes(color = group), size = 5) +
  geom_node_text(aes(label = gene_name), repel = TRUE, size = 5) +
  theme_void() +
  theme(legend.position = "right") +
  guides(color = guide_legend(override.aes = list(size = 5))) +
  labs(color = "case_control", title = "Level 2 periyte overlaps")

p
ggsave(
  here::here(
    "05_figures/990_shared_figures/001_magma/ppi_sig_networks",
    "pericyte_case-control.png"
  ),
  height = 12,
  width = 14
)
```

### MAGMA for case vs control risk genes

```{r}
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/risk_case-control_go_terms.qs"
  )

gene_list <- microglia_risk_genes |>
  dplyr::group_by(case_control) |>
  tidyr::nest()

if (!file.exists(file)) {
  plan("multisession", workers = parallel::detectCores() - 1)
  result_list_bp <- future_map(
    gene_list$data,
    ~ enrichGO(
      gene = .x$gene,
      OrgDb = org.Hs.eg.db,
      keyType = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont = "BP",
      universe = gene_ensembl_ids$ensembl,
      pAdjustMethod = "BH",
      qvalueCutoff = 0.05,
      readable = TRUE
    ),
    .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$case_control, "_BP"))
  result_list_cc <- future_map(
    gene_list$data,
    ~ enrichGO(
      gene = .x$gene,
      OrgDb = org.Hs.eg.db,
      keyType = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont = "CC",
      universe = gene_ensembl_ids$ensembl,
      pAdjustMethod = "BH",
      qvalueCutoff = 0.05,
      readable = TRUE
    ),
    .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$case_control, "_CC"))
  result_list_mf <- future_map(
    gene_list$data,
    ~ enrichGO(
      gene = .x$gene,
      OrgDb = org.Hs.eg.db,
      keyType = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont = "MF",
      universe = gene_ensembl_ids$ensembl,
      pAdjustMethod = "BH",
      qvalueCutoff = 0.05,
      readable = TRUE
    ),
    .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$case_control, "_MF"))
  result_list <- c(result_list_bp, result_list_mf, result_list_cc)
  rm(result_list_bp, result_list_cc, result_list_mf)

  qs::qsave(result_list, file)
} else {
  result_list <- qs::qread(file)
}


# Remove any NULL entries
result_list <- result_list[!sapply(result_list, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(result_list, is.null)) == 0)
# Filter the list to keep only elements where the 'result' slot has rows
result_list <- result_list[sapply(result_list, function(x) nrow(x@result) > 0)]
# Filter to only those wtih sig enrichments
result_list <- result_list[sapply(result_list, function(x) {
  sum(x@result$p.adjust < 0.05) > 0
})]
```

```{r}
# Get semantic similarity of terms
result_list <- map(result_list, pairwise_termsim)

# Define a safe version of your treeplot function that returns NULL on error
safe_treeplot <- possibly(treeplot, otherwise = NULL)
# Use map with the safe version of the function
plan("multisession", workers = parallel::detectCores() - 1)
treeplots <- future_map(result_list, safe_treeplot)

# Remove any NULL entries
treeplots <- treeplots[!sapply(treeplots, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(treeplots, is.null)) == 0)
# Replace those with no treeplot with dotplots
no_treeplot <- names(result_list)[!names(result_list) %in% names(treeplots)]
dotplots <- map(result_list[no_treeplot], dotplot)
assertthat::see_if(sum(map_lgl(dotplots, is.null)) == 0)
treeplots <- c(treeplots, dotplots)

treeplots <- map2(treeplots, names(treeplots), ~ .x + ggtitle(.y))
treeplots$case_only_BP + treeplots$case_only_CC + treeplots$case_only_MF
treeplots$both_BP + treeplots$both_CC + treeplots$both_CC
treeplots$control_only_MF + treeplots$control_only_CC

treeplot_groups <- names(treeplots) |> str_sub(1, -4) |> unique()

plots <- map(
  treeplot_groups,
  ~ {
    plots <- treeplots[grepl(.x, names(treeplots))]
    plot <- purrr::reduce(plots, `+`)
    return(plot)
  }
) |>
  set_names(treeplot_groups)

walk2(
  plots,
  names(plots),
  ~ ggsave(
    filename = here::here(
      "05_figures/990_shared_figures/001_magma/",
      paste0(.y, "risk_genes_go.png")
    ),
    plot = .x,
    width = 24,
    height = 14
  )
)
```

## For each module

```{r}
# Plot clustering
map2(
  subgraphs,
  module_assignment,
  ~ plot(
    .x,
    vertex.size = 3,
    vertex.color = as.character(.y$module_color),
    vertex.frame.color = .y$module_color,
    edge.color = "grey",
    rescale = TRUE,
    vertex.label = NA,
    main = paste0("Celltype: ", .y$label[1])
  )
)

# Save clustering as file
readr::write_delim(list_rbind(module_assignment), file = output_file2)
#modules <- readr::read_delim(file = output_file2)
```

## Module assignment

Having assigned the genes to modules the next thing to do is choose which celltypes to take forward to assign functions via GO pathways to.

```{r}
# Get modules assignment
modules <- list_rbind(module_assignment)

# Get number of genes per celltypes
gene_num <- map_dbl(my_gene_list$full_background, length)
# Check the gene numbers per celltypes of interest
gene_num <- gene_num[names(gene_num) %in% sig_celltypes$gene_list]
gene_num
# Get the celltypes with fewer than 30 genes
celltypes_with_few_genes <- names(gene_num)[gene_num < 30]
```

For cases where the number of genes is small, there isn't a need to use the clusters, though there isn't a rule of thumb for a cutoff for this.
Given most of the celltypes in this case have more than 30 genes, I'll run those that aren't through GO as they are, but the others I'll do per Louvain cluster.

```{r}
modules_sig <- modules |>
  # Filiter to sig celltypes
  dplyr::filter(label %in% sig_celltypes$gene_list) |>
  # Update modules for celltypes with low number of genes to all be the same
  dplyr::mutate(
    module_updated = case_when(
      label %in% celltypes_with_few_genes ~ 1,
      .default = module
    )
  ) |>
  dplyr::select(!c(hgnc_symbol, gene.y, entrezid))

tar_load(translated_id)

modules_sig <- modules_sig |>
  dplyr::left_join(translated_id, by = join_by(gene == ensembl_gene_id)) |>
  dplyr::distinct(entrezgene_id, .keep_all = TRUE)
```

```{r}
gene_list <- modules_sig |>
  group_by(label, module) |>
  tidyr::nest()
```

### GO enrichment

```{r}
# Filter out any NULL entries if there were conversion errors
gene_list_entrez <- map(
  gene_list$data,
  ~ .x |>
    # remove any missing data
    dplyr::filter(!is.na(entrezgene_id)) |>
    dplyr::pull(entrezgene_id)
)

entrez_background <- gene_ensembl_ids |>
  dplyr::left_join(translated_id, by = join_by(ensembl == ensembl_gene_id))
names(gene_list_entrez) <- paste0(gene_list$label, "_module", gene_list$module)

# Get tradeseq subset background
sce_subset <- qs::qread(here(
  "03_data/990_processed_data/008_pseudotime/slingshot_tradeseq_3k_case_and_control.qs"
))

tradeseq_ids <- rownames(sce_subset)

assertthat::assert_that(
  sum(!(tradeseq_ids %in% translated_id$ensembl_gene_id)) == 0
)

tradeseq_ids <- translated_id |>
  dplyr::filter(ensembl_gene_id %in% tradeseq_ids)

head(gene_list)

gene_list <- gene_list |>
  dplyr::mutate(
    background = if_else(
      grepl("lineage_", label),
      list(tradeseq_ids$ensembl_gene_id),
      list(gene_ensembl_ids$ensembl)
    )
  )

gene_list_entrez_sub <-
  gene_list_entrez[sapply(gene_list_entrez, function(x) {
    length(x) > 1
  })]

# Save file - it takes a while to compute
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/module_go_terms.rds"
  )
if (use_known_interactions_only) {
  file <-
    here::here(
      "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/module_go_terms_multicore_known_interactions.qs"
    )
} else {
  file <-
    here::here(
      "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/module_go_terms_multicore.qs"
    )
}


if (!file.exists(file)) {
  plan("multisession", workers = parallel::detectCores() - 1)
  result_list_bp <- future_map2(
    gene_list$data,
    gene_list$background,
    ~ enrichGO(
      gene = .x$gene,
      OrgDb = org.Hs.eg.db,
      keyType = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont = "BP",
      universe = .y,
      pAdjustMethod = "BH",
      qvalueCutoff = 0.05,
      readable = TRUE
    ),
    .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$label, "_module", gene_list$module, "_BP"))
  result_list_cc <- future_map2(
    gene_list$data,
    gene_list$background,
    ~ enrichGO(
      gene = .x$gene,
      OrgDb = org.Hs.eg.db,
      keyType = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont = "CC",
      universe = .y,
      pAdjustMethod = "BH",
      qvalueCutoff = 0.05,
      readable = TRUE
    ),
    .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$label, "_module", gene_list$module, "_CC"))
  result_list_mf <- future_map2(
    gene_list$data,
    gene_list$background,
    ~ enrichGO(
      gene = .x$gene,
      OrgDb = org.Hs.eg.db,
      keyType = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont = "MF",
      universe = .y,
      pAdjustMethod = "BH",
      qvalueCutoff = 0.05,
      readable = TRUE
    ),
    .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$label, "_module", gene_list$module, "_MF"))
  result_list <- c(result_list_bp, result_list_mf, result_list_cc)
  rm(result_list_bp, result_list_cc, result_list_mf)

  qs::qsave(result_list, file)
} else {
  result_list <- qs::qread(file)
}


# Remove any NULL entries
result_list <- result_list[!sapply(result_list, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(result_list, is.null)) == 0)
# Filter the list to keep only elements where the 'result' slot has rows
result_list <- result_list[sapply(result_list, function(x) nrow(x@result) > 0)]
# Filter to only those wtih sig enrichments
result_list <- result_list[sapply(result_list, function(x) {
  sum(x@result$p.adjust < 0.05) > 0
})]
```

### Save for MAGMA

I want to run these modules through MAGMA later so I'll save the gene lists whilst I have them in entrez.
Note that I'm only using the modules that had more than one gene.

I'm going to save each celltypes module set to one file.

```{r}
# Save to MAGMA
names(gene_list_entrez_sub) |> head()
# Create a character vector where each element is a single string
lines_to_write <- sapply(
  names(gene_list_entrez),
  function(name) {
    paste(name, paste(gene_list_entrez[[name]], collapse = " "))
  },
  USE.NAMES = FALSE
)

pseudobulk_lines <- lines_to_write[grepl("_pseudobulk_", lines_to_write)]
magma_gene_list_lines <- lines_to_write[!grepl("_pseudobulk_", lines_to_write)]

make_magma_input_per_celltype <- function(line_subset, subset_label) {
  # Get the line subset
  line_subset <- line_subset[grepl(subset_label, line_subset)]
  # Get celltypes
  celltypes <- sub("_.*", "", line_subset) |> unique()
  # Match celltypename from begining of line
  celltypes2 <- paste0("^", celltypes)
  # Get per celltype lines
  per_celltype_lines <- map(
    celltypes2,
    ~ line_subset[grepl(.x, line_subset)]
  ) |>
    set_names(paste0(celltypes, "_", subset_label))
  return(per_celltype_lines)
}

pseudobulk_apoe_lines <-
  make_magma_input_per_celltype(pseudobulk_lines, "pseudobulk_apoe")
pseudobulk_no_apoe_lines <-
  make_magma_input_per_celltype(pseudobulk_lines, "pseudobulk_no_apoe")
magma_gene_list_lines <-
  make_magma_input_per_celltype(magma_gene_list_lines, "sig_magma_sig_genes")
magma_list <- c(
  pseudobulk_apoe_lines,
  pseudobulk_no_apoe_lines,
  magma_gene_list_lines
)
# Write the character vector to a file
map2(
  magma_list,
  names(magma_list),
  ~ readr::write_lines(
    .x,
    here::here(
      "03_data/994_magma_inputs",
      paste0("ppi_sig_modules_", .y, ".magma.txt")
    )
  )
)
```

### Treeplots

```{r}
# Plotting the first module's GO enrichment result as an example
if (length(result_list[[1]]) > 0) {
  dotplot(result_list[[1]])
}

# Get semantic similarity of terms
result_list <- map(result_list, pairwise_termsim)
treeplot(result_list[[5]])

# Define a safe version of your treeplot function that returns NULL on error
safe_treeplot <- possibly(treeplot, otherwise = NULL)
# Use map with the safe version of the function
plan("multisession", workers = parallel::detectCores() - 1)
treeplots <- future_map(result_list, safe_treeplot)

# Remove any NULL entries
treeplots <- treeplots[!sapply(treeplots, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(treeplots, is.null)) == 0)
# Replace those with no treeplot with dotplots
no_treeplot <- names(result_list)[!names(result_list) %in% names(treeplots)]
dotplots <- map(result_list[no_treeplot], dotplot)
assertthat::see_if(sum(map_lgl(dotplots, is.null)) == 0)
treeplots <- c(treeplots, dotplots)

treeplots <- map2(treeplots, names(treeplots), ~ .x + ggtitle(.y))

# I want to make patchwork of plots per celltype
# Extract unique cell types from the plot names
celltypes <- unique(sub("_module.*", "", names(treeplots)))

# Split the list of plots into a nested list by cell type
get_celltype_ontology_plots <- function(celltype, ontology, plot_list) {
  plots_for_type <- plot_list[grepl(
    paste0("^", celltype, "_module"),
    names(plot_list)
  )]
  plots_ont <- plots_for_type[grepl(ontology, names(plots_for_type))]
  combined_plot <- wrap_plots(plots_ont, ncol = 1)
  if (length(plots_ont) == 0) {
    combined_plot <- NULL
  }
  combined_plot
}

plots_by_celltype_bp <-
  map(celltypes, get_celltype_ontology_plots, "_BP", treeplots) |>
  set_names(paste0(celltypes, "_BP"))
plots_by_celltype_cc <-
  map(celltypes, get_celltype_ontology_plots, "_CC", treeplots) |>
  set_names(paste0(celltypes, "_CC"))
plots_by_celltype_mf <-
  map(celltypes, get_celltype_ontology_plots, "_MF", treeplots) |>
  set_names(paste0(celltypes, "_MF"))

plots_by_celltype <-
  c(plots_by_celltype_bp, plots_by_celltype_cc, plots_by_celltype_mf)
# Remove nulls
plots_by_celltype <- plots_by_celltype[!sapply(plots_by_celltype, is.null)]

rm(plots_by_celltype_bp, plots_by_celltype_cc, plots_by_celltype_mf)
# save the plots nice and tall
walk2(
  plots_by_celltype,
  names(plots_by_celltype),
  ~ ggsave(
    filename = here::here(
      "05_figures/990_shared_figures/ppi_modules",
      paste0(.y, "_combined_plot.png")
    ),
    plot = .x,
    width = 14,
    height = 34
  )
)
```

```{r}
#| fig-height: 25
#| fig-width: 14
plots_by_celltype
```

```{r}
result_df <- map2_dfr(
  result_list,
  names(result_list),
  ~ {
    .x@result |>
      dplyr::filter(p.adjust < 0.05) |>
      dplyr::mutate(
        label = .y,
        ontology = str_extract(label, "[^_]+$"),
        module = str_extract(label, "(?:.*_)?([^_]+)(?=_[^_]+$)", group = 1),
        group = str_replace(label, "^((.*?_){2}.*?)_.*$", "\\1")
      )
  }
) |>
  as_tibble()

lineage_pathways <- result_df |>
  dplyr::filter(grepl("lineage", group) & Count > 1)

unique_module_genes <- lineage_pathways |>
  #dplyr::filter(ontology == "BP") |>
  dplyr::mutate(genes = str_split(geneID, "/")) |>
  dplyr::select(group, module, ontology, genes) |>
  unique() |>
  summarise(
    unique_genes = list(unique(unlist(genes))),
    .by = c(group, module, ontology)
  ) |>
  dplyr::mutate(plot_title = paste0(group, "-", ontology))

counts <- assays(sce_subset)$counts

plots <- map2(
  unique_module_genes$unique_genes,
  unique_module_genes$plot_title,
  ~ {
    module_genes <- translated_id |>
      dplyr::filter(hgnc_symbol %in% .x) |>
      dplyr::mutate(plot_title = paste0(.y, " - ", hgnc_symbol))
    print(module_genes)
    plots <- map2(
      module_genes$ensembl_gene_id,
      module_genes$plot_title,
      ~ plotSmoothers(sce_subset, counts, .x) +
        ggtitle(.y)
    )
    return(plots)
  }
)

plot_grids <- map(plots, ~ plot_grid(plotlist = .x))
plot_grids[[1]]

map(plots, length) |> unlist() |> sum()

pdf(
  here(
    "05_figures/990_shared_figures/004_pseudotime",
    "01_tradeseq",
    "sig_ppi_module_pathways.pdf"
  ),
  width = 11,
  height = 8.5
)
walk(plot_grids, print)
dev.off()
```

### Module labels

#### Pseudobulk labels

#### MAGMA sig gene labels

##### Stroke

```{r}
vascular_stroke <-
  list(
    "Arterial" = c(
      "1" = "epithelial_cell_migration",
      "3" = "stem_cell_prolif-g2_m_transition",
      "4" = "macroautophagy",
      "5" = "gtpase-axon",
      "6" = "angiogenesis"
    ),
    "Arteriolar-SMC" = c(
      "1" = "actin_org_stress",
      "2" = "autophagy",
      "4" = "heart_contraction",
      "5" = "extracell_matrix",
      "6" = "cell_dev",
      "8" = "serine_kinase"
    ),
    "Capilary" = c(
      "1" = "cell_function",
      "2" = "autophagy",
      "3" = "kidney-sex_development",
      "5" = "mrna_processing"
    ),
    "Meningeal-FB" = c(
      "1" = "extracellular_matrix",
      "2" = "dephosphorylation",
      "3" = "autophagy",
      "5" = "glycosylation",
      "6" = "rna_splicing"
    ),
    "Pericyte" = c(
      "1" = "epithelium_migration",
      "2" = "fatty_acid_synthesis",
      "3" = "rna_splice",
      "5" = "pcg_protein",
      "7" = "ubiquitination"
    ),
    "Pericyte-2" = c(
      "1" = "endosomal",
      "2" = "epithelium_migration",
      "3" = "limb_development",
      "4" = "cerebellum_development"
    ),
    "T-Pericyte" = c(
      "1" = "cytoskeleton",
      "2" = "autophagy",
      "3" = "serine_kinase",
      "4" = "axon_guidance",
      "5" = "rna_polymerase"
    ),
    "M-Pericyte" = c(
      "1" = "pos_reg_cytoskele",
      "2" = "serine_kinase",
      "3" = "autophagy",
      "4" = "neg_reg_angiogenesis",
      "5" = "cation_transport"
    ),
    "T-cell-mixed" = c(
      "1" = "cell_differentiation-axon",
      "2" = "gtpase",
      "3" = "rna_splicing",
      "4" = "ubiqutination"
    ),
    "Vascular-SMC-LINC00486" = c(
      "1" = "actin",
      "2" = "mrna",
      "3" = "gtpase",
      "4" = "histone",
      "5" = "angiogenesis"
    )
  )

# function to make df per vector
make_ppi_df <- function(
  module_labels,
  celltype,
  gwas,
  fraction,
  ontology = NA
) {
  df <-
    tibble(
      module_label = paste0(module_labels, "-module", names(module_labels)),
      celltype = celltype,
      gwas = gwas,
      fraction = fraction,
      ontology = ontology
    )
  return(df)
}
vascular_stroke <-
  map2(
    vascular_stroke,
    names(vascular_stroke),
    make_ppi_df,
    "stroke",
    "controls_vascular",
    "all"
  ) |>
  list_rbind()
```

##### AD

```{r}
ad_all_controls <- list(
  "Microglia-activated" = c(
    "1" = "Lymphocyte activation",
    "2" = "Amyloid",
    "3" = "Dephosphorylation"
  ),
  "Pericyte-2" = c("1" = "Amyloid", "3" = "Supramolecular fibre organisation"),
  "Perivascular-FB-KAZN2" = c(
    "2" = "Amyloid",
    "4" = "Viral process",
    "1" = "Axon terminus"
  )
)
module_labels <-
  map2(
    ad_all_controls,
    names(ad_all_controls),
    make_ppi_df,
    "ad",
    "all_controls",
    "all"
  ) |>
  list_rbind() |>
  rbind(vascular_stroke)

ad_parenchymal <- list(
  "Microglia-activated" = c(
    "1" = "synapse",
    "2" = "gtpase",
    "3" = "tcell_activation",
    "4" = "mirna",
    "5" = "amyloid"
  ),
  "Microglia-quiescent" = c(
    "1" = "synaptic_transmission",
    "2" = "immune_response",
    "4" = "actin_filament",
    "5" = "golgi",
    "6" = "ion_transport"
  )
)

module_labels <-
  map2(
    ad_parenchymal,
    names(ad_parenchymal),
    make_ppi_df,
    "ad",
    "controls_parenchymal",
    "all"
  ) |>
  list_rbind() |>
  rbind(module_labels)
```

```{r}
ad_all_controls_bp <- list(
  "Microglia-activated" = c(
    "1" = "leukocyte_activation",
    "2" = "actin_filament",
    "3" = "amyloid",
    "4" = "gtpas",
    "6" = "viral"
  ),
  "Pericyte-2" = c(
    "1" = "amyloid",
    "3" = "actin_filament",
    "4" = "circadian",
    "5" = "viral"
  ),
  "Perivascular-FB-KAZN2" = c("1" = "notch", "3" = "amyloid", "5" = "viral")
)
module_labels <-
  map2(
    ad_all_controls_bp,
    names(ad_all_controls_bp),
    make_ppi_df,
    "ad",
    "all_controls",
    "BP"
  ) |>
  list_rbind() |>
  rbind(module_labels)

all_magma_sig_celltype_genes_bp <- list(
  "All-celltypes" = c(
    "1" = "leukocyte_activation",
    "3" = "amyloid",
    "4" = "notch_sig-endothelial-migration"
  )
)
module_labels <-
  map2(
    all_magma_sig_celltype_genes_bp,
    names(all_magma_sig_celltype_genes_bp),
    make_ppi_df,
    "ad",
    "all_controls",
    "BP"
  ) |>
  list_rbind() |>
  rbind(module_labels)
```

```{r}
readr::write_csv(
  module_labels,
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "ppi_magma_sig_genes_module_labels.csv"
  )
)
```
