---
title: Protein-protein interactions
execute:
  eval: true
#self-contained: true
---

```{r}
here::i_am("04_data_analysis/006_protein-protein-interactions/17_protein-protein_interactions.qmd")
```

# Load packages

```{r}
source(here::here("04_data_analysis/990_code_libraries/02_library-calls-for-renv.R"))
tar_config_set(store = here::here("_targets"))
```

# Functions

Credit to Jimena for these functions, and indeed the basis for almost all the subsequent code.

```{r}
# Rescale data to range 0 to 1.
rescale01 <- function(numvect){
  rango <- range(numvect)
  rescalado <- unlist(lapply(numvect, function(x) if((x - rango[1]) == 0) { 0 } else {(x - rango[1]) / (rango[2] - rango[1])}))
  return(rescalado)
}

similar_gene_list  <- function(gene_list, attr_matrix, rango = 100){
  # attr_matrix must have at least a column with ensembl_gene_id and the rownames ordered by the attribute
  d_gl <- as.numeric(rownames(attr_matrix)[attr_matrix$ensembl_gene_id %in% gene_list])
  # Random sample of genes (most with a similar attribute)
  rango2 <- setdiff(seq(-rango/2, rango/2, 1), 0)
  rnd_ind <- sample(rango2, size = length(gene_list), replace = TRUE) 
  rnd_ind <- d_gl + rnd_ind
  # check the extremes (all should be within the range of D)
  if(length(which(rnd_ind < 1)) > 0) {
    rnd_ind[which(rnd_ind < 1)] <- sample(1:rango, 1)
  }
  if(length(which(rnd_ind > nrow(attr_matrix)))){
    rnd_ind[which(rnd_ind > nrow(attr_matrix))] <- sample(nrow(attr_matrix):(nrow(attr_matrix) - rango), 1)
  }
  # remove duplicates and replace with random genes (to keep gene number constant)
  if(length(rnd_ind) != length(unique(rnd_ind))){
    rnd_ind <- unique(rnd_ind)
    rnd_ind <- c(rnd_ind, sample(setdiff(1:nrow(attr_matrix), rnd_ind), size = (length(gene_list) - length(rnd_ind))))
  }
  rnd_smpl <- as.character(attr_matrix$ensembl_gene_id[rnd_ind])
  return(rnd_smpl)
}

# Divide genes according to an attribute #
attribute_2_list20bins <- function(attr_matrix, gene_col = 1, attr_col = 2, do_log = TRUE){
  if(do_log == TRUE){
    at <- rescale01(log(attr_matrix[, attr_col] + 1))  
  } else{
    at <- rescale01(attr_matrix[, attr_col])
  }
  bines <- seq(0, 1, .05)
  gps <- list()
  for(k in c(1:(length(bines) - 1))){
     if(k == 1){
      gps[[k]] <- as.character(union(attr_matrix[which(at <= bines[k]), gene_col],
                                     attr_matrix[which(at < bines[k + 1]), gene_col]))
     } else {
       if(k == 20){
         gps[[k]] <- as.character(intersect(attr_matrix[which(at >= bines[k]), gene_col], 
                                            attr_matrix[which(at <= bines[k +  1]), gene_col]))  
         } else {
           gps[[k]] <- as.character(intersect(attr_matrix[which(at >= bines[k]), gene_col],
                                              attr_matrix[which(at < bines[k + 1]), gene_col]))
           }
     }
  }
  return(gps)
}

```

# Read in data

```{r}
#| eval: true
# read data
# Get DESeq2 results
res <- readr::read_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated_no-apoe.csv")) |>
  na.omit() |>
  dplyr::mutate(apoe_included = "no_apoe")
res <- readr::read_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated_apoe.csv")) |>
  na.omit() |>
  dplyr::mutate(apoe_included = "apoe") |>
  rbind(res)


# if(include_apoe) {
# res <- readr::read_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated_apoe.csv")) %>%
#   na.omit()
# } else {
# res <- readr::read_csv(here::here("03_data/990_processed_data/001_snrnaseq/08_pseudobulk/pseudobulk_ad-vs-control_deseq2_subtype-annotated_no-apoe.csv")) %>%
#   na.omit()
# }
```

```{r}
x = res |>
  dplyr::filter(padj < 0.05)
table(x$celltype)
```

# Data prep

We need ensembl IDs for the PPI, so let's get them

```{r}
# Gene ensembl IDs
tar_load(gene_ids)
gene_ensembl_ids <- gene_ids
# remove duplicated gene IDs 
unique_ids = gene_ensembl_ids[which(!duplicated(gene_ensembl_ids$gene)),]

# Join dataframes
res <- left_join(res, unique_ids, by = "gene")
```

Filter to significant genes

```{r}
# Filter to sig genes
res_sig <- res |>
  dplyr::filter(padj < 0.05)

x = res_sig |>
  dplyr::filter(apoe_included ==  "no_apoe")
table(x$celltype)

#write_csv(res_sig, here::here("initial_pseudobulk_sig_genes.csv"))

# Assert that there are no NAs in ensembl IDs
assertthat::are_equal(nrow(dplyr::filter(res_sig, is.na(ensembl))), 0)

readr::write_csv(res_sig, here::here("../../../gmbh_results_summaries/2024-04-52_ad_bbb/pseudobulk_sig_degs.csv"))
```

## MAGMA genes

Add in the sig MAGMA celltype sig gene list

```{r}
#| eval: false
#| cache: true
# Get entrez IDs
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
listAttributes(ensembl)[grepl("entrez", listAttributes(ensembl)$name, ignore.case = T),]

entrez_ids <- getBM(attributes = c('ensembl_gene_id', 'entrezgene_id'),
                         filters = 'ensembl_gene_id',
                         values = gene_ensembl_ids$ensembl,
                         mart = ensembl)
```


```{r}
tar_load(translated_id)

magma_sig <-
  readr::read_tsv(here::here(
    "03_data/994_magma_inputs/sig_celltype_sig_genes.tsv"
  )) |>
  janitor::clean_names() |>
  dplyr::rename(entrezgene_id = gene) |>
  # Exclude the top one percents
  dplyr::filter(!percent == "top-one-percent") |>
  # Filter to level 2
  #dplyr::filter(celltype_level == "level2") |>
  dplyr::filter(padj < 0.05) |>
  dplyr::filter(grepl("Bellgenguez|EUROPEUKBB", group)) |>
  dplyr::left_join(translated_id, by = join_by(entrezgene_id))

assertthat::assert_that(sum(!magma_sig$entrezgene_id %in% translated_id$entrezgene_id) == 0)
# get gene lists per celltype, gwas and percent
magma_list <- magma_sig |>
  dplyr::rename(ensembl = ensembl_gene_id) |>
  dplyr::mutate(case_or_control = if_else(grepl("_Case_", group), "case", 
                                          "control")) |>
  dplyr::group_by(gwas_background, input_gene_list, case_or_control, percent, 
                  celltype_level, set_name) |>
  tidyr::nest() |>
  dplyr::rename(celltype = set_name) |>
  dplyr::mutate(celltype = paste0(celltype, "_sig-magma-sig-genes"))
```

I'd be nice to have a PPI for all the gene across all three celltypes of interest as well

```{r}
sig_celltypes_magma <- magma_sig |>
  dplyr::rename(ensembl = ensembl_gene_id) |>
  dplyr::filter(set_name %in% c("Microglia-activated", "Pericyte-2", "Perivascular-FB-KAZN2") & input_gene_list == "all_controls" & percent == "top-ten-percent" & gwas_background == "EUROPEUKBB_35k10k")
sig_celltypes_magma <- tibble(celltype = "sig_magma_celltypes", data = list(sig_celltypes_magma))
```

There're a few genes that have overlapping expression in the celltypes, it'd be good to add those together and see what the interactions look like.

```{r}
x <- sig_celltypes_magma$data[[1]] |>
  dplyr::left_join(unique_ids, by = join_by(ensembl)) |>
  dplyr::group_by(set_name) |>
  dplyr::summarise(genes = gene)
extra_genes <- data.frame(set_name = c("Microglia-activated"), 
                          genes = c("ADAM17", "MARCHF7", "PLEKHA1", "MINK1"))
mg <- x |> dplyr::filter(set_name == "Microglia-activated") |> 
  rbind(extra_genes)
extra_genes <- data.frame(set_name = c("Pericyte-2"), genes = c("IQCK"))
p2 <- x |> dplyr::filter(set_name == "Pericyte-2") |> 
  rbind(extra_genes)
extra_genes <- data.frame(set_name = c("Perivascular-FB-KAZN2"), 
                          genes = c("TRANK1", "EGFR"))
all <- x |> dplyr::filter(set_name == "Perivascular-FB-KAZN2") |>
  rbind(extra_genes) |>
  rbind(mg) |>
  rbind(p2) |>
  dplyr::left_join(unique_ids, by = join_by(genes == gene)) |>
  dplyr::group_by(set_name) |>
  tidyr::nest() |>
  dplyr::mutate(celltype = case_when(
    set_name == "Microglia-activated" ~ "Microglia-activated_sig_magma_extended",
    set_name == "Pericyte-2" ~ "Pericyte-2_sig_magma_extended",
    set_name == "Perivascular-FB-KAZN2" ~ "Perivascular-FB-KAZN2_sig_magma_extended",
    .default = set_name
  ), input_gene_list = "all_controls", percent = "top-ten-percent", 
  gwas_background = unique(sig_celltypes_magma$data[[1]]$gwas_background)) |>
  dplyr::ungroup() |>
  dplyr::select(celltype, input_gene_list, gwas_background, percent, data)

assertthat::assert_that(map_lgl(all$data, ~ nrow(.x) == nrow(unique(.x))) |> sum() != 0)
```

## Pseudotime

```{r}
pseudotime <- readr::read_csv(here("03_data/990_processed_data/008_pseudotime",
                      "top_pseudotime_condition_genes.csv"))
head(pseudotime)

pseudotime_list <- pseudotime |>
  dplyr::rename(ensembl = ensembl_gene_id, celltype = lineage) |>
  dplyr::group_by(celltype) |>
  tidyr::nest()
```

## Merge data

```{r}
gene_list <- res_sig |>
  dplyr::group_by(celltype, apoe_included) |>
  tidyr::nest() |>
  dplyr::mutate(celltype = paste0(celltype, "_pseudobulk"))

# Merge pseudobulk and magma data
gene_list <- rbind(gene_list, magma_list) |>
  rbind(sig_celltypes_magma) |>
  rbind(all) |>
  rbind(pseudotime_list)
rm(all, mg, p2)
```

# PPI Test 1. Links within gene set

## Background gene list

```{r}
#| eval: false

# Note that it can take a while to download the gene lists, so I've set eval 
# to false for this chunk.

# ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
# 
# # Background population (protein coding genes)
# bg <- getBM(attributes = c("ensembl_gene_id", "gene_biotype"), mart = ensembl)
# bg <- bg[which(bg$gene_biotype == "protein_coding"), ]
# write.table(bg$ensembl_gene_id, here::here("03_data/993_protein_protein_interaction_data/full_background"), 
#             sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# CDS length # 
cds <- getBM(attributes = c("ensembl_gene_id", "cds_length"),
            mart = ensembl)
colnames(cds) <- c("ensembl_gene_id", "cds_length")
cds <- cds[-which(is.na(cds$cds_length)== TRUE), ]
cds <- cds[order(cds$ensembl_gene_id), ]
cds_max <- aggregate.data.frame(cds, by = list(cds$ensembl_gene_id), FUN = max)
cds_max <- cds_max[, c("ensembl_gene_id", "cds_length")]
cds_max <- cds_max[cds_max$ensembl_gene_id %in% bg$ensembl_gene_id, ]
write.table(cds_max, here::here("03_data/993_protein_protein_interaction_data/EnsemblGeneID_MaxCDSlength.txt"), 
            sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
```

## Design

So I'm thinking it makes sense to do this with gene lists from the pseudobulk differential expression per celltype.

### Choose PPI network

We can either use the full PPI network, or just the known interactions

```{r}
use_known_interactions_only = TRUE
```

```{r}
# # # SELECT YOUR NETWORK FILE # # # 
# Merged protein protein interactions.
# my_network <- read_graph(file = here::here("03_data/993_protein_protein_interaction_data/2023May_MergedPPI_.txt"), 
#                          format = "ncol")
# For some reason updating igraph has resulted in read.graph being deprecated 
# in favour for read_graph, but this is throwing an error
# Read the file into a dataframe
# ppi_data <- read.table(here::here("03_data/993_protein_protein_interaction_data/MergedPPI_2024Feb_PIO_STRING.txt"), 
#                        header = FALSE, as.is = TRUE)
if(use_known_interactions_only) {
ppi_data <- read.table(here::here("03_data/993_protein_protein_interaction_data/MergedPPI_2024Feb.txt"), 
                       header = FALSE, as.is = TRUE)
} else {
ppi_data <- read.table(here::here("03_data/993_protein_protein_interaction_data/MergedPPI_2024Feb.txt"), 
                       header = FALSE, as.is = TRUE)
}

# Create an igraph object from the dataframe
my_network <- graph_from_data_frame(ppi_data, directed = FALSE)
rm(ppi_data)
# Check the graph
summary(my_network)

# To include merged PPI datasets with only physical interactions from STRING
# use 2023May_MergedPPI_PIO_STRING.txt instead

edge_attr(my_network, "weight", index = E(my_network)) <- 1
```

## Background list

Could want to run against multiple backgrounds in future, but I'll just use the full list of gene from the pseudobulk across all celltypes.

```{r}
# For the background I can use the full gene list including non-significant genes
background_population <- unique(res$ensembl)
background_population <- list("full_background" = background_population)
```

```{r}
#| eval: false
# Path to background populations
bg_pop <-
  list.files(
    path = here::here("03_data/993_protein_protein_interaction_data/"),
    full.names = TRUE,
    pattern = "Background"
  ) 

# # #  INPUT YOUR BACKGROUND population # # # 
# All protein coding genes for example
background_population <- map(bg_pop, ~ read.table(file = .x, 
                                    sep = "\t", header = FALSE, 
                                    stringsAsFactors = FALSE)) |>
  purrr::set_names(basename(bg_pop))

# if(length(background_population) == 1){
#   background_population <- background_population[[1]]
# }
```


```{r}
# # #  INPUT gene attributes  # # # 
# Gene length / max CDS length
gene_length <- read.table(here::here("03_data/993_protein_protein_interaction_data/EnsemblGeneID_MaxCDSlength.txt"), 
                         sep = "\t", header = FALSE, 
                         stringsAsFactors = FALSE)
colnames(gene_length) <- c("ensembl_gene_id", "gene_length")


# # # SETUP NUMBER OF RANDOM SAMPLES to create your NULL # # #
m <- 10000

# # # Set to "D" to take into account degree, 
# # # "GL" to taken into account Gene length, 
# # # or "B" to take into account both degree and Gene length
gene_attribute <- "B"

# # # CHANGE the name of your OUTPUT FILE that will contain your test against NULL # # #
output_file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "PPI_Test1"
  )

# Min number of genes for a cluster
min_cluster_size <- 5

# Output Louvain clusters
output_file2 <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "PPI_Test1-Louvain_")
```

```{r}
# Add test type to the output file name
if(gene_attribute == "D") {
  output_file <- paste(output_file, "MatchDegree", sep = "_")} else {
  if(gene_attribute == "GL") {
  output_file <- paste(output_file, "MatchGenelength", sep = "_")} else {
    if(gene_attribute == "B"){
  output_file <- paste(output_file, "MatchDegreeAndGenelength", sep = "_")   
    }
  }
  }

if(use_known_interactions_only) {
  output_file <- paste(output_file, "known-interactions", sep = "_")
  output_file2 <- paste(output_file2, "known-interactions", sep = "_")
} 
    
# Pull out the ensembl list for each celltype
my_gene_list <- map(gene_list$data, ~ dplyr::pull(.x, ensembl) |> unique()) |>
  set_names(paste(gene_list$celltype, gene_list$apoe_included, 
                  gene_list$gwas_background, gene_list$input_gene_list, 
                  gene_list$percent, gene_list$celltype_level, 
                  gene_list$case_or_control, sep = "_"))
names(my_gene_list) <- str_replace(names(my_gene_list), "_NA_NA_NA_NA_NA", "") |>
  str_replace("_NA_NA", "") |>
  str_replace("_NA", "")
```

## Gene lists for analysis

```{r}
process_network <- function(background) {
  # Reduce my network to background population of genes tested #
  Gbg <- vertex_attr(my_network)$name
  BG <- intersect(background, intersect(Gbg, gene_length$ensembl_gene_id))
  my_network <- induced_subgraph(graph = my_network, vids = BG)
  
  # Create tables with the GENE attributes provided for the background population found in my network #
  # Calculate and order genes according to their degree in my network #
  D <- igraph::degree(my_network, mode = "all")
  D <- data.frame(ensembl_gene_id = names(D), degree = D)
  D <- D[order(D$degree, decreasing = TRUE),]
  rownames(D) <- 1:nrow(D)
  
  # Order genes by Gene length #
  gene_length <- gene_length[gene_length$ensembl_gene_id %in% BG, ]
  gene_length <- gene_length[order(gene_length$gene_length, decreasing = TRUE), ]
  rownames(gene_length) <- 1:nrow(gene_length)
  
  # Combined score Degree and Gene length
  B <- merge(D, gene_length, by = "ensembl_gene_id")
  B <- data.frame(B, 
                  scaled_degree = rescale01(B$degree), 
                  scaled_gene_length = rescale01(B$gene_length), 
                  score = rescale01(B$degree) + rescale01(B$gene_length))
  B <- B[order(B$score,  decreasing = TRUE), ]
  rownames(B) <- 1:nrow(gene_length)
  
  # Report numbers
  print(paste0("Background population: ", length(background), " genes"))
  print(paste0("Genes in the network: ", length(Gbg), " genes"))
  print(
    paste0(
      "Background population contained in the network and used for analysis: ",
      length(BG),
      " genes"
    )
  )
  
  x <- map(my_gene_list, ~ length(intersect(.x, BG)))
  x <- map2(x, names(my_gene_list), ~ print(paste0("Genes of interest contained in the network and used for analysis: ", .x, " for celltype ", .y)))
  
  return(list("BG" = BG, "network" = my_network, "D" = D, "B" = B))
}

res <- map(background_population, process_network)
```

```{r}
x <- map2(names(my_gene_list), my_gene_list, ~ print(paste0("Genes of interest: ", length(.y), " for celltype ", .x)))
rm(x)
```

## Subnetwork plot

+ Interaction network of the genes of interest.

```{r}
rm(background_population)

# Function to intersect each cell type gene list with a single background list
intersect_with_background <- function(background_genes, cell_type_gene_list) {
  map(cell_type_gene_list, ~ intersect(.x, y = background_genes))
}
my_gene_list <- map(res, ~ intersect_with_background(.x$BG, my_gene_list))
```

```{r}
# Define subnetwork
create_subnetwork <- function(network, gene_lists) {
  map(gene_lists, ~ induced_subgraph(graph = network, vids = .x))
}
my_subgraph <- map2(res, my_gene_list, ~ create_subnetwork(.x$network, .y))
```

I'll disable the code that generates the plots as they also can be plotted with their clusters later.

```{r}
#| eval: false
# Plot subnetwork
map(my_subgraph, ~ map2(
  .x, names(.x),
  ~ plot(
    .x,
    vertex.size = 3,
    vertex.color = "darkslateblue",
    vertex.frame.color = "darkslateblue",
    edge.color = "grey",
    rescale = TRUE,
    vertex.label = NA,
    main = paste0("Celltype: ", .y)
  )
))
```

## Test for number of interactions

```{r}
perform_permutation <- function(gene_list, gene_list_name, my_network, BG, gene_attribute, m, num_cores = detectCores() - 1) {
  
  print(paste0("Processing ", gene_list_name))
  
  # Gene population of interest
  gene_list_A <- intersect(gene_list, BG)

  # Sum of the edges within gene list A
  mynet_gl <- induced_subgraph(my_network, vids = gene_list_A)
  w_mynet_gl <- edge.attributes(mynet_gl)$weight
  o <- sum(w_mynet_gl)
  
  # Sum of the edges from within a random gene list size A
  # Use mclapply to parallelize the replicate function
  e <- mclapply(1:m, function(i) {
    rnd_smpl <- similar_gene_list(gene_list = gene_list_A, attr_matrix = gene_attribute, rango = 100)
    rnd_mynet_gl <- induced_subgraph(my_network, vids = rnd_smpl)
    rnd_w_mynet_gl <- edge.attributes(rnd_mynet_gl)$weight
    sum(rnd_w_mynet_gl)
  }, mc.cores = num_cores)
  # Convert the list to a vector
  e <- unlist(e)

  p <- length(which(e >= o)) / m

  # Write to dataframe
  df <- data.frame("gene_list" = gene_list_name, "o" = o, "e" = mean(e), "sem" = sd(e), "p" = p)
  return(df)
  
  print(paste0("Finished processing ", gene_list_name))
}

results <-
  map2(
    my_gene_list$full_background,
    names(my_gene_list$full_background),
    ~ perform_permutation(
      .x,
      .y,
      my_network = res$full_background$network,
      BG = res$full_background$BG,
      gene_attribute = res$full_background[[gene_attribute]],
      m = m
    )
  ) |>
  list_rbind()
```

### Results

```{r}
# Make group column for pseudobulk/lineage/magma genes
results <- results |>
  dplyr::mutate(input_type = case_when(
    grepl("_pseudobulk", gene_list) ~ "pseudobulk",
    gene_list == "1" | gene_list == "2" | gene_list == "overall" ~ "lineage",
    .default = "magma"))
results <- results |>
  dplyr::mutate(apoe = case_when(
    grepl("_no_apoe", gene_list) ~ "no_apoe",
    input_type == "pseudobulk" ~ "apoe",
    .default = NA
  )) |>
  dplyr::mutate(case_control = case_when(
    grepl("_case", gene_list) & input_type == "magma" ~ "case",
    !grepl("_case", gene_list) & input_type == "magma" ~ "control",
    .default = NA
  ))
# Add adjusted pvalues
results$pval <- ifelse(results$p == 0, 1e-8, results$p)
results <- results |>
  dplyr::group_by(input_type, case_control, apoe) |>
  dplyr::mutate(padj = p.adjust(pval, method = "bonferroni"))

results <- results |>
  dplyr::mutate(gene_list = if_else(gene_list %in% c("1", "2", "overall"), paste0("lineage_", gene_list), gene_list))

readr::write_tsv(results, paste0(output_file, ".tsv"))
#results <- readr::read_tsv(paste0(output_file, ".tsv"))
sig_celltypes <- results |>
  dplyr::filter(padj < 0.05)
# Table with results of test
results |>
  dplyr::filter(padj < 0.05) |>
  DT::datatable(caption = "Test if the number of interactions is higher than expected by chance",
                rownames = FALSE) %>% formatRound(columns = c("e", "sem"), digits = c(2))
```

+ **o** observed number of interactions.

+ **e** expected number of interactions based on `{r} m` randomizations.

+ **sem** standard error of the mean based on `{r} m` randomizations.

+ **p** estimated p value based on `{r} m` randomizations.

+ **Note** If a weighted network is provided then it is a test for the sum of the edge's weights.

## Louvain clustering 

- run through funciton code and make sure it's working

```{r}
perform_louvain_clustering <- function(graph,
                                       min_cluster_size = 1,
                                       color_palette = "Dark2",
                                       default_color = "grey",
                                       label) {
  # Perform Louvain clustering
  louvain <- cluster_louvain(graph)
  
  # Get module membership
  module_membership <- membership(louvain)
  # Get the sizes of each module
  module_sizes <- sizes(louvain)
  # Filter out small clusters
  large_modules <- names(module_sizes[module_sizes >= min_cluster_size])
  
  # Create a filtered membership vector
  filtered_membership <- ifelse(module_membership %in% large_modules, module_membership, 0)
  # Get the number of remaining modules
  num_modules <- length(unique(filtered_membership[filtered_membership != 0]))
  
# Generate distinct colors for each module
  colors <- brewer.pal(n = num_modules, name = color_palette)
  
  # Create a color vector with the default color for small clusters
  module_colors <- rep(default_color, length(filtered_membership))
  # Assign colors to large modules
  module_colors[filtered_membership != 0] <- colors[as.integer(factor(filtered_membership[filtered_membership != 0]))]
  
  # Get gene names
  gene_names <- V(graph)$name
  
  # Create dataframe
  result <- data.frame(
    gene = gene_names,
    module = filtered_membership,
    module_color = module_colors,
    label = label
  )
  
  return(result)
}

# remove any subgraphs that are empty
subgraphs <- my_subgraph$full_background[map_lgl(my_subgraph$full_background, ~ length(.x) > 0)]


names(subgraphs) <- if_else(names(subgraphs) %in% c("1", "2", "overall"), paste0("lineage_", names(subgraphs)), names(subgraphs))

module_assignment <-
  map2(
    subgraphs,
    names(subgraphs),
    ~ perform_louvain_clustering(.x, min_cluster_size = 3, label = .y)
  )
```

```{r}
ddd <- load(here::here("04_data_analysis/994_scripts_from_emeka/table_gene_full.Rdata"))
info_annot_gene<-read.table(here::here("04_data_analysis/994_scripts_from_emeka/NCBI37.3.gene.loc"),h=F,sep="\t")
colnames(info_annot_gene) <- c('entrezid', 'chr', 'start', 'stop', 'strand', "hgnc_symbol")
table_gene_du_id<-merge(table_gene_du,info_annot_gene,by=c("hgnc_symbol"))
colnames(table_gene_du_id)[2] <- "gene" 

module_assignment <- map(module_assignment, dplyr::left_join, table_gene_du_id, by = "gene")
module_assignment <- map(module_assignment, ~ .x |>
           dplyr::left_join(gene_ids, by = join_by(gene == ensembl)) |>
           dplyr::mutate(gene_symbol = if_else(is.na(hgnc_symbol), gene.y, hgnc_symbol)))
```

```{r}
modules <- list_rbind(module_assignment) |>
  dplyr::filter(label %in% sig_celltypes$gene_list) |>
  dplyr::filter(!grepl("low-feature-cell", label))

ad_all_controls <- list(
  "Microglia-activated_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2_control" = c("1" = "Lymphocyte activation", "2" = "Amyloid", "3" = "Dephosphorylation"),
  "Pericyte-2_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2_control" = c("1" = "Amyloid", "3" = "Supramolecular fibre organisation"),
  "Perivascular-FB-KAZN2_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2_control" = c("2" = "Amyloid", "4" = "Viral process", "1" = "Axon terminus"),
  "Microglia-activated_sig_magma_extended_EUROPEUKBB_35k10k_all_controls_top-ten-percent" = c("1" = "Amyloid", "2" = "Cell adhesion", "3" = "Lymphocyte activation"),
  "Perivascular-FB-KAZN2_sig_magma_extended_EUROPEUKBB_35k10k_all_controls_top-ten-percent" = c("1" = "Viral process", "2" = "Actin filament", "3" = "Amyloid"),
  "Pericyte-2_sig_magma_extended_EUROPEUKBB_35k10k_all_controls_top-ten-percent" = c("1" = "Amyloid", "3" = "Supramolecular fibre organisation")
)

# function to make df per vector
make_ppi_df <- function(module_labels, celltype, gwas, fraction, ontology = NA) {
  df <-
    tibble(
      module_label = module_labels,
      module = as.numeric(names(module_labels)),
      label = celltype,
      gwas = gwas,
      fraction = fraction,
      ontology = ontology
    )
  return(df)
}

module_labels <-
  map2(ad_all_controls,
       names(ad_all_controls),
       make_ppi_df,
       "Bellenguez",
       "all_controls",
       "all") |>
  list_rbind()

modules <- modules |>
  left_join(module_labels, by = join_by(label, module))
```

```{r}
plot_network_ggraph <- function(group, module_df, overall_network = my_network,
                                network_layout = "auto") {
  require(ggraph)
  require(tidygraph)
  
  df <- module_df |>
    #dplyr::filter(grepl(group, label)) |>
    dplyr::filter(label == group) |>
    dplyr::group_by(module) |>
    dplyr::mutate(genes_in_module = n()) |>
    dplyr::ungroup() |>
    dplyr::filter(genes_in_module > 1) |>
    # If there's no module labels just replace with module numbers
    dplyr::mutate(module_label = if_else(is.na(module_label), NA, module_label))
    #dplyr::mutate(module_label = if_else(is.na(module_label), as.character(module), module_label))
  
  # Add filter to isolated nodes
  if(grepl("Perivascular-FB-KAZN2", group)) {
    df <- df |>
      dplyr::filter(!hgnc_symbol %in% c("JAZF1", "ZNF652"))
  }
  
  subgraph <- induced_subgraph(graph = overall_network, vids = df$gene)
  # Create a named vector for easy lookup
ensembl_to_symbol <- setNames(df$hgnc_symbol, df$gene)

# Add gene symbols to the graph vertices
V(subgraph)$hgnc_symbol <- ensembl_to_symbol[V(subgraph)$name]
  # Convert igraph to tidygraph
  tbl_graph <- as_tbl_graph(subgraph)
  
  # Add module information to the graph
  tbl_graph <- tbl_graph |>
    activate(nodes) |>
    mutate(module_number = df$module,
           module_color = df$module_color,
           module_label = df$module_label,
           group = df$label,
           gene_name = df$gene_symbol) |>
    dplyr::filter(centrality_degree() > 1)
  
  # Plot using ggraph
  p <- ggraph(tbl_graph, layout = network_layout) +  # 'fr' layout for Fruchterman-Reingold
    geom_edge_link(aes(edge_alpha = 0.5), edge_colour = "grey", 
                   edge_linetype = "solid", show.legend = FALSE) +
    geom_node_point(aes(color = module_label), size = 1.2, alpha = 0.7) +
    geom_node_text(aes(label = gene_name), repel = TRUE, size = 1.8) +
    scale_color_manual(values = setNames(df$module_color, df$module_label)) +
    theme_void() +
    #guides(color = guide_legend(override.aes = list(size = 2))) +
    #guides(color = guide_legend(nrow = 2)) +
    labs(color = "Module Function", title = unique(df$celltype)) +
    theme(legend.position = "top", plot.title = element_text(size = 5,
                                                             hjust = 0.5,
                                                             face = "bold"),
          legend.text = element_text(size = 4), 
          legend.title = element_text(size = 4, hjust = 0.5, vjust = -7),
          legend.spacing.x = unit(0.1, "mm"), 
          legend.spacing.y = unit(0.1, "mm"), 
          legend.key.width = unit(0.8, "mm"),
          legend.key.spacing.x = unit(1, "mm"),
          legend.title.position = "top") +
  
  if(length(unique(df$label)) > 1) {
    p <- p + facet_wrap(~ group)  # Facet by group
  }
  
  return(p)
}

# Define the function to subset a single string up to the last underscore
subset_until_last_underscore <- function(input_string) {
  # Find the position of the last underscore
  last_underscore_position <- str_locate_all(input_string, "_")[[1]][, 1] %>% max()
  
  # Subset the string up to the last underscore
  if (!is.na(last_underscore_position)) {
    return(str_sub(input_string, 1, last_underscore_position - 1))
  } else {
    return(input_string)
  }
}

# Apply the function to each element of the vector
modules$celltype_label_full <- sapply(modules$label, subset_until_last_underscore)
# Extract substring up to the first underscore
modules$celltype <- str_extract(modules$label, "^[^_]*")

# I want to make sure the Amyloid groups get the same colour label
# Function to assign colors
assign_amyloid_color <- function(df, amyloid_color) {
  df <- df %>%
    dplyr::group_by(label) %>%
    dplyr::mutate(
      # Check if "Amyloid" is in the group
      amyloid_present = any(module_label == "Amyloid"),
      # Get the original color of "Amyloid" if present
      original_amyloid_color = ifelse(module_label == "Amyloid", module_color, NA),
      original_amyloid_color = dplyr::first(na.omit(original_amyloid_color))
    ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      # Assign the desired color to "Amyloid"
      module_color = case_when(
        module_label == "Amyloid" ~ amyloid_color,
        .default = module_color)) |>
      # Swap the original "Amyloid" color with the new "Amyloid" color in other labels
    dplyr::mutate(module_color = case_when(
      module_color == amyloid_color & module_label != "Amyloid" ~ original_amyloid_color,
      .default = module_color)
    ) %>%
    dplyr::select(-amyloid_present, -original_amyloid_color)
  
  return(df)
}
modules <- assign_amyloid_color(modules, "#D95F02")

plots <- map(unique(modules$label), plot_network_ggraph, modules, network_layout = "fr") |>
  set_names(unique(modules$label))

qs::qsave(plots, here::here("05_figures/990_shared_figures/003_final_figures/001_data_for_plots/ppi_network_plots.qs"))
map2(plots, unique(modules$label), ~ ggsave(here::here("05_figures/990_shared_figures/002_pseudobulk/ppi_sig_networks", paste0(.y, ".png")), plot = .x, height = 12, width = 14))
```

## Joint plots

Want to try making a joint plot for the three celltypes of interest

Need to make a table that has one row per gene and a join factor of celltype and one for module function
Also should make a column to denote if a gene is unique in 2 or three celltypes.
Make a master amyloid column as well

```{r}
celltype_abbrev_df <- readr::read_tsv(here::here("05_figures/990_shared_figures/003_final_figures/001_data_for_plots/celltype_abbreviations.tsv"))
```


```{r}
#| eval: false
unique(modules$label)

module_sub <- modules |>
  dplyr::filter(label %in% c("Microglia-activated_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2", "Pericyte-2_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2", "Perivascular-FB-KAZN2_sig-magma-sig-genes_EUROPEUKBB_35k10k_all_controls_top-ten-percent_level2")) |>
  dplyr::left_join(celltype_abbrev_df, by = join_by(celltype)) |>
  dplyr::mutate(celltypes_abbrev = if_else(is.na(celltypes_abbrev), celltype, celltypes_abbrev))

celltypes_per_gene <- module_sub |>
  dplyr::select(gene_symbol, celltypes_abbrev) |>
  pivot_wider(values_from = celltypes_abbrev, names_from = celltypes_abbrev) |>
  unite(celltypes_with_gene, `Microglia-A`:`Perivascular-FB-2`, sep = " ", na.rm = TRUE)

modules_per_gene <- module_sub |>
  dplyr::select(gene_symbol, celltypes_abbrev, module_label) |>
  dplyr::filter(!is.na(module_label)) |>
  unite(celltype_model, celltypes_abbrev:module_label) |>
  pivot_wider(values_from = celltype_model, names_from = celltype_model) |>
  unite(
    celltypes_with_modules_gene,
    `Microglia-A_Lymphocyte activation`:`Perivascular-FB-2_Viral process`,
    sep = " ",
    na.rm = TRUE
  ) |>
  dplyr::mutate(amyloid_modules = if_else(
    grepl("amyloid", celltypes_with_modules_gene, ignore.case = TRUE),
    "amyloid",
    NA
  ))

# Count unique cell types for each gene
df_summary <- module_sub |>
  dplyr::select(gene_symbol, celltypes_abbrev) |>
  summarise(celltype_count = n_distinct(celltypes_abbrev), .by = gene_symbol)

celltypes_per_gene |>
  dplyr::left_join(modules_per_gene, by = join_by(gene_symbol)) |>
  dplyr::left_join(df_summary, by = join_by(gene_symbol)) |>
  readr::write_tsv(here("03_data/999_data_for_publication/cytoscape_edgelist_metadata.tsv"))
induced_subgraph(graph = overall_network, vids = module_sub$gene) |>
  as_edgelist() |>
  as.data.frame() |>
  na.omit() |>
  readr::write_tsv(here("03_data/999_data_for_publication/cytoscape_edgelist_ensembl.tsv"))
  
# Create a named vector for easy lookup
ensembl_to_symbol <- setNames(module_sub$hgnc_symbol, module_sub$gene)
network <- induced_subgraph(graph = overall_network, vids = module_sub$gene)
# Add gene symbols to the graph vertices
V(network)$name <- ensembl_to_symbol[V(network)$name]
  network |>
    as_edgelist() |>
    as.data.frame() |>
    na.omit() |>
    readr::write_tsv(here("03_data/999_data_for_publication/cytoscape_edgelist_genesymbol.tsv"))
    

plot_network_ggraph <- function(group, module_df, overall_network = my_network,
                                network_layout = "auto") {
  require(ggraph)
  require(tidygraph)
  
  df <- module_df |>
    dplyr::group_by(label, module) |>
    dplyr::mutate(genes_in_module = n()) |>
    dplyr::ungroup() |>
    dplyr::filter(genes_in_module > 1) |>
    # If there's no module labels just replace with module numbers
    dplyr::mutate(module_label = if_else(is.na(module_label), as.character(module), module_label))
  
  
  set.seed(1234)
  subgraph <- induced_subgraph(graph = overall_network, vids = df$gene)
  all_genes <- unique(df$hgnc_symbol)
  # Create a named vector for easy lookup
ensembl_to_symbol <- setNames(df$hgnc_symbol, df$gene)

# Add gene symbols to the graph vertices
V(subgraph)$hgnc_symbol <- ensembl_to_symbol[V(subgraph)$name]
  # Convert igraph to tidygraph
  tbl_graph <- as_tbl_graph(subgraph)
  
  celltype <- df |>
    dplyr::filter(label == group)
  
  # Get additional genes
  genes <- unique(df$gene)[!unique(df$gene) %in% celltype$gene]
  additional_genes <- df |>
    dplyr::filter(gene %in% genes) |>
    dplyr::distinct(gene, .keep_all = TRUE) |>
    dplyr::mutate(module_color = "grey", module_label = "Other celltype/s")
  
  # Combine with celltype specific stuff 
  df <- rbind(celltype, additional_genes) |>
    dplyr::mutate(module_label = if_else(module_label == "0", "< 3 proteins", module_label))
  
  # Add module information to the graph
  tbl_graph <- tbl_graph %>%
    activate(nodes) %>%
    mutate(module_number = df$module,
           module_color = df$module_color,
           module_label = df$module_label,
           group = df$label,
           gene_name = df$gene_symbol)
  
  # Plot using ggraph
  p <- ggraph(tbl_graph, layout = network_layout) +  # 'fr' layout for Fruchterman-Reingold
    geom_edge_link(aes(edge_alpha = 0.5), edge_colour = "grey", 
                   edge_linetype = "solid", show.legend = FALSE) +
    geom_node_point(aes(color = module_label), size = 5) +
    geom_node_text(aes(label = gene_name), repel = TRUE, size = 5) +
    scale_color_manual(values = setNames(df$module_color, df$module_label)) +
    theme_void() +
    theme(legend.position = "right") +
    guides(color = guide_legend(override.aes = list(size = 5))) +
    labs(color = "Module Function", title = unique(df$celltype))
  
  # if(length(unique(df$label)) > 1) {
  #   p <- p + facet_wrap(~ group)  # Facet by group
  # }
  
  return(p)
}

plots <- map(unique(module_sub$label), plot_network_ggraph, module_sub, network_layout = "fr") |>
  set_names(unique(module_sub$label))
```

- NOTE: I can't seem to get ggraph to plot the nodes in the same way, so I'll try exporting the network as an edgelist and the data table of the celltypes and do it manually. May also need to mess with the ensembl vs gene symbol labels...


```{r}
module_sub <- modules |>
  dplyr::filter(grepl("all_controls_top-ten-percent", label)) |>
  dplyr::filter(!grepl("_extended_", label)) |>
  dplyr::left_join(celltype_abbrev_df, by = join_by(celltype)) |>
  dplyr::mutate(celltypes_abbrev = if_else(is.na(celltypes_abbrev), celltype, celltypes_abbrev),
                case_control = if_else(grepl("_case", label), "case", "control"),
                celltype_level = if_else(grepl("level1", label), "level1", "level2"))

# Summarize the presence of each gene in the case_control groups
gene_summary <- module_sub %>%
  summarize(
    in_case = any(case_control == "case"),
    in_control = any(case_control == "control"),
  .by = c(celltypes_abbrev, celltype_level, gene_symbol))

# Join the summary back to the original dataframe
module_sub <- module_sub %>%
  left_join(gene_summary, by = join_by(celltypes_abbrev, celltype_level, gene_symbol)) %>%
  dplyr::mutate(
    unique_genes_per_celltype = case_when(
      in_case & !in_control ~ "case_only",
      !in_case & in_control ~ "control_only",
      in_case & in_control ~ "both",
      .default = NA
    )
  ) %>%
  dplyr::select(-in_case, -in_control)

# Do the same for overall genes
gene_summary <- module_sub %>%
  summarize(
    in_case = any(case_control == "case"),
    in_control = any(case_control == "control"),
  .by = c(gene_symbol))

module_sub <- module_sub %>%
  left_join(gene_summary, by = join_by(gene_symbol)) %>%
  dplyr::mutate(
    unique_genes_overall = case_when(
      in_case & !in_control ~ "case_only",
      !in_case & in_control ~ "control_only",
      in_case & in_control ~ "both",
      .default = NA
    )
  ) %>%
  dplyr::select(-in_case, -in_control)

table(module_sub$unique_genes_per_celltype)

df <- module_sub |>
  dplyr::filter(celltypes_abbrev == "Microglia-A")

overall_network = my_network
network_layout = "auto"

  
set.seed(1234)
subgraph <- induced_subgraph(graph = overall_network, vids = df$gene)
all_genes <- unique(df$hgnc_symbol)
# Create a named vector for easy lookup
ensembl_to_symbol <- setNames(df$hgnc_symbol, df$gene)

# Add gene symbols to the graph vertices
V(subgraph)$hgnc_symbol <- ensembl_to_symbol[V(subgraph)$name]
  # Convert igraph to tidygraph
  tbl_graph <- as_tbl_graph(subgraph)
  
  # celltype <- df |>
  #   dplyr::filter(label == group)
  # 
  # # Get additional genes
  # genes <- unique(df$gene)[!unique(df$gene) %in% celltype$gene]
  # additional_genes <- df |>
  #   dplyr::filter(gene %in% genes) |>
  #   dplyr::distinct(gene, .keep_all = TRUE) |>
  #   dplyr::mutate(module_color = "grey", module_label = "Other celltype/s")
  # 
  # # Combine with celltype specific stuff 
  # df <- rbind(celltype, additional_genes) |>
  #   dplyr::mutate(module_label = if_else(module_label == "0", "< 3 proteins", module_label))
  
  microglia_risk_genes <- df |>
    dplyr::select(gene, gene_symbol, unique_genes_per_celltype, 
                  celltypes_abbrev) |>
    dplyr::distinct() |>
    pivot_wider(names_from = unique_genes_per_celltype, values_from = unique_genes_per_celltype) |>
    unite("case_control", case_only:control_only, na.rm = TRUE)
  
  # Add module information to the graph
  tbl_graph <- tbl_graph %>%
    activate(nodes) %>%
    mutate(group = microglia_risk_genes$case_control,
           gene_name = microglia_risk_genes$gene_symbol)
  
  # Plot using ggraph
  p <- ggraph(tbl_graph, layout = network_layout) +  # 'fr' layout for Fruchterman-Reingold
    geom_edge_link(aes(edge_alpha = 0.5), edge_colour = "grey", 
                   edge_linetype = "solid", show.legend = FALSE) +
    geom_node_point(aes(color = group), size = 5) +
    geom_node_text(aes(label = gene_name), repel = TRUE, size = 5) +
    theme_void() +
    theme(legend.position = "right") +
    guides(color = guide_legend(override.aes = list(size = 5))) +
    labs(color = "case_control", title = microglia_risk_genes$celltypes_abbrev)
  
p
ggsave(here::here("05_figures/990_shared_figures/001_magma/ppi_sig_networks", "microglia-a_case-control.png"), height = 12, width = 14)
```

```{r}
df <- module_sub |>
  dplyr::filter(celltype_level == "level2" & grepl("Pericyte", celltypes_abbrev))

gene_summary <- df %>%
  summarize(
    in_case = any(case_control == "case"),
    in_control = any(case_control == "control"),
  .by = c(gene_symbol))

# Join the summary back to the original dataframe
df <- df |>
  left_join(gene_summary, by = join_by(gene_symbol)) |>
  dplyr::mutate(
    unique_genes_per_celltype = case_when(
      in_case & !in_control ~ "case_only",
      !in_case & in_control ~ "control_only",
      in_case & in_control ~ "both",
      .default = NA
    )
  ) %>%
  dplyr::select(-in_case, -in_control)

overall_network = my_network
network_layout = "auto"
  
set.seed(1234)
subgraph <- induced_subgraph(graph = overall_network, vids = df$gene)
all_genes <- unique(df$hgnc_symbol)
# Create a named vector for easy lookup
ensembl_to_symbol <- setNames(df$hgnc_symbol, df$gene)

# Add gene symbols to the graph vertices
V(subgraph)$hgnc_symbol <- ensembl_to_symbol[V(subgraph)$name]
  # Convert igraph to tidygraph
  tbl_graph <- as_tbl_graph(subgraph)
  
  # celltype <- df |>
  #   dplyr::filter(label == group)
  # 
  # # Get additional genes
  # genes <- unique(df$gene)[!unique(df$gene) %in% celltype$gene]
  # additional_genes <- df |>
  #   dplyr::filter(gene %in% genes) |>
  #   dplyr::distinct(gene, .keep_all = TRUE) |>
  #   dplyr::mutate(module_color = "grey", module_label = "Other celltype/s")
  # 
  # # Combine with celltype specific stuff 
  # df <- rbind(celltype, additional_genes) |>
  #   dplyr::mutate(module_label = if_else(module_label == "0", "< 3 proteins", module_label))
  
  df <- df |>
    dplyr::select(gene, gene_symbol, unique_genes_per_celltype) |>
    dplyr::distinct() |>
    pivot_wider(names_from = unique_genes_per_celltype, values_from = unique_genes_per_celltype) |>
    unite("case_control", both:control_only, na.rm = TRUE)
  
  # Add module information to the graph
  tbl_graph <- tbl_graph %>%
    activate(nodes) %>%
    mutate(group = df$case_control,
           gene_name = df$gene_symbol)
  
  # Plot using ggraph
  p <- ggraph(tbl_graph, layout = network_layout) +  # 'fr' layout for Fruchterman-Reingold
    geom_edge_link(aes(edge_alpha = 0.5), edge_colour = "grey", 
                   edge_linetype = "solid", show.legend = FALSE) +
    geom_node_point(aes(color = group), size = 5) +
    geom_node_text(aes(label = gene_name), repel = TRUE, size = 5) +
    theme_void() +
    theme(legend.position = "right") +
    guides(color = guide_legend(override.aes = list(size = 5))) +
    labs(color = "case_control", title = "Level 2 periyte overlaps")
  
p
ggsave(here::here("05_figures/990_shared_figures/001_magma/ppi_sig_networks", "pericyte_case-control.png"), height = 12, width = 14)
  

```

### MAGMA for case vs control risk genes

```{r}
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/risk_case-control_go_terms.qs"
  )

gene_list <- microglia_risk_genes |>
  dplyr::group_by(case_control) |>
  tidyr::nest()

if (!file.exists(file)) {
  plan("multisession", workers = parallel::detectCores() - 1)
  result_list_bp <- future_map(
    gene_list$data,
    ~ enrichGO(
      gene          = .x$gene,
      OrgDb         = org.Hs.eg.db,
      keyType       = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont           = "BP",
      universe      = gene_ensembl_ids$ensembl,
      pAdjustMethod = "BH",
      qvalueCutoff  = 0.05,
      readable      = TRUE
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$case_control, "_BP"))
  result_list_cc <- future_map(
    gene_list$data,
    ~ enrichGO(
      gene          = .x$gene,
      OrgDb         = org.Hs.eg.db,
      keyType       = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont           = "CC",
      universe      = gene_ensembl_ids$ensembl,
      pAdjustMethod = "BH",
      qvalueCutoff  = 0.05,
      readable      = TRUE
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$case_control, "_CC"))
  result_list_mf <- future_map(
    gene_list$data,
    ~ enrichGO(
      gene          = .x$gene,
      OrgDb         = org.Hs.eg.db,
      keyType       = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont           = "MF",
      universe      = gene_ensembl_ids$ensembl,
      pAdjustMethod = "BH",
      qvalueCutoff  = 0.05,
      readable      = TRUE
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$case_control, "_MF"))
  result_list <- c(result_list_bp, result_list_mf, result_list_cc)
  rm(result_list_bp, result_list_cc, result_list_mf)
  
  qs::qsave(result_list, file)
} else {
  result_list <- qs::qread(file)
}


# Remove any NULL entries
result_list <- result_list[!sapply(result_list, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(result_list, is.null)) == 0)
# Filter the list to keep only elements where the 'result' slot has rows
result_list <- result_list[sapply(result_list, function(x) nrow(x@result) > 0)]
# Filter to only those wtih sig enrichments
result_list <- result_list[sapply(result_list, function(x) sum(x@result$p.adjust < 0.05) > 0)]
```

```{r}
# Get semantic similarity of terms
result_list <- map(result_list, pairwise_termsim)

# Define a safe version of your treeplot function that returns NULL on error
safe_treeplot <- possibly(treeplot, otherwise = NULL)
# Use map with the safe version of the function
plan("multisession", workers = parallel::detectCores() - 1)
treeplots <- future_map(result_list, safe_treeplot)

# Remove any NULL entries
treeplots <- treeplots[!sapply(treeplots, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(treeplots, is.null)) == 0)
# Replace those with no treeplot with dotplots
no_treeplot <- names(result_list)[!names(result_list) %in% names(treeplots)]
dotplots <- map(result_list[no_treeplot], dotplot)
assertthat::see_if(sum(map_lgl(dotplots, is.null)) == 0)
treeplots <- c(treeplots, dotplots)

treeplots <- map2(treeplots, names(treeplots), ~ .x + ggtitle(.y))
treeplots$case_only_BP + treeplots$case_only_CC + treeplots$case_only_MF
treeplots$both_BP + treeplots$both_CC + treeplots$both_CC
treeplots$control_only_MF + treeplots$control_only_CC

treeplot_groups <- names(treeplots) |> str_sub(1, -4) |> unique()

plots <- map(treeplot_groups, ~ {
  plots <- treeplots[grepl(.x, names(treeplots))]
  plot <- purrr::reduce(plots, `+`)
  return(plot)
}) |>
  set_names(treeplot_groups)

walk2(plots, names(plots), ~ ggsave(
  filename = here::here("05_figures/990_shared_figures/001_magma/", paste0(.y, "risk_genes_go.png")),
  plot = .x,
  width = 24,
  height = 14
))
```


## For each module

```{r}
#| eval: false
# Plot each community separately
#par(mfrow = c(2, 3))
mcl <- membership(cl)
for (i in which(table(cl$membership) >= min_cluster_size)) {
  #i=1
  community_vertices <- which(mcl == i)
  
  # Create a subgraph for the current community
  subgraph <- induced_subgraph(my_subgraph, community_vertices)
  # xx <- subset(module_assignment, module == i)
  V(subgraph)$hgnc_symbol <- module_assignment[match(V(subgraph)$name, module_assignment$gene), "hgnc_symbol"]
 # V(subgraph)$colors <- module_assignment[match(V(subgraph)$name, module_assignment$gene), "known"]

  # Plot the subgraph with community-specific information
  #png(paste("Known and 90 pain genes M",i,".png",sep = ""))
  plot(subgraph,vertex.size=7, vertex.label.dist=2, vertex.label.cex=0.8, 
       vertex.label = V(subgraph)$hgnc_symbol, vertex.color = V(subgraph)$colors )
  box()
  #dev.off()
}

```

```{r}
# Plot clustering
map2(subgraphs, module_assignment, ~ plot(.x, 
     vertex.size = 3, 
     vertex.color = as.character(.y$module_color), 
     vertex.frame.color = .y$module_color, 
     edge.color = "grey",  
     rescale = TRUE, 
     vertex.label = NA,
     main = paste0("Celltype: ", .y$label[1])))

# Save clustering as file
readr::write_delim(list_rbind(module_assignment), file = output_file2)
#modules <- readr::read_delim(file = output_file2)
```

## Module assignment

Having assigned the genes to modules the next thing to do is choose which celltypes to take forward to assign functions via GO pathways to.

```{r}
# Get modules assignment
modules <- list_rbind(module_assignment)

# Get number of genes per celltypes
gene_num <- map_dbl(my_gene_list$full_background, length)
# Check the gene numbers per celltypes of interest
gene_num <- gene_num[names(gene_num) %in% sig_celltypes$gene_list]
gene_num
# Get the celltypes with fewer than 30 genes
celltypes_with_few_genes <- names(gene_num)[gene_num < 30]
```

For cases where the number of genes is small, there isn't a need to use the clusters, though there isn't a rule of thumb for a cutoff for this.
Given most of the celltypes in this case have more than 30 genes, I'll run those that aren't through GO as they are, but the others I'll do per Louvain cluster.

```{r}
modules_sig <- modules |>
  # Filiter to sig celltypes
  dplyr::filter(label %in% sig_celltypes$gene_list) |>
  # Update modules for celltypes with low number of genes to all be the same
  dplyr::mutate(module_updated = case_when(
    label %in% celltypes_with_few_genes ~ 1,
    .default = module
  )) |>
  dplyr::select(!c(hgnc_symbol, gene.y, entrezid))

tar_load(translated_id)

modules_sig <- modules_sig |>
  dplyr::left_join(translated_id, by = join_by(gene == ensembl_gene_id)) |>
  dplyr::distinct(entrezgene_id, .keep_all = TRUE)
```

```{r}
gene_list <- modules_sig %>% 
  group_by(label, module) %>% 
  tidyr::nest()
```

### GO enrichment

```{r}
# Filter out any NULL entries if there were conversion errors
gene_list_entrez <- map(gene_list$data, ~ .x |>
                          # remove any missing data
                          dplyr::filter(!is.na(entrezgene_id)) |>
                          dplyr::pull(entrezgene_id))

entrez_background <- gene_ensembl_ids |>
  dplyr::left_join(translated_id, by = join_by(ensembl == ensembl_gene_id))
names(gene_list_entrez) <- paste0(gene_list$label, "_module", gene_list$module)

# Get tradeseq subset background
sce_subset <- qs::qread(here("03_data/990_processed_data/008_pseudotime/slingshot_tradeseq_3k_case_and_control.qs"))

tradeseq_ids <- rownames(sce_subset)

assertthat::assert_that(sum(!(
  tradeseq_ids %in% translated_id$ensembl_gene_id
)) == 0)

tradeseq_ids <- translated_id |>
  dplyr::filter(ensembl_gene_id %in% tradeseq_ids)

head(gene_list)

gene_list <- gene_list |>
  dplyr::mutate(background = if_else(grepl("lineage_", label), list(tradeseq_ids$ensembl_gene_id), list(gene_ensembl_ids$ensembl)))

gene_list_entrez_sub <-
  gene_list_entrez[sapply(gene_list_entrez, function(x)
    length(x) > 1)]

# Save file - it takes a while to compute
file <-
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/module_go_terms.rds"
  )
if(use_known_interactions_only) {
  file <-
    here::here(
      "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/module_go_terms_multicore_known_interactions.qs"
    )
} else {
  file <-
    here::here(
      "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions/module_go_terms_multicore.qs"
    )
}

  
if (!file.exists(file)) {
  plan("multisession", workers = parallel::detectCores() - 1)
  result_list_bp <- future_map2(
    gene_list$data,
    gene_list$background,
    ~ enrichGO(
      gene          = .x$gene,
      OrgDb         = org.Hs.eg.db,
      keyType       = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont           = "BP",
      universe      = .y,
      pAdjustMethod = "BH",
      qvalueCutoff  = 0.05,
      readable      = TRUE
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$label, "_module", gene_list$module, "_BP"))
  result_list_cc <- future_map2(
    gene_list$data,
    gene_list$background,
    ~ enrichGO(
      gene          = .x$gene,
      OrgDb         = org.Hs.eg.db,
      keyType       = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont           = "CC",
      universe      = .y,
      pAdjustMethod = "BH",
      qvalueCutoff  = 0.05,
      readable      = TRUE
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$label, "_module", gene_list$module, "_CC"))
  result_list_mf <- future_map2(
    gene_list$data,
    gene_list$background,
    ~ enrichGO(
      gene          = .x$gene,
      OrgDb         = org.Hs.eg.db,
      keyType       = "ENSEMBL",
      # "BP" for biological process, "MF" for molecular function, "CC" for cellular component
      ont           = "MF",
      universe      = .y,
      pAdjustMethod = "BH",
      qvalueCutoff  = 0.05,
      readable      = TRUE
    ), .options = furrr_options(seed = 123)
  ) |>
    set_names(paste0(gene_list$label, "_module", gene_list$module, "_MF"))
  result_list <- c(result_list_bp, result_list_mf, result_list_cc)
  rm(result_list_bp, result_list_cc, result_list_mf)
  
  qs::qsave(result_list, file)
} else {
  result_list <- qs::qread(file)
}


# Remove any NULL entries
result_list <- result_list[!sapply(result_list, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(result_list, is.null)) == 0)
# Filter the list to keep only elements where the 'result' slot has rows
result_list <- result_list[sapply(result_list, function(x) nrow(x@result) > 0)]
# Filter to only those wtih sig enrichments
result_list <- result_list[sapply(result_list, function(x) sum(x@result$p.adjust < 0.05) > 0)]
```

### Save for MAGMA

I want to run these modules through MAGMA later so I'll save the gene lists whilst I have them in entrez.
Note that I'm only using the modules that had more than one gene.

I'm going to save each celltypes module set to one file.

```{r}
# Save to MAGMA
names(gene_list_entrez_sub) |> head()
# Create a character vector where each element is a single string
lines_to_write <- sapply(names(gene_list_entrez), function(name) {
  paste(name, paste(gene_list_entrez[[name]], collapse = " "))
}, USE.NAMES = FALSE)

pseudobulk_lines <- lines_to_write[grepl("_pseudobulk_", lines_to_write)]
magma_gene_list_lines <- lines_to_write[!grepl("_pseudobulk_", lines_to_write)]

make_magma_input_per_celltype <- function(line_subset, subset_label) {
  # Get the line subset
  line_subset <- line_subset[grepl(subset_label, line_subset)]
  # Get celltypes
  celltypes <- sub("_.*", "", line_subset) |> unique()
  # Match celltypename from begining of line
  celltypes2 <- paste0("^", celltypes)
  # Get per celltype lines
  per_celltype_lines <- map(celltypes2, ~ line_subset[grepl(.x, line_subset)]) |>
    set_names(paste0(celltypes, "_", subset_label))
  return(per_celltype_lines)
}

pseudobulk_apoe_lines <-
  make_magma_input_per_celltype(pseudobulk_lines, "pseudobulk_apoe")
pseudobulk_no_apoe_lines <-
  make_magma_input_per_celltype(pseudobulk_lines, "pseudobulk_no_apoe")
magma_gene_list_lines <-
  make_magma_input_per_celltype(magma_gene_list_lines, "sig_magma_sig_genes")
magma_list <- c(pseudobulk_apoe_lines, pseudobulk_no_apoe_lines, magma_gene_list_lines)
# Write the character vector to a file
map2(magma_list,
     names(magma_list),
     ~ readr::write_lines(.x,
                          here::here(
                            "03_data/994_magma_inputs",
                            paste0("ppi_sig_modules_", .y, ".magma.txt")
                          )))
```

### Treeplots

```{r}
# Plotting the first module's GO enrichment result as an example
if (length(result_list[[1]]) > 0) {
  dotplot(result_list[[1]])
}

# Get semantic similarity of terms
result_list <- map(result_list, pairwise_termsim)
treeplot(result_list[[5]])

# Define a safe version of your treeplot function that returns NULL on error
safe_treeplot <- possibly(treeplot, otherwise = NULL)
# Use map with the safe version of the function
plan("multisession", workers = parallel::detectCores() - 1)
treeplots <- future_map(result_list, safe_treeplot)

# Remove any NULL entries
treeplots <- treeplots[!sapply(treeplots, is.null)]
# Assert that there are no nulls in list
assertthat::see_if(sum(map_lgl(treeplots, is.null)) == 0)
# Replace those with no treeplot with dotplots
no_treeplot <- names(result_list)[!names(result_list) %in% names(treeplots)]
dotplots <- map(result_list[no_treeplot], dotplot)
assertthat::see_if(sum(map_lgl(dotplots, is.null)) == 0)
treeplots <- c(treeplots, dotplots)

treeplots <- map2(treeplots, names(treeplots), ~ .x + ggtitle(.y))

# I want to make patchwork of plots per celltype
# Extract unique cell types from the plot names
celltypes <- unique(sub("_module.*", "", names(treeplots)))

# Split the list of plots into a nested list by cell type
get_celltype_ontology_plots <- function(celltype, ontology, plot_list) {
  plots_for_type <- plot_list[grepl(paste0("^", celltype, "_module"), names(plot_list))]
  plots_ont <- plots_for_type[grepl(ontology, names(plots_for_type))]
  combined_plot <- wrap_plots(plots_ont, ncol = 1)
  if(length(plots_ont) == 0) {
  combined_plot <- NULL
  } 
  combined_plot
}

plots_by_celltype_bp <-
  map(celltypes, get_celltype_ontology_plots, "_BP", treeplots) |>
  set_names(paste0(celltypes, "_BP"))
plots_by_celltype_cc <-
  map(celltypes, get_celltype_ontology_plots, "_CC", treeplots) |>
  set_names(paste0(celltypes, "_CC"))
plots_by_celltype_mf <-
  map(celltypes, get_celltype_ontology_plots, "_MF", treeplots) |>
  set_names(paste0(celltypes, "_MF"))

plots_by_celltype <-
  c(plots_by_celltype_bp,
    plots_by_celltype_cc,
    plots_by_celltype_mf)
# Remove nulls
plots_by_celltype <- plots_by_celltype[!sapply(plots_by_celltype, is.null)]

rm(plots_by_celltype_bp, plots_by_celltype_cc, plots_by_celltype_mf)
# save the plots nice and tall
walk2(plots_by_celltype, names(plots_by_celltype), ~ ggsave(
  filename = here::here("05_figures/990_shared_figures/ppi_modules", paste0(.y, "_combined_plot.png")),
  plot = .x,
  width = 14,
  height = 34
))
```

```{r}
#| fig-height: 25
#| fig-width: 14
plots_by_celltype
```

```{r}
result_df <- map2_dfr(result_list, names(result_list), ~ {
  .x@result |>
    dplyr::filter(p.adjust < 0.05) |>
    dplyr::mutate(label = .y, ontology = str_extract(label, "[^_]+$"),
                  module = str_extract(label, "(?:.*_)?([^_]+)(?=_[^_]+$)", 
                                       group = 1),
                  group = str_replace(label, "^((.*?_){2}.*?)_.*$", "\\1"))
}) |> as_tibble()

lineage_pathways <- result_df |>
  dplyr::filter(grepl("lineage", group) & Count > 1)

unique_module_genes <- lineage_pathways |>
  #dplyr::filter(ontology == "BP") |>
  dplyr::mutate(genes = str_split(geneID, "/")) |>
  dplyr::select(group, module, ontology, genes) |>
  unique() |>
  summarise(unique_genes = list(unique(unlist(genes))), 
            .by = c(group, module, ontology)) |>
  dplyr::mutate(plot_title = paste0(group, "-", ontology))

counts <- assays(sce_subset)$counts

plots <- map2(unique_module_genes$unique_genes, unique_module_genes$plot_title,
              ~ {
                module_genes <- translated_id |>
                  dplyr::filter(hgnc_symbol %in% .x) |>
                  dplyr::mutate(plot_title = paste0(.y, " - ", hgnc_symbol))
                print(module_genes)
                plots <- map2(module_genes$ensembl_gene_id, 
                              module_genes$plot_title, ~ 
                                plotSmoothers(sce_subset, counts, .x) +
                                ggtitle(.y))
  return(plots)
  })

plot_grids <- map(plots, ~ plot_grid(plotlist = .x))
plot_grids[[1]]

map(plots, length) |> unlist() |> sum()

pdf(here("05_figures/990_shared_figures/004_pseudotime",
         "01_tradeseq", "sig_ppi_module_pathways.pdf"), 
    width = 11, height = 8.5)
walk(plot_grids, print)
dev.off()
```

### Module labels

So there isn't really a mathematical solution to this other than eyeballing the plots and assigning module functions

#### Pseudobulk labels

```{r}
#| eval: false
# Astro module 1 has memory stuff
module_assignments <-
  c(#astro-activ
    "synapse_regulation-memory",
    "plasma_membrane",
    "anion_transport",
    "cell_adhesion",
    "basal_membrane-exosome",
    # astro-quie
    "synaptic_transmission-memory",
    "ubiquitin-complexes",
    "cell_junction-actin",
    "vascular_transport",
    "glycosylation",
    "extracellular_matrix",
    "chemotaxis-pos_reg_cascades",
    # ex-neuron l2-3
    "endothelial_migration-preptide_hormone",
    "synapse_protein_localisation",
    "ribonuclieotide_catabolic",
    "rna_splicing",
    "wnt",
    # ex-neuron-l4-5
    "extracellular_matrix_organisation",
    "negative_reg_protein_phos",
    "chromatid-mitotic_spindle",
    "glycosyltransferase",
    "bbb_transport-anion",
    "salt_reponse-calcium",
    # in-neuron
    "ubiquitin_ligasse",
    "chloride",
    "IGF",
    "vesicle-synapse",
    "gtpase_activity",
    # M-pericyte
    "adhesion",
    "endo_retic",
    "cellcell_adhesion",
    "basal_plasma_membrane-stress",
    # microglia-activated
    "amino_acid_transport-sodium_ion",
    "cholesterol",
    "peptide_catabolic",
    "gtpase_reg-binding",
    # t-pericyte
    "glutamate-synaptic",
    "basal_plasma",
    "cellcell_adhesion-synapse_organisation-epitheilal_migration",
    "neuron_projection_regulation",
    # trans-endo-to-mural
    "carboxylic_acid_transport",
    "synapce_reg-chemotaxis",
    "cytoskeleton_actin",
    "pyrimidine_metabolic")
pseudobulk_modules <- names(treeplots)[grepl("_pseudobulk_", names(treeplots))]
module_assignments <- tibble("module" = pseudobulk_modules, "label" = module_assignments)

# Save module assignment
write_csv(
  module_assignments,
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "ppi_sig_module_labels.csv"
  )
)
```

#### MAGMA sig gene labels

##### Stroke

```{r}
vascular_stroke <-
  list(
    "Arterial" = c(
      "1" = "epithelial_cell_migration",
      "3" = "stem_cell_prolif-g2_m_transition",
      "4" = "macroautophagy",
      "5" = "gtpase-axon",
      "6" = "angiogenesis"
    ),
    "Arteriolar-SMC" = c(
      "1" = "actin_org_stress",
      "2" = "autophagy",
      "4" = "heart_contraction",
      "5" = "extracell_matrix",
      "6" = "cell_dev",
      "8" = "serine_kinase"
    ),
    "Capilary" = c(
      "1" = "cell_function",
      "2" = "autophagy",
      "3" = "kidney-sex_development",
      "5" = "mrna_processing"
    ),
    "Meningeal-FB" = c(
      "1" = "extracellular_matrix",
      "2" = "dephosphorylation",
      "3" = "autophagy",
      "5" = "glycosylation",
      "6" = "rna_splicing"
    ),
    "Pericyte" = c(
      "1" = "epithelium_migration",
      "2" = "fatty_acid_synthesis",
      "3" = "rna_splice",
      "5" = "pcg_protein",
      "7" = "ubiquitination"
    ),
    "Pericyte-2" = c(
      "1" = "endosomal",
      "2" = "epithelium_migration",
      "3" = "limb_development",
      "4" = "cerebellum_development"
    ),
    "T-Pericyte" = c(
      "1" = "cytoskeleton",
      "2" = "autophagy",
      "3" = "serine_kinase",
      "4" = "axon_guidance",
      "5" = "rna_polymerase"
    ),
    "M-Pericyte" = c(
      "1" = "pos_reg_cytoskele",
      "2" = "serine_kinase",
      "3" = "autophagy",
      "4" = "neg_reg_angiogenesis",
      "5" = "cation_transport"
    ),
    "T-cell-mixed" = c(
        "1" = "cell_differentiation-axon",
        "2" = "gtpase",
        "3" = "rna_splicing",
        "4" = "ubiqutination"
      ),
    "Vascular-SMC-LINC00486" = c(
      "1" = "actin",
      "2" = "mrna",
      "3" = "gtpase",
      "4" = "histone",
      "5" = "angiogenesis"
    )
  )

# function to make df per vector
make_ppi_df <- function(module_labels, celltype, gwas, fraction, ontology = NA) {
  df <-
    tibble(
      module_label = paste0(module_labels, "-module", names(module_labels)),
      celltype = celltype,
      gwas = gwas,
      fraction = fraction,
      ontology = ontology
    )
  return(df)
}
vascular_stroke <-
  map2(vascular_stroke,
       names(vascular_stroke),
       make_ppi_df,
       "stroke",
       "controls_vascular",
       "all") |>
  list_rbind()
```

##### AD

```{r}
ad_all_controls <- list(
  "Microglia-activated" = c("1" = "Lymphocyte activation", "2" = "Amyloid", "3" = "Dephosphorylation"),
  "Pericyte-2" = c("1" = "Amyloid", "3" = "Supramolecular fibre organisation"),
  "Perivascular-FB-KAZN2" = c("2" = "Amyloid", "4" = "Viral process", "1" = "Axon terminus")
)
module_labels <-
  map2(ad_all_controls,
       names(ad_all_controls),
       make_ppi_df,
       "ad",
       "all_controls",
       "all") |>
  list_rbind() |>
  rbind(vascular_stroke)

ad_parenchymal <- list(
  "Microglia-activated" = c("1" = "synapse", "2" = "gtpase", "3" = "tcell_activation", "4" = "mirna", "5" = "amyloid"),
  "Microglia-quiescent" = c("1" = "synaptic_transmission", "2" = "immune_response", "4" = "actin_filament", "5" = "golgi", "6" = "ion_transport")
)

module_labels <-
  map2(ad_parenchymal,
       names(ad_parenchymal),
       make_ppi_df,
       "ad",
       "controls_parenchymal",
       "all") |>
  list_rbind() |>
  rbind(module_labels)
```

```{r}
ad_all_controls_bp <- list(
  "Microglia-activated" = c("1" = "leukocyte_activation", "2" = "actin_filament", "3" = "amyloid", "4" = "gtpas", "6" = "viral"),
  "Pericyte-2" = c("1" = "amyloid", "3" = "actin_filament", "4" = "circadian", "5" = "viral"),
  "Perivascular-FB-KAZN2" = c("1" = "notch", "3" = "amyloid", "5" = "viral")
)
module_labels <-
  map2(ad_all_controls_bp,
       names(ad_all_controls_bp),
       make_ppi_df,
       "ad",
       "all_controls",
       "BP") |>
  list_rbind() |>
  rbind(module_labels)

all_magma_sig_celltype_genes_bp <- list(
  "All-celltypes" = c("1" = "leukocyte_activation", "3" = "amyloid", "4" = "notch_sig-endothelial-migration")
)
module_labels <-
  map2(all_magma_sig_celltype_genes_bp,
       names(all_magma_sig_celltype_genes_bp),
       make_ppi_df,
       "ad",
       "all_controls",
       "BP") |>
  list_rbind() |>
  rbind(module_labels)
```

```{r}
readr::write_csv(
  module_labels,
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "ppi_magma_sig_genes_module_labels.csv"
  )
)
```

```{r}
#| eval: false
# Add gene symbols
modules_sig <- modules_sig |>
  dplyr::rename(ensembl = gene) |>
  dplyr::left_join(gene_ensembl_ids, by = "ensembl")
# Check there's no NAs
assertthat::are_equal(sum(is.na(modules_sig$gene)), 0)

# subset to desired celltypes
module_sub <- modules_sig |>
  dplyr::filter(grepl("EUROPEUKBB", label) & grepl("all_controls_top-ten-percent", label) | label == "sig_magma_celltypes") |>
  dplyr::mutate(gwas = ifelse(grepl("EUROPEUKBB|sig_magma_celltypes", label), "ad", NA),
                # use str_extract to extract everything until the first "_"
                celltype = str_extract(label, "^[^_]*")) |>
dplyr::mutate(celltype = ifelse(celltype == "sig", "All-celltypes", celltype))

# use str_extract to extract characters after "-module" to get module numbers
module_labels$module <- str_extract(module_labels$module_label, "(?<=-module).+") |>
  as.numeric()
module_labels_sub <- module_labels |>
  dplyr::filter(ontology == "BP")

# join module labels
module_sub <- module_sub |>
  dplyr::left_join(module_labels_sub, by = join_by(module, gwas, celltype))
# save data
readr::write_csv(module_sub, here::here("03_data/990_processed_data/007_magma/sig_celltype_module_labels_with_genes.csv"))

# look at amyloid modules in particular
amyloid_modules <- module_sub |>
  dplyr::filter(grepl("amyloid", module_label)) |>
dplyr::filter(celltype != "All-celltypes")
amyloid_modules |> dplyr::select(!label)

df_list <- split(amyloid_modules$gene, amyloid_modules$celltype)

unique_genes <- lapply(names(df_list), function(x) {
  current_genes <- df_list[[x]]
  other_genes <- unlist(df_list[names(df_list) != x])
  unique_genes <- setdiff(current_genes, other_genes)
  return(unique_genes)
})
names(unique_genes) <- names(df_list)
unique_genes <- unique_genes |>
  stack() |>
  dplyr::rename(gene = values, celltype_specificty = ind) |>
  dplyr::mutate(shared_or_unique_gene = "unique")
unique_genes

if (nrow(unique_genes) != nrow(amyloid_modules)) {
  common_genes <- data.frame(
    "gene" = Reduce(intersect, df_list),
    "celltype_specificty" = "NA",
    "shared_or_unique_gene" = "shared"
  )
  
} else {
  common_genes <- NULL
}
rbind(unique_genes, common_genes)
#readr::write_csv(rbind(unique_genes, common_genes), here::here("../../../gmbh_results_summaries/2024-04-52_ad_bbb/sig_celltype_amyloid_genes.csv"))
```

## Plot labelled modules

It'd be nice to have the PPI networks with the module labels attached

```{r}
#| eval: false
# Plot clustering
map2(subgraphs, module_assignment, ~ plot(.x, 
     vertex.size = 3, 
     vertex.color = as.character(.y$module_color), 
     vertex.frame.color = .y$module_color, 
     edge.color = "grey",  
     rescale = TRUE, 
     vertex.label = NA,
     main = paste0("Celltype: ", .y$label[1])))

# subset to celltypes of interest
#module_sub <- module_assignment[(grepl("EUROPEUKBB", names(module_assignment)) & grepl("all_controls_top-ten-percent", names(module_assignment)))] 
subgraphs_sub <- subgraphs[(grepl("EUROPEUKBB", names(subgraphs)) & grepl("all_controls_top-ten-percent", names(subgraphs)))]

# make module label list for plots
module_sub_list <- module_sub |>
  dplyr::filter(!is.na(module_label)) |>
  dplyr::group_by(label) |>
  tidyr::nest()
list <- module_sub_list$data |>
  set_names(module_sub_list$label)

map2(subgraphs_sub, list, ~ {
  png(
    here::here(
      "05_figures/990_shared_figures/ppi_modules/network_plots",
      paste0(.y$celltype[1], "_magma_risk_ppi.png")
    )
  )
  
  
  df <- data.frame(module_label = unique(.y$module_label))
  df$colours <- rainbow(n = nrow(df))
  df <- left_join(.y, df, by = "module_label")
  plot(
    .x,
    vertex.size = 3,
    vertex.color = as.character(df$colours),
    vertex.frame.color = df$colours,
    edge.color = 'grey',
    rescale = TRUE,
    vertex.label = NA,
    main = paste0('Celltype: ', df$celltype[1])
  )
  # Assuming you have a vector of unique labels and corresponding colors
  unique_labels <- df |>
    dplyr::select(module_label, colours) |>
    unique()
  #colors_for_legend <- unique(as.character(.y)) # Replace with actual colors if different
  legend(
    "topright",
    # Position of the le
    legend = unique_labels$module_label,
    # Text in the le
    col = unique_labels$colours,
    # Colors in the legend
    pch = 19,
    # Type of point to use, 19 is a solid circle
    cex = 0.8 # Size of legend text
  )
  
  dev.off()
})
```

### networkD3 graph

Let's try using `networkD3` to make some nicer visualisations, and be able to see what genes are in the nodes

```{r}
#| eval: false
# In case they are not selected from the ppi network check that they are in the ppi network
genes_of_interest <- intersect(sig_celltypes_magma$data[[1]]$ensembl, V(my_network)$name)


# Subset the ppi network to your genes of interest
my_network_sub <- induced_subgraph(graph = my_network, vids = genes_of_interest)
my_network_sub <- as_edgelist(my_network_sub)

# You can use Gene IDs instead of Ensembl Gene IDs if you have the corresponding annotations
# for example gene_info containing Gene_ID / Ensembl IDs  to Gene_Name correspondence 
# my_network[, 1] <- gene_info$Gene_name[match(x = my_network[, 1], table = gene_info$Gene_ID)]
# my_network[, 2] <- gene_info$Gene_name[match(x = my_network[, 2], table = gene_info$Gene_ID)]

unique_genes_df <- module_sub |>
  dplyr::filter(celltype != "All-celltypes") |>
  group_by(ensembl) |>
  summarise(celltypes_with_gene = toString(unique(celltype))) |>
  ungroup()

nodes_table <- module_sub |>
dplyr::filter(celltype == "All-celltypes") |>
dplyr::left_join(unique_genes_df, by = "ensembl") |>
dplyr::mutate(module_plus_celltypes = paste0(module_label, " ", celltypes_with_gene)) |>
dplyr::mutate(module_label = ifelse(is.na(module_label), "no_label", module_label))
#dplyr::filter(!is.na(module_label))

# Nodes table 
#nodes <- unique(c(my_network_sub[, 1], my_network_sub[, 2]))
#nodes_table <- data.frame(name = nodes,
#                          # Change here for your relevant annotations 
#                          group1 = sample(x = c("A", "B", "C"), size = length(nodes), replace = TRUE),
#                          group2 = sample(x = c("typeI", "typeII"), size = length(nodes), replace = TRUE),
#                          size = 1)

# Links table
links_table <- data.frame(my_network_sub)
links_table$X1 <- match(links_table$X1, nodes_table$ensembl) - 1
links_table$X2 <- match(links_table$X2, nodes_table$ensembl) - 1
colnames(links_table) <- c("source", "target")

# Plot by your first set of annotations
module_plot <- forceNetwork(Links = links_table, Nodes = nodes_table, 
             # In case you want specific colours
             colourScale = networkD3::JS('d3.scaleOrdinal().domain(["leukocyte_activation-module1", "notch_sig-endothelial-migration-module4", "amyloid-module3", "no_label"]).range(["blue", "red", "limegreen", "grey"])'), 
             linkColour = alpha("grey", .5), 
             charge = -20, 
             Source = "source", 
             Target = "target",
             NodeID = "gene",
             Group = "module_label", 
             opacity = 0.8, 
             bounded = TRUE,
             legend = TRUE,
             opacityNoHover = .5)#,
             #Nodesize = "celltypes_with_gene")

# Plot by your second annotation
celltypes_plots <- forceNetwork(Links = links_table, Nodes = nodes_table, 
             # In case you want specific colours
             colourScale = networkD3::JS('d3.scaleOrdinal().domain(["typeI", "typeII"]).range(["deeppink", "steelblue"])'), 
             linkColour = alpha("grey", .5),
             charge = -20,
             Source = "source", 
             Target = "target",
             NodeID = "gene", 
             Group = "celltypes_with_gene", 
             opacity = 0.8, 
             bounded = TRUE, 
             legend = TRUE,
             opacityNoHover = .5) 
combined_plot <- manipulateWidget::combineWidgets(module_plot, celltypes_plots, ncol = 2)
combined_plot

# Save both plots to an HTML file
htmlwidgets::saveWidget(combined_plot, here::here("05_figures/990_shared_figures/ppi_modules/network_plots/d3_plots.html"))

# Use webshot to take a screenshot of the HTML file and save it as an image
webshot::webshot(here::here("05_figures/990_shared_figures/ppi_modules/network_plots/d3_plots.html"), file = here::here("05_figures/990_shared_figures/ppi_modules/network_plots/d3_plots.png"))

nodes_table_sub <- nodes_table |>
dplyr::filter(celltypes_with_gene %in% c("Pericyte-2", "Microglia-activated", "Perivascular-FB-KAZN2"))

my_network_sub <- induced_subgraph(graph = my_network, vids = unique(nodes_table_sub$ensembl))
my_network_sub <- as_edgelist(my_network_sub)

# Links table
links_table <- data.frame(my_network_sub)
links_table$X1 <- match(links_table$X1, nodes_table_sub$ensembl) - 1
links_table$X2 <- match(links_table$X2, nodes_table_sub$ensembl) - 1
colnames(links_table) <- c("source", "target")

# Plot by your first set of annotations
module_plot <- forceNetwork(Links = links_table, Nodes = nodes_table_sub, 
             # In case you want specific colours
             colourScale = networkD3::JS('d3.scaleOrdinal().domain(["leukocyte_activation-module1", "notch_sig-endothelial-migration-module4", "amyloid-module3", "no_label"]).range(["blue", "red", "limegreen", "grey"])'), 
             linkColour = alpha("grey", .5), 
             charge = -20, 
             Source = "source", 
             Target = "target",
             NodeID = "gene",
             Group = "module_label", 
             opacity = 0.8, 
             bounded = TRUE,
             legend = TRUE,
             opacityNoHover = .5)#,
             #Nodesize = "celltypes_with_gene")

# Plot by your second annotation
celltypes_plots <- forceNetwork(Links = links_table, Nodes = nodes_table_sub, 
             # In case you want specific colours
             colourScale = networkD3::JS('d3.scaleOrdinal().domain(["Microglia-activated", "Pericyte-2", "Perivascular-FB-KAZN2"]).range(["deeppink", "steelblue", "yellow"])'), 
             linkColour = alpha("grey", .5),
             charge = -20,
             Source = "source", 
             Target = "target",
             NodeID = "gene", 
             Group = "celltypes_with_gene", 
             opacity = 0.8, 
             bounded = TRUE, 
             legend = TRUE,
             opacityNoHover = .5) 
combined_plot <- manipulateWidget::combineWidgets(module_plot, celltypes_plots, ncol = 2)
combined_plot

nodes_table_sub <- nodes_table |>
dplyr::filter(celltypes_with_gene %in% c("Pericyte-2", "Microglia-activated", "Perivascular-FB-KAZN2")) |>
dplyr::filter(module_label == "amyloid-module3")

my_network_sub <- induced_subgraph(graph = my_network, vids = unique(nodes_table_sub$ensembl))
my_network_sub <- as_edgelist(my_network_sub)

# Links table
links_table <- data.frame(my_network_sub)
links_table$X1 <- match(links_table$X1, nodes_table_sub$ensembl) - 1
links_table$X2 <- match(links_table$X2, nodes_table_sub$ensembl) - 1
colnames(links_table) <- c("source", "target")

# Plot by your second annotation
celltypes_plots <- forceNetwork(Links = links_table, Nodes = nodes_table_sub, 
             # In case you want specific colours
             colourScale = networkD3::JS('d3.scaleOrdinal().domain(["Microglia-activated", "Pericyte-2", "Perivascular-FB-KAZN2"]).range(["deeppink", "steelblue", "yellow"])'), 
             linkColour = alpha("grey", .5),
             charge = -20,
             Source = "source", 
             Target = "target",
             NodeID = "gene", 
             Group = "celltypes_with_gene", 
             opacity = 0.8, 
             bounded = TRUE, 
             legend = TRUE,
             opacityNoHover = .5) 
celltypes_plots

combined_plot <- manipulateWidget::combineWidgets(module_plot, celltypes_plots, ncol = 2)
combined_plot
```


```{r}
#| eval: false
unique_genes_to_plot <- rbind(unique_genes, common_genes) |>
dplyr::left_join(gene_ensembl_ids, by = "gene") |>
  dplyr::mutate(celltype_specificty = as.character(celltype_specificty)) |>
  dplyr::mutate(celltype_specificty = ifelse(celltype_specificty == "NA", "Shared-genes", celltype_specificty))

# In case they are not selected from the ppi network check that they are in the ppi network
genes_of_interest <- intersect(unique_genes_to_plot$ensembl, V(my_network)$name)
assertthat::are_equal(length(unique_genes_to_plot$gene), length(genes_of_interest))



# Subset the ppi network to your genes of interest
my_network_sub <- induced_subgraph(graph = my_network, vids = genes_of_interest)
my_network_sub <- as_edgelist(my_network_sub)

# Links table
links_table <- data.frame(my_network_sub)
links_table$X1 <- match(links_table$X1, unique_genes_to_plot$ensembl) - 1
links_table$X2 <- match(links_table$X2, unique_genes_to_plot$ensembl) - 1
colnames(links_table) <- c("source", "target")

# Plot by your first set of annotations
module_plot <- forceNetwork(Links = links_table, Nodes = unique_genes_to_plot, 
             # In case you want specific colours
             colourScale = networkD3::JS('d3.scaleOrdinal().domain(["Microglia-activated", "Pericyte-2", "Perivascular-FB-KAZN2", "Shared-genes"]).range(["deeppink", "steelblue", "red", "limegreen"])'), 
             linkColour = alpha("grey", .5), 
             charge = -150, 
             Source = "source", 
             Target = "target",
             NodeID = "gene",
             Group = "celltype_specificty", 
             opacity = 1, 
             bounded = TRUE,
             legend = TRUE,
             zoom = TRUE,
             height = 400,
             width = 500,
             opacityNoHover = .5)#,
             #Nodesize = "celltypes_with_gene")
module_plot


# doesn't work due to phanotomJS error, likely due to incompatible version of openssl
# module_plot <- forceNetwork(Links = links_table, Nodes = unique_genes_to_plot, 
#              # In case you want specific colours
#              colourScale = networkD3::JS('d3.scaleOrdinal().domain(["Microglia-activated", "Pericyte-2", "Perivascular-FB-KAZN2", "Shared-genes"]).range(["deeppink", "steelblue", "red", "limegreen"])'), 
#              linkColour = alpha("grey", .5), 
#              charge = -150, 
#              Source = "source", 
#              Target = "target",
#              NodeID = "gene",
#              Group = "celltype_specificty", 
#              opacity = 1, 
#              bounded = TRUE,
#              legend = TRUE,
#              zoom = TRUE,
#              opacityNoHover = .5)#,
#              #Nodesize = "celltypes_with_gene")
# 
# htmlwidgets::saveWidget(module_plot, here::here("test_network.html"))
# webshot::webshot(here::here("test_network.html"), file = "test_network.png", vwidth = 500, vheight = 400, zoom = 3)
```

<!-- Several of the modules have just one gene in them and I don't trust any enrichment for GO terms there, so I'll replace the module label with the gene label -->

```{r}
#| eval: false
#| include: false
# I've changed to just excluding these now
gene_num <- map_dbl(result_list_subset, ~ length(.x@gene))
one_gene <- names(gene_num)[gene_num == 1]
genes <- map_chr(one_gene, ~ result_list[[.x]]@gene)
names(genes) <- one_gene

ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
# Retrieve gene symbols
gene_info <- getBM(attributes = c('entrezgene_id', 'hgnc_symbol'),
                   filters = 'entrezgene_id',
                   values = genes,
                   mart = ensembl)

# Print the results
print(gene_info)
# Make sure there's no NAs in the conversion
assertthat::noNA(gene_info)

# Make sure genes are arranged in the same way
module_order <- names(genes)[match(gene_info$entrezgene_id, genes)]
gene_symbols <- gene_info$hgnc_symbol
names(gene_symbols) <- module_order
# There are some modules not in the module assignment as they didn't get trees 
# for being to small. I'll exclude these modules and add them to dataframe
extra_modules <- gene_symbols[!names(gene_symbols) %in% module_assignments$module]
extra_modules <- data.frame(module = names(extra_modules), label = extra_modules)
module_assignments <- rbind(module_assignments, extra_modules)
# Update labels in the dataframe
module_assignments$label[match(names(gene_symbols), module_assignments$module)] <- gene_symbols
# Save module assignment
write_csv(
  module_assignments,
  here::here(
    "03_data/990_processed_data/001_snrnaseq/12_protein_protein_interactions",
    "ppi_sig_module_labels.csv"
  )
)
```
